{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started # Device tests # This guide will walk you through the LwM2M protocol device tests module available as part of Coiote IoT Device Management platform. Device tests Azure IoT integration # With the Coiote IoT Device Management platform, you can integrate your LwM2M devices with Azure IoT Hub, Azure IoT Central, or Azure DPS. This guide will take you on a step-by-step journey through the integration process to make it seamless and efficient. Here\u2019s how you can get started with the Coiote DM \u2013 Azure IoT integration: Azure IoT Hub Azure IoT Central Azure DPS AWS integration # Integrate Coiote DM with the Amazon Web Services and gain new opportunities to leverage your IoT data. Integrate with AWS","title":"Getting started"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#device-tests","text":"This guide will walk you through the LwM2M protocol device tests module available as part of Coiote IoT Device Management platform. Device tests","title":"Device tests"},{"location":"#azure-iot-integration","text":"With the Coiote IoT Device Management platform, you can integrate your LwM2M devices with Azure IoT Hub, Azure IoT Central, or Azure DPS. This guide will take you on a step-by-step journey through the integration process to make it seamless and efficient. Here\u2019s how you can get started with the Coiote DM \u2013 Azure IoT integration: Azure IoT Hub Azure IoT Central Azure DPS","title":"Azure IoT integration"},{"location":"#aws-integration","text":"Integrate Coiote DM with the Amazon Web Services and gain new opportunities to leverage your IoT data. Integrate with AWS","title":"AWS integration"},{"location":"AWS_Integration_Guide/Configuring_AWS_integration/","text":"Configuring the integration # Follow this section to integrate your AWS services with Coiote DM. Prerequisites # An active AWS subscription with access to IoT Core, CloudFormation, CloudWatch, Lambda and Secrets Manager in supported regions. Installed AWS CLI . A Coiote DM user account with the awsiottenant role. Important It's recommended to create a Coiote DM user account dedicated exclusively for the integration. Note that the integration will work correctly only until the user with the awsiottenant role exists in Coiote DM and the AWS CloudFormation stack is appropriately configured. Supported regions # eu-central-1 eu-north-1 eu-west-1 eu-west-2 eu-west-3 us-east-1 us-east-2 us-west-1 us-west-2 If you cannot find your region, please create a GitHub issue or contact AVSystem. Create a Coiote DM REST user # To start integrating AWS with Coiote DM, you first need to create a user account that will be used to authorize and authenticate API calls from AWS in Coiote DM. To do that: Go to your Coiote DM account and from the Administration menu, select Users management . Select Add user and fill in the form: Provide Email for new user (which will be its username) and select your domain from the Domain path drop-down list. Remember to switch on the User Verified and User Enabled toggle buttons. In the Client Roles fields, pick the CoioteDM client and awsiottenant role. Click Save . Go to the Credentials tab, type a password for your user (twice), select Set password , then confirm by clicking Set password in the pop-up. Copy tasks and provide credentials for your device group in Coiote DM # The Coiote DM-side configuration of the integration is located in the dedicated AWSiotCoreCertAuth device group. To complete this side of the integration, log in as the user with the awsiottenant role (only if that user was created in the Root Domain . If not, they can not access the root groups and the tasks have to be copied from the Cloud admin account.). Then follow the steps below: Go to the Device groups panel and select a group: For the default setting, select the AWSiotCoreCertAuth group which already contains all the necessary tasks and setting values. Alternatively, create a new group and migrate the required tasks and setting values: Select the Add button, name your group and click Add . Migrate all the six tasks that have the AWS prefix in their task name: Select the AWSiotCoreCertAuth group and go to Group tasks , select the first AWS task and click Copy . In the pop-up window, click Select group in the Task target field and choose your custom integration group from the list. Remember to select the Domain of the user you created earlier. In the Actions field, select Add new task . Repeat the action for the remaining five tasks. Migrate the AWSdataPlaneEndpointAddress setting value: Select your custom integration group and go to Profiles , then select Copy from . In the pop-up window, click Select group and select the AWSiotCoreCertAuth group. Pick the AWSdataPlaneEndpointAddress setting value from the list by checking it in the Selected column, then click Copy . Enter your AWS Endpoint Name in Coiote DM: Go to Device groups , select your custom integration group (or the AWSiotCoreCertAuth group, depending on the previous step) and go to Profiles . Complete the AWS setting value: Open your command line and run the following command: aws iot describe-endpoint --endpoint-type iot:Data-ATS --region <desired-region-for-the-integration> Copy the returned result. In Coiote DM, go to the Profiles tab of your integration group and paste the result as the value for AWSdataPlaneEndpointAddress . Append :8443 port to the pasted value. Click Save . Optionally, you may now add your LwM2M devices to the integration device group so that they are ready once the integration setup is complete. Add AWS resources using the integration repository # Important To complete this step, make sure you have the appropriate AWS permissions to enter the CloudFormation service and create a stack ( for details, see the AWS CloudFormation User Guide ). To add the resources needed for the integration to your AWS services: Go to the AWS Console page ( https://console.aws.amazon.com/console/home ) and sign in. Make sure that you are in the right region. From the list of services, select CloudFormation . Create a new stack. Use the template of Amazon S3 URL from below and change placeholders [REGION-NAME] to the one you use and is supported . https://coiote-aws-int-[REGION-NAME].s3.[REGION-NAME].amazonaws.com/coiote-aws-integration-cf-template.json Choose a name for the stack and provide the parameters: Important The credentials you provide at this point should belong to the user with access to the Coiote DM group which stores the AWS configuration set in a previous step. coioteDMrestUsername - username of the created CoioteDM account. coioteDMrestPassword - password of the created CoioteDM account. coioteDMrestUri - URL address and port of your Coiote DM installation. The port should always be 8088 to enable proper mTLS-based authentication. Note For some installations, port is not required. If you don't know what port to choose, contact our support. Finalize configuring the stack and wait for its creation to finish. Once the stack is created successfully, the devices in your integration group will be automatically migrated to the AWS IoT Core. To check if your integration works correctly, go to AWS IoT Core, and from the menu, select Manage > Things , then see if your devices are listed as in here: Next steps # To learn how to perform operations on your devices, please see the Performing LwM2M operations chapter. Removing the integration # To remove the integration of AWS and Coiote DM, follow the following steps: In CoioteDM remove all the devices from the AWSiotCoreCertAuth group. Go to the CloudFormation service in AWS and select the stack that was created while setting up the integration. Delete the stack. Go to the S3 service in AWS and select the bucket with the lambda code files. Delete the files.","title":"Configuring the integration"},{"location":"AWS_Integration_Guide/Configuring_AWS_integration/#configuring-the-integration","text":"Follow this section to integrate your AWS services with Coiote DM.","title":"Configuring the integration"},{"location":"AWS_Integration_Guide/Configuring_AWS_integration/#prerequisites","text":"An active AWS subscription with access to IoT Core, CloudFormation, CloudWatch, Lambda and Secrets Manager in supported regions. Installed AWS CLI . A Coiote DM user account with the awsiottenant role. Important It's recommended to create a Coiote DM user account dedicated exclusively for the integration. Note that the integration will work correctly only until the user with the awsiottenant role exists in Coiote DM and the AWS CloudFormation stack is appropriately configured.","title":"Prerequisites"},{"location":"AWS_Integration_Guide/Configuring_AWS_integration/#supported-regions","text":"eu-central-1 eu-north-1 eu-west-1 eu-west-2 eu-west-3 us-east-1 us-east-2 us-west-1 us-west-2 If you cannot find your region, please create a GitHub issue or contact AVSystem.","title":"Supported regions"},{"location":"AWS_Integration_Guide/Configuring_AWS_integration/#create-a-coiote-dm-rest-user","text":"To start integrating AWS with Coiote DM, you first need to create a user account that will be used to authorize and authenticate API calls from AWS in Coiote DM. To do that: Go to your Coiote DM account and from the Administration menu, select Users management . Select Add user and fill in the form: Provide Email for new user (which will be its username) and select your domain from the Domain path drop-down list. Remember to switch on the User Verified and User Enabled toggle buttons. In the Client Roles fields, pick the CoioteDM client and awsiottenant role. Click Save . Go to the Credentials tab, type a password for your user (twice), select Set password , then confirm by clicking Set password in the pop-up.","title":"Create a Coiote DM REST user"},{"location":"AWS_Integration_Guide/Configuring_AWS_integration/#copy-tasks-and-provide-credentials-for-your-device-group-in-coiote-dm","text":"The Coiote DM-side configuration of the integration is located in the dedicated AWSiotCoreCertAuth device group. To complete this side of the integration, log in as the user with the awsiottenant role (only if that user was created in the Root Domain . If not, they can not access the root groups and the tasks have to be copied from the Cloud admin account.). Then follow the steps below: Go to the Device groups panel and select a group: For the default setting, select the AWSiotCoreCertAuth group which already contains all the necessary tasks and setting values. Alternatively, create a new group and migrate the required tasks and setting values: Select the Add button, name your group and click Add . Migrate all the six tasks that have the AWS prefix in their task name: Select the AWSiotCoreCertAuth group and go to Group tasks , select the first AWS task and click Copy . In the pop-up window, click Select group in the Task target field and choose your custom integration group from the list. Remember to select the Domain of the user you created earlier. In the Actions field, select Add new task . Repeat the action for the remaining five tasks. Migrate the AWSdataPlaneEndpointAddress setting value: Select your custom integration group and go to Profiles , then select Copy from . In the pop-up window, click Select group and select the AWSiotCoreCertAuth group. Pick the AWSdataPlaneEndpointAddress setting value from the list by checking it in the Selected column, then click Copy . Enter your AWS Endpoint Name in Coiote DM: Go to Device groups , select your custom integration group (or the AWSiotCoreCertAuth group, depending on the previous step) and go to Profiles . Complete the AWS setting value: Open your command line and run the following command: aws iot describe-endpoint --endpoint-type iot:Data-ATS --region <desired-region-for-the-integration> Copy the returned result. In Coiote DM, go to the Profiles tab of your integration group and paste the result as the value for AWSdataPlaneEndpointAddress . Append :8443 port to the pasted value. Click Save . Optionally, you may now add your LwM2M devices to the integration device group so that they are ready once the integration setup is complete.","title":"Copy tasks and provide credentials for your device group in Coiote DM"},{"location":"AWS_Integration_Guide/Configuring_AWS_integration/#add-aws-resources-using-the-integration-repository","text":"Important To complete this step, make sure you have the appropriate AWS permissions to enter the CloudFormation service and create a stack ( for details, see the AWS CloudFormation User Guide ). To add the resources needed for the integration to your AWS services: Go to the AWS Console page ( https://console.aws.amazon.com/console/home ) and sign in. Make sure that you are in the right region. From the list of services, select CloudFormation . Create a new stack. Use the template of Amazon S3 URL from below and change placeholders [REGION-NAME] to the one you use and is supported . https://coiote-aws-int-[REGION-NAME].s3.[REGION-NAME].amazonaws.com/coiote-aws-integration-cf-template.json Choose a name for the stack and provide the parameters: Important The credentials you provide at this point should belong to the user with access to the Coiote DM group which stores the AWS configuration set in a previous step. coioteDMrestUsername - username of the created CoioteDM account. coioteDMrestPassword - password of the created CoioteDM account. coioteDMrestUri - URL address and port of your Coiote DM installation. The port should always be 8088 to enable proper mTLS-based authentication. Note For some installations, port is not required. If you don't know what port to choose, contact our support. Finalize configuring the stack and wait for its creation to finish. Once the stack is created successfully, the devices in your integration group will be automatically migrated to the AWS IoT Core. To check if your integration works correctly, go to AWS IoT Core, and from the menu, select Manage > Things , then see if your devices are listed as in here:","title":"Add AWS resources using the integration repository"},{"location":"AWS_Integration_Guide/Configuring_AWS_integration/#next-steps","text":"To learn how to perform operations on your devices, please see the Performing LwM2M operations chapter.","title":"Next steps"},{"location":"AWS_Integration_Guide/Configuring_AWS_integration/#removing-the-integration","text":"To remove the integration of AWS and Coiote DM, follow the following steps: In CoioteDM remove all the devices from the AWSiotCoreCertAuth group. Go to the CloudFormation service in AWS and select the stack that was created while setting up the integration. Delete the stack. Go to the S3 service in AWS and select the bucket with the lambda code files. Delete the files.","title":"Removing the integration"},{"location":"AWS_Integration_Guide/Overview/","text":"Overview # Explore the guide to learn how to integrate your IoT assets with the Coiote IoT Device Management platform. To get started, follow the Configuration chapter. What is the AWS IoT Core integration? # Learn the basic concepts behind the integration by reading the Concepts chapter.","title":"Overview"},{"location":"AWS_Integration_Guide/Overview/#overview","text":"Explore the guide to learn how to integrate your IoT assets with the Coiote IoT Device Management platform. To get started, follow the Configuration chapter.","title":"Overview"},{"location":"AWS_Integration_Guide/Overview/#what-is-the-aws-iot-core-integration","text":"Learn the basic concepts behind the integration by reading the Concepts chapter.","title":"What is the AWS IoT Core integration?"},{"location":"AWS_Integration_Guide/Concepts/AWS_Integration_concepts/","text":"How AWS integration works # Here's a walkthrough of the main concepts related to the AWS IoT Core - Coiote DM integration that will help you understand the role of each of the integration components and how they are employed for the benefit of LwM2M device management via the AWS services. Things # Within the AWS IoT Core - Coiote DM integration, things are the AWS representations of LwM2M device entities managed by the Coiote DM platform. They are used to mirror device state, as well as collect, process and act upon device data on the fly using a connection protocol of your choice. Note Things are automatically added to AWS IoT Core upon completing the integration setup and successful device connection. Thing types # Thing types are containers that store configuration and other device-related information shared by all Things of the same type to simplify their bulk management. Within the integration, they are created automatically when a new device is added to AWS from Coiote DM and they are based on device Manufacturer and Model name . In case a new device with a specific Manufacturer and model name pair can be matched with an existing thing type, then it will be associated with it automatically. Note Note that you cannot modify a once created thing type, but you can deprecate (allowing no new devices to be associated with it) or delete it when there are no things associated with a given Thing type. Device Shadows # A device shadow is a structure that stores the device state and represents it in the form of a JSON file, making the device data available to applications and services regardless of device connection to Coiote DM. To synchronize device state information between the Coiote DM and AWS IoT Core, shadows feature the mechanism of reported and desired values. Reported values section - presents the current device state as reported by the device itself (and mediated by Coiote DM) in a JSON file structure within a device shadow. Desired values section - used for requesting changes in the reported section of the device Operation shadow . For the purposes of the integration, a default of three different shadows is established for each connected thing: an unnamed shadow, a datamodel shadow and an operation shadow. Classic Shadow # The Classic shadow (also unnamed shadow) is used for storing connectivity parameters of a LwM2M device (such as registered lifetime, last lifetime refresh, queue mode, LwM2M URI, device registration status etc.). The reported state refreshes upon each change in these parameters that is reported by Coiote DM ( Register or Update message from device). Operation Shadow # The Operation Shadow is where you request your LwM2M operations to be executed. To this end, the desired values of the device state are used. Thus, you can perform any LwM2M 1.0 operation on the device by defining it inside the desired values section. Also, to check if the operation execution was successful, the reported values section of the Operation Shadow is used (but only in case of the READ, WRITE and READ COMPOSITE operations). Communication flow # A value change using the desired device state is formulated as the one below: { \"state\" : { \"desired\" : { \"operation\" : \"write\" , \"keys\" : [ \"LwM2M Server.1.Lifetime\" , \"Device.0.UTC Offset\" ], \"values\" : [ 68 , \"+02:00\" ] } } } Once a value change in the desired section of the operation shadow is saved, a chain of events starts: A change in the desired section triggers the operationRequest rule. The operationRequest rule sends a request to AWS Lambda . AWS Lambda validates the request and forwards it as an event to Coiote DM, making it schedule a task and initiate a device session. Coiote DM communicates with the device. The device responds to Coiote DM with the operation result. Coiote DM forwards the device response back to the Operation Shadow and the results are published in the reported section. The change in the reported section triggers the operationResponse rule. The results are then republished using the operationResponse rule to the Datamodel shadow (but only in case of the READ, WRITE and READ COMPOSITE operations). Datamodel Shadow # The Datamodel Shadow is the place where the cashed data model of the LwM2M device is stored. What this means is that it is a \"read-only shadow\" that keeps the most recent record of the device state as it has been reported by Coiote DM - no device operations can be performed from here. The Datamodel Shadow is updated in case of the following events: Device Register message that comes from Coiote DM, Device Notify and Send messages, Republishing operation results from the Operation shadow to the Datamodel shadow using the operationResponse rule. CloudWatch logs # CloudWatch collects and keeps a record of all the logs generated on the AWS-side of the integration. You can use these data for analysis and troubleshooting in case of all the AWS integration components: Device Shadows (the data plane), Things and Thing types (the control plane), The Rules mechanism, AWS Lambda.","title":"How AWS integration works"},{"location":"AWS_Integration_Guide/Concepts/AWS_Integration_concepts/#how-aws-integration-works","text":"Here's a walkthrough of the main concepts related to the AWS IoT Core - Coiote DM integration that will help you understand the role of each of the integration components and how they are employed for the benefit of LwM2M device management via the AWS services.","title":"How AWS integration works"},{"location":"AWS_Integration_Guide/Concepts/AWS_Integration_concepts/#things","text":"Within the AWS IoT Core - Coiote DM integration, things are the AWS representations of LwM2M device entities managed by the Coiote DM platform. They are used to mirror device state, as well as collect, process and act upon device data on the fly using a connection protocol of your choice. Note Things are automatically added to AWS IoT Core upon completing the integration setup and successful device connection.","title":"Things"},{"location":"AWS_Integration_Guide/Concepts/AWS_Integration_concepts/#thing-types","text":"Thing types are containers that store configuration and other device-related information shared by all Things of the same type to simplify their bulk management. Within the integration, they are created automatically when a new device is added to AWS from Coiote DM and they are based on device Manufacturer and Model name . In case a new device with a specific Manufacturer and model name pair can be matched with an existing thing type, then it will be associated with it automatically. Note Note that you cannot modify a once created thing type, but you can deprecate (allowing no new devices to be associated with it) or delete it when there are no things associated with a given Thing type.","title":"Thing types"},{"location":"AWS_Integration_Guide/Concepts/AWS_Integration_concepts/#device-shadows","text":"A device shadow is a structure that stores the device state and represents it in the form of a JSON file, making the device data available to applications and services regardless of device connection to Coiote DM. To synchronize device state information between the Coiote DM and AWS IoT Core, shadows feature the mechanism of reported and desired values. Reported values section - presents the current device state as reported by the device itself (and mediated by Coiote DM) in a JSON file structure within a device shadow. Desired values section - used for requesting changes in the reported section of the device Operation shadow . For the purposes of the integration, a default of three different shadows is established for each connected thing: an unnamed shadow, a datamodel shadow and an operation shadow.","title":"Device Shadows"},{"location":"AWS_Integration_Guide/Concepts/AWS_Integration_concepts/#classic-shadow","text":"The Classic shadow (also unnamed shadow) is used for storing connectivity parameters of a LwM2M device (such as registered lifetime, last lifetime refresh, queue mode, LwM2M URI, device registration status etc.). The reported state refreshes upon each change in these parameters that is reported by Coiote DM ( Register or Update message from device).","title":"Classic Shadow"},{"location":"AWS_Integration_Guide/Concepts/AWS_Integration_concepts/#operation-shadow","text":"The Operation Shadow is where you request your LwM2M operations to be executed. To this end, the desired values of the device state are used. Thus, you can perform any LwM2M 1.0 operation on the device by defining it inside the desired values section. Also, to check if the operation execution was successful, the reported values section of the Operation Shadow is used (but only in case of the READ, WRITE and READ COMPOSITE operations).","title":"Operation Shadow"},{"location":"AWS_Integration_Guide/Concepts/AWS_Integration_concepts/#communication-flow","text":"A value change using the desired device state is formulated as the one below: { \"state\" : { \"desired\" : { \"operation\" : \"write\" , \"keys\" : [ \"LwM2M Server.1.Lifetime\" , \"Device.0.UTC Offset\" ], \"values\" : [ 68 , \"+02:00\" ] } } } Once a value change in the desired section of the operation shadow is saved, a chain of events starts: A change in the desired section triggers the operationRequest rule. The operationRequest rule sends a request to AWS Lambda . AWS Lambda validates the request and forwards it as an event to Coiote DM, making it schedule a task and initiate a device session. Coiote DM communicates with the device. The device responds to Coiote DM with the operation result. Coiote DM forwards the device response back to the Operation Shadow and the results are published in the reported section. The change in the reported section triggers the operationResponse rule. The results are then republished using the operationResponse rule to the Datamodel shadow (but only in case of the READ, WRITE and READ COMPOSITE operations).","title":"Communication flow"},{"location":"AWS_Integration_Guide/Concepts/AWS_Integration_concepts/#datamodel-shadow","text":"The Datamodel Shadow is the place where the cashed data model of the LwM2M device is stored. What this means is that it is a \"read-only shadow\" that keeps the most recent record of the device state as it has been reported by Coiote DM - no device operations can be performed from here. The Datamodel Shadow is updated in case of the following events: Device Register message that comes from Coiote DM, Device Notify and Send messages, Republishing operation results from the Operation shadow to the Datamodel shadow using the operationResponse rule.","title":"Datamodel Shadow"},{"location":"AWS_Integration_Guide/Concepts/AWS_Integration_concepts/#cloudwatch-logs","text":"CloudWatch collects and keeps a record of all the logs generated on the AWS-side of the integration. You can use these data for analysis and troubleshooting in case of all the AWS integration components: Device Shadows (the data plane), Things and Thing types (the control plane), The Rules mechanism, AWS Lambda.","title":"CloudWatch logs"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/","text":"Performing LwM2M operations # This section will give you an overview of how to perform LwM2M operations on devices in AWS IoT Core and check AWS CloudWatch logs. Prerequisites # A configured AWS integration. An active LwM2M device already migrated to AWS IoT Core. Execute LwM2M operations on device # Within the AWS - Coiote DM integration, LwM2M operations on devices are triggered by modifying the desired section of a device Operation Shadow . The changes, upon successful execution, are then reported back by Coiote DM and repopulated to the reported section of a device Datamodel Shadow . The integration supports the following LwM2M operations: READ # To send a request for a READ operation to a device: Enter AWS IoT Core and go to Manage > Things . From the list, select your device. Go to the Device Shadows section and select the operation Shadow. Click Edit and formulate the request inside the Device Shadow state field based on the example input given below: In the operation section, type the operation name In the keys section, type the LwM2M object and resource paths for which you want to execute the operation. In the values section, type the values for the specified keys (only for some operations). Read_request { \"state\": { \"desired\": { \"operation\": \"read\", \"keys\": [ \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array.4\" ] } } } Click Update . To see the operation results, check the reported section of the operation Shadow. An example response looks like this: Read_result { \"reported\": { \"operation\": \"read\", \"failedKeys\": [ \"\" ], \"result\": { \"Device\": { \"0\": { \"UTC Offset\": \"+02:00\" } }, \"LwM2M Server\": { \"1\": { \"Lifetime\": \"68\" } }, \"Portfolio\": { \"5\": { \"Identity\": { \"1\": \"AVS\" } }, \"11\": { \"Identity\": { \"1\": \"your_ID\" } } }, \"Test object\": { \"0\": { \"Integer array\": { \"4\": \"256\" } } } } } } Note To execute a READ operation on all the readable resources, enter \"\"/\"\" or \"\"all\"\" as the value in the keys section of the request. WRITE # To request a WRITE operation for a device, follow the steps 1-5 from the READ subsection, but using the following example: Write_request { \"state\": { \"desired\": { \"operation\": \"write\", \"keys\": [ \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array.4\" ], \"values\": [ 68, \"your_ID\", \"random_value\", \"+02:00\", 256 ] } } } OBSERVE # To request a OBSERVE operation for a device, follow the steps 1-5 from the READ subsection, but using the following example: Observe_request { \"state\": { \"desired\": { \"operation\": \"observe\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ], \"attributes\": [ {\"epmin\":5,\"gt\":-65.5,\"lt\":-105.5,\"st\":4.0}, {\"pmin\":30,\"pmax\":35}, {}, {\"epmax\":40}, {}, {\"pmax\":20} ] } } } Note In the attributes section, you need to specify the full attribute list with their corresponding values for a given key, as the attributes that are left out will be overwritten with null (except for the con attribute). Alternatively, you can provide an empty value {} so that no attribute values are changed. On the other hand, if you only specify the con attribute for a given key, it will not affect any other attributes and their existing values won't be changed also. To check the results of the OBSERVE operation, go to the datamodel Shadow of your device and see the reported section. EXECUTE # To request an EXECUTE operation for a device, follow the steps 1-5 from the READ subsection, but using the following example: Execute_request { \"state\": { \"desired\": { \"operation\": \"execute\", \"keys\": [ \"Device.0.Reboot\" ] } } } Note With the EXECUTE operation, you can specify only one key for each request. Other operations # Here are example inputs for other operations supported by the integration: READ COMPOSITE, OBSERVE COMPOSITE, WRITE ATTRIBUTES, CANCEL OBSERVE, CANCEL OBSERVE COMPOSITE. Cancel Observe # Cancel_observe { \"state\": { \"desired\": { \"operation\": \"cancelObserve\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ] } } } Note To cancel all the current OBSERVE requests, type \"all\" in the keys section. Write Attributes # Write_attributes { \"state\": { \"desired\": { \"operation\": \"writeAttributes\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ], \"attributes\": [ { \"epmin\": 5, \"gt\": -65.5, \"lt\": -105.5, \"st\": 4, \"con\": 1 }, { \"pmin\": 30, \"pmax\": 35, \"con\": \"\" }, {}, { \"epmax\": 40 }, { \"con\": null }, { \"pmax\": 20 } ] } } } Observe-Composite # Observe_composite { \"state\": { \"desired\": { \"operation\": \"observeComposite\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ], \"attributes\": [ { \"epmin\": 5, \"gt\": -65.5, \"lt\": -105.5, \"st\": 4, \"con\": 1 }, { \"pmin\": 30, \"pmax\": 35, \"con\": \"\" }, {}, { \"epmax\": 40 }, { \"con\": null }, { \"pmax\": 20 } ] } } } Read-Composite # Read_composite { \"state\": { \"desired\": { \"operation\": \"readComposite\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ], } } } Cancel Observe-Composite # Cancelobserve_composite { \"state\": { \"desired\": { \"operation\": \"cancelObserveComposite\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ], } } } Check logs in CloudWatch # If you encounter difficulties when forwarding your requests to Coiote DM, it may be helpful to check the logs collected by AWS CloudWatch for all the components of the integration. To check logs for AWS Lambda: Go to AWS CloudWatch and select Logs > Log groups . From the Log groups list, select the /aws/lambda/lwm2mOperation group. To check error logs for all integration components in one place: Go to AWS CloudWatch and select Logs > Log groups . From the Log groups list, select the AWSIotLogsV2 group. Select all the logs from the list by checking the box next to Log stream and click Search all . Expand a log stream to see its details by clicking the arrow icon > .","title":"Performing LwM2M operations"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#performing-lwm2m-operations","text":"This section will give you an overview of how to perform LwM2M operations on devices in AWS IoT Core and check AWS CloudWatch logs.","title":"Performing LwM2M operations"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#prerequisites","text":"A configured AWS integration. An active LwM2M device already migrated to AWS IoT Core.","title":"Prerequisites"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#execute-lwm2m-operations-on-device","text":"Within the AWS - Coiote DM integration, LwM2M operations on devices are triggered by modifying the desired section of a device Operation Shadow . The changes, upon successful execution, are then reported back by Coiote DM and repopulated to the reported section of a device Datamodel Shadow . The integration supports the following LwM2M operations:","title":"Execute LwM2M operations on device"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#read","text":"To send a request for a READ operation to a device: Enter AWS IoT Core and go to Manage > Things . From the list, select your device. Go to the Device Shadows section and select the operation Shadow. Click Edit and formulate the request inside the Device Shadow state field based on the example input given below: In the operation section, type the operation name In the keys section, type the LwM2M object and resource paths for which you want to execute the operation. In the values section, type the values for the specified keys (only for some operations). Read_request { \"state\": { \"desired\": { \"operation\": \"read\", \"keys\": [ \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array.4\" ] } } } Click Update . To see the operation results, check the reported section of the operation Shadow. An example response looks like this: Read_result { \"reported\": { \"operation\": \"read\", \"failedKeys\": [ \"\" ], \"result\": { \"Device\": { \"0\": { \"UTC Offset\": \"+02:00\" } }, \"LwM2M Server\": { \"1\": { \"Lifetime\": \"68\" } }, \"Portfolio\": { \"5\": { \"Identity\": { \"1\": \"AVS\" } }, \"11\": { \"Identity\": { \"1\": \"your_ID\" } } }, \"Test object\": { \"0\": { \"Integer array\": { \"4\": \"256\" } } } } } } Note To execute a READ operation on all the readable resources, enter \"\"/\"\" or \"\"all\"\" as the value in the keys section of the request.","title":"READ"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#write","text":"To request a WRITE operation for a device, follow the steps 1-5 from the READ subsection, but using the following example: Write_request { \"state\": { \"desired\": { \"operation\": \"write\", \"keys\": [ \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array.4\" ], \"values\": [ 68, \"your_ID\", \"random_value\", \"+02:00\", 256 ] } } }","title":"WRITE"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#observe","text":"To request a OBSERVE operation for a device, follow the steps 1-5 from the READ subsection, but using the following example: Observe_request { \"state\": { \"desired\": { \"operation\": \"observe\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ], \"attributes\": [ {\"epmin\":5,\"gt\":-65.5,\"lt\":-105.5,\"st\":4.0}, {\"pmin\":30,\"pmax\":35}, {}, {\"epmax\":40}, {}, {\"pmax\":20} ] } } } Note In the attributes section, you need to specify the full attribute list with their corresponding values for a given key, as the attributes that are left out will be overwritten with null (except for the con attribute). Alternatively, you can provide an empty value {} so that no attribute values are changed. On the other hand, if you only specify the con attribute for a given key, it will not affect any other attributes and their existing values won't be changed also. To check the results of the OBSERVE operation, go to the datamodel Shadow of your device and see the reported section.","title":"OBSERVE"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#execute","text":"To request an EXECUTE operation for a device, follow the steps 1-5 from the READ subsection, but using the following example: Execute_request { \"state\": { \"desired\": { \"operation\": \"execute\", \"keys\": [ \"Device.0.Reboot\" ] } } } Note With the EXECUTE operation, you can specify only one key for each request.","title":"EXECUTE"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#other-operations","text":"Here are example inputs for other operations supported by the integration: READ COMPOSITE, OBSERVE COMPOSITE, WRITE ATTRIBUTES, CANCEL OBSERVE, CANCEL OBSERVE COMPOSITE.","title":"Other operations"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#cancel-observe","text":"Cancel_observe { \"state\": { \"desired\": { \"operation\": \"cancelObserve\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ] } } } Note To cancel all the current OBSERVE requests, type \"all\" in the keys section.","title":"Cancel Observe"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#write-attributes","text":"Write_attributes { \"state\": { \"desired\": { \"operation\": \"writeAttributes\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ], \"attributes\": [ { \"epmin\": 5, \"gt\": -65.5, \"lt\": -105.5, \"st\": 4, \"con\": 1 }, { \"pmin\": 30, \"pmax\": 35, \"con\": \"\" }, {}, { \"epmax\": 40 }, { \"con\": null }, { \"pmax\": 20 } ] } } }","title":"Write Attributes"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#observe-composite","text":"Observe_composite { \"state\": { \"desired\": { \"operation\": \"observeComposite\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ], \"attributes\": [ { \"epmin\": 5, \"gt\": -65.5, \"lt\": -105.5, \"st\": 4, \"con\": 1 }, { \"pmin\": 30, \"pmax\": 35, \"con\": \"\" }, {}, { \"epmax\": 40 }, { \"con\": null }, { \"pmax\": 20 } ] } } }","title":"Observe-Composite"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#read-composite","text":"Read_composite { \"state\": { \"desired\": { \"operation\": \"readComposite\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ], } } }","title":"Read-Composite"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#cancel-observe-composite","text":"Cancelobserve_composite { \"state\": { \"desired\": { \"operation\": \"cancelObserveComposite\", \"keys\": [ \"Connectivity Monitoring.0.Radio Signal Strength\", \"LwM2M Server.1.Lifetime\", \"Portfolio.11.Identity.1\", \"Portfolio.5.Identity.1\", \"Device.0.UTC Offset\", \"Test object.0.Integer array\" ], } } }","title":"Cancel Observe-Composite"},{"location":"AWS_Integration_Guide/Device_operations/Operation_types/#check-logs-in-cloudwatch","text":"If you encounter difficulties when forwarding your requests to Coiote DM, it may be helpful to check the logs collected by AWS CloudWatch for all the components of the integration. To check logs for AWS Lambda: Go to AWS CloudWatch and select Logs > Log groups . From the Log groups list, select the /aws/lambda/lwm2mOperation group. To check error logs for all integration components in one place: Go to AWS CloudWatch and select Logs > Log groups . From the Log groups list, select the AWSIotLogsV2 group. Select all the logs from the list by checking the box next to Log stream and click Search all . Expand a log stream to see its details by clicking the arrow icon > .","title":"Check logs in CloudWatch"},{"location":"Anjay_integrations/Getting_started/","text":"Getting started # Start developing LwM2M applications on your boards and IoT devices in just a few clicks using our Anjay LwM2M Client. Espressif ESP32 # M5StickC # Start integration M5StickC/BG96 # Start integration ESP32-DevKitC/BG96 # Start integration STMicroelectronics # Build a LwM2M application for your ST board using I-Cube Anjay from scratch by following our I-CUBE-Anjay guide . STM32L496G-DISCO/BG96 # Integrate your P-L496G-CELL02 Discovery kit board along with the default-provided Quectel BG96 modem using our Anjay LwM2M Client based on freeRTOS. Start integration STM32L496G-DISCO/MONARCH # Integrate your P-L496G-CELL02 Discovery kit along with the Sequans' Monarch GM01Q-STMOD expansion board using our Anjay LwM2M Client based on freeRTOS. Start integration B-L462E-CELL1/TYPE1SC # Integrate your B-L462E-CELL1 Discovery kit board along with the TYPE 1SE module with built-in eSIM (ST4SIM-200M) using our Anjay LwM2M Client based on freeRTOS. Start integration B-L475E-IOT01A # Integrate your B-L475E-IOT01A Discovery kit board using our Anjay LwM2M Client based on Zephyr OS. Start integration B-U585I-IOT02A/BG96 # Integrate your B-U585I-IOT02A/BG96 Discovery kit board using our Anjay LwM2M Client based on Zephyr OS. Start integration Nordic Semiconductor # Thingy:91 # Integrate your Thingy:91 board using our Anjay LwM2M Client based on Zephyr OS. Start integration nRF9160 # Integrate your nRF9160 board using our Anjay LwM2M Client based on Zephyr OS. Start integration","title":"Getting started"},{"location":"Anjay_integrations/Getting_started/#getting-started","text":"Start developing LwM2M applications on your boards and IoT devices in just a few clicks using our Anjay LwM2M Client.","title":"Getting started"},{"location":"Anjay_integrations/Getting_started/#espressif-esp32","text":"","title":"Espressif ESP32"},{"location":"Anjay_integrations/Getting_started/#m5stickc","text":"Start integration","title":"M5StickC"},{"location":"Anjay_integrations/Getting_started/#m5stickcbg96","text":"Start integration","title":"M5StickC/BG96"},{"location":"Anjay_integrations/Getting_started/#esp32-devkitcbg96","text":"Start integration","title":"ESP32-DevKitC/BG96"},{"location":"Anjay_integrations/Getting_started/#stmicroelectronics","text":"Build a LwM2M application for your ST board using I-Cube Anjay from scratch by following our I-CUBE-Anjay guide .","title":"STMicroelectronics"},{"location":"Anjay_integrations/Getting_started/#stm32l496g-discobg96","text":"Integrate your P-L496G-CELL02 Discovery kit board along with the default-provided Quectel BG96 modem using our Anjay LwM2M Client based on freeRTOS. Start integration","title":"STM32L496G-DISCO/BG96"},{"location":"Anjay_integrations/Getting_started/#stm32l496g-discomonarch","text":"Integrate your P-L496G-CELL02 Discovery kit along with the Sequans' Monarch GM01Q-STMOD expansion board using our Anjay LwM2M Client based on freeRTOS. Start integration","title":"STM32L496G-DISCO/MONARCH"},{"location":"Anjay_integrations/Getting_started/#b-l462e-cell1type1sc","text":"Integrate your B-L462E-CELL1 Discovery kit board along with the TYPE 1SE module with built-in eSIM (ST4SIM-200M) using our Anjay LwM2M Client based on freeRTOS. Start integration","title":"B-L462E-CELL1/TYPE1SC"},{"location":"Anjay_integrations/Getting_started/#b-l475e-iot01a","text":"Integrate your B-L475E-IOT01A Discovery kit board using our Anjay LwM2M Client based on Zephyr OS. Start integration","title":"B-L475E-IOT01A"},{"location":"Anjay_integrations/Getting_started/#b-u585i-iot02abg96","text":"Integrate your B-U585I-IOT02A/BG96 Discovery kit board using our Anjay LwM2M Client based on Zephyr OS. Start integration","title":"B-U585I-IOT02A/BG96"},{"location":"Anjay_integrations/Getting_started/#nordic-semiconductor","text":"","title":"Nordic Semiconductor"},{"location":"Anjay_integrations/Getting_started/#thingy91","text":"Integrate your Thingy:91 board using our Anjay LwM2M Client based on Zephyr OS. Start integration","title":"Thingy:91"},{"location":"Anjay_integrations/Getting_started/#nrf9160","text":"Integrate your nRF9160 board using our Anjay LwM2M Client based on Zephyr OS. Start integration","title":"nRF9160"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/","text":"Tutorial: Implementing LwM2M objects on RaspberryPi # Introduction # Svetovid is a LwM2M client that gives you tools to implement selected LwM2M objects for RaspberryPi-based IoT devices. The Python programming language is used to implement LwM2M objects. Svetovid is based on a state-of-the-art LwM2M client Anjay developed by AVSystem. It features the FSDM (File System Data Model) in which LwM2M objects are mapped to folders that follow a particular schema, and executables behave as expected by the LwM2M client that loads and manages them. This tutorial will show you how to implement a temperature LwM2M object on your device and a push button using Svetovid. This will enable live readings of their resources (temperature, push button state and counter) in Coiote DM. Prerequisites # Raspberry Pi 3 or 4 with a configured operating system and a set-up WiFi connection. A Sense HAT or a GrovePi with a temperature sensor ( DHT11 or similar) and a push button ( Grove-button or similar). An active Coiote IoT Device Management user account with Cloud admin permissions. Step 1: Prepare your Sense HAT/GrovePi # Sense HAT # Install the Sense HAT packages: sudo apt-get install sense-hat Check if Sense HAT is working correctly: Create a hello_world.py file: from sense_hat import SenseHat sense = SenseHat() sense.show_message(\"Hello World!\") Run the program: python hello_world.py If a Hello World! message is displayed, you're good to proceed. Note If you're new to Sense HAT, follow the getting started tutorial . GrovePi # To install the GrovePi repository, paste and execute the following commands: mkdir ~/Dexter cd /home/pi/Dexter git clone https://github.com/DexterInd/GrovePi cd /home/pi/Dexter/GrovePi/Script bash ./update_grovepi.sh 2. Check if the GrovePi libraries are working correctly: Connect a LED module to GrovePi port D4. In the terminal, type: cd /home/pi/Dexter/GrovePi/Software/Python python grove_led_blink.py The LED should start blinking. Step 2: Install Svetovid # To install Svetovid, paste and execute the following commands into your command-line terminal: mkdir ~/AVSystem cd /home/pi/AVSystem git clone https://github.com/AVSystem/Svetovid-raspberry-client.git cd /home/pi/AVsystem/Svetovid-raspberry-client sudo dpkg -i svetovid_20.11-raspberry_armhf.deb sudo dpkg -i svetovid-plugin-fsdm_20.11-raspberry_armhf.deb sudo dpkg -i avsystem_svetovid-20.11-raspberry-Linux-fsdmtool-runtime-python.deb In file /usr/local/share/svetovid/bin/fsdm/lwm2m_object_registry.py , find the https://raw.githubusercontent.com/OpenMobileAlliance/lwm2m-registry/test entry and replace it with https://raw.githubusercontent.com/OpenMobileAlliance/lwm2m-registry/prod . Step 3: Register your device in Coiote DM # Disable the Svetovid service: sudo systemctl disable svetovid.service --now Set the server connection details: in /etc/svetovid/config/security.json : { \"1\": { \"ssid\": \"1\", \"server_uri\": \"coaps://lwm2m-test.avsystem.io:5684\", \"is_bootstrap\": \"0\", \"security_mode\": \"psk\", \"pubkey_or_identity_hex\": \"XXXX\", \"privkey_or_psk_hex\": \"XXXX\", \"server_pubkey_hex\": \"\", \"holdoff_s\": \"0\", \"bs_timeout_s\": \"0\" } } in /etc/svetovid/config/svd.json : { \"device\": { \"endpoint_name\": \"YYYY\", \"udp_listen_port\": 1234 }, \"logging\": { \"default_log_level\": \"trace\", \"log_level\": { \"svd\": \"trace\" } }, \"lwm2m_version_config\": { \"min\": \"1.0\", \"max\": \"1.1\" }, \"in_buffer_size_b\": 1024, \"out_buffer_size_b\": 1024, \"msg_cache_size_b\": 65536 } Note XXXX and YYYY should be replaced by the chosen values of endpoint name, PSK identity and PSK key. Tip XXXX values are in hex. To convert your plain text, use the following: echo -n 'text-value' | xxd -p Restart the Svetovid service: sudo systemctl start svetovid.service --now Create a device instance in Coiote DM: When logged into your Coiote DM user account, go to Device Inventory and click Add device . Provide Device ID, Key Identity and Key values as in the Svetovid config files from the earlier step. Wait for the connection. Analyze the objects exposed by the device. Note Your RaspberryPi-based device will feature a number of default LwM2M objects provided by Svetovid, for instance the temperature object - 3303 . Step 4: Implement the LwM2M temperature object 3303 (only for GrovePi) # Disable the Svetovid service: sudo systemctl disable svetovid.service --now Generate a stub object in your dm (data model) Svetovid folder by pasting and executing the following command in the terminal: $ sudo svetovid-fsdmtool generate --object 3303 --output-dir /etc/svetovid/dm --generator python Tip You can analyze the resource implementation in the /etc/svetovid/dm/3303 folder . For more details, see the Svetovid page on GitHub . Modify the python script in the /etc/svetovid/dm/3303/Sensor_Value.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore import grovepi import math # Connect the Grove Temperature & Humidity Sensor Pro to digital port D4 # This example uses the blue colored sensor. # SIG,NC,VCC,GND sensor = 4 # The Sensor goes on digital port 4. # temp_humidity_sensor_type # Grove Base Kit comes with the blue sensor. blue = 0 # The Blue colored sensor. white = 1 # The White colored sensor. class ResourceHandler_3303_5700(ResourceHandler): NAME = \"Sensor Value\" DESCRIPTION = '''\\ Last or Current Measured Value from the Sensor.''' DATATYPE = DataType.FLOAT EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise # TODO: print value to stdout # print(0.0) [temp,humidity] = grovepi.dht(sensor,blue) print(\"%.02f\"%(temp)) if __name__ == '__main__': ResourceHandler_3303_5700().main() Modify the python script in the /etc/svetovid/dm/3303/resources/5700.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore import grovepi import math # Connect the Grove Temperature & Humidity Sensor Pro to digital port D4 # This example uses the blue colored sensor. # SIG,NC,VCC,GND sensor = 4 # The Sensor goes on digital port 4. # temp_humidity_sensor_type # Grove Base Kit comes with the blue sensor. blue = 0 # The Blue colored sensor. white = 1 # The White colored sensor. class ResourceHandler_3303_5700(ResourceHandler): NAME = \"Sensor Value\" DESCRIPTION = '''\\ Last or Current Measured Value from the Sensor.''' DATATYPE = DataType.FLOAT EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise # TODO: print value to stdout # print(0.0) [temp,humidity] = grovepi.dht(sensor,blue) print(\"%.02f\"%(temp)) if __name__ == '__main__': ResourceHandler_3303_5700().main() Plug in the temperature sensor to digital port D4 of the GrovePi. Restart the Svetovid service: sudo systemctl restart svetovid.service --now Refresh device state in Coiote and see if the Temperature object 3303 has appeared in the Objects tab and values are reported for for the Sensor Value 5700 resource: Step 5: Implement the LwM2M push button based on the Multiple Axis Joystick object 3345 # Now you can implement the Push Button module based on the OMA DM Multiple Axis Joystick object (3345). Type in the terminal: $ sudo svetovid-fsdmtool generate --object 3345 --output-dir /etc/svetovid/dm --generator python` Tip You can analyze the resource implementation in the /etc/svetovid/dm/3345 folder. For more details, see the Svetovid page on GitHub . Type in the terminal: cd /etc/svetovid/dm/3345/resources ./5550 read . You should be able to see a default value reported in the command-line terminal. In home directory, create the file ~/button_object_forwarder.py and paste the following into it: SenseHat from sense_hat import SenseHat from time import sleep from fsdm import KvStore sense = SenseHat() sense.clear() #KvStore(namespace=3345).set('counter', 0) #KvStore(namespace=3345).set('state', False) released_before = False counter = 0 while True: for event in sense.stick.get_events(): if event.action == \"pressed\": if event.direction == \"middle\": sense.show_letter(\"M\") KvStore(namespace=3345).set('state', True) if released_before: counter = counter + 1 KvStore(namespace=3345).set('counter', counter) released_before = False elif event.action == \"released\": if event.direction == \"middle\": sense.show_letter(\"m\") KvStore(namespace=3345).set('state', False) released_before = True else: sense.clear() # Wait and clear the screen sleep(0.5) sense.clear() GrovePi from time import sleep import grovepi from fsdm import KvStore button = 3 KvStore(namespace=3345).set('counter', 0) KvStore(namespace=3345).set('state', False) released_before = False counter = 0 grovepi.pinMode(button, \"INPUT\") while True: try: state = grovepi.digitalRead(button) KvStore(namespace=3345).set('state', True) print(\"State:{}\".format(state)) if state == 1: if released_before: counter = counter + 1 print(\"Counter:{}\".format(counter)) KvStore(namespace=3345).set('counter', counter+1) released_before = False KvStore(namespace=3345).set('state', True) else: released_before = True KvStore(namespace=3345).set('state', False) sleep(.2) except IOError: print(\"Error\") Modify the python script in the /etc/svetovid/dm/3345/Digital_Input_Counter.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5501(ResourceHandler): NAME = \"Digital Input Counter\" DESCRIPTION = '''\\ The cumulative value of active state detected.''' DATATYPE = DataType.INTEGER EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise value = KvStore(namespace=3345).get('counter') if value is None: # The value was not set, so it's not found. # raise CoapError.NOT_FOUND value = 0 print(value) # TODO: print value to stdout # print(0) if __name__ == '__main__': ResourceHandler_3345_5501().main() Modify the python script in the /etc/svetovid/dm/3345/Digital_Input_State.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5500(ResourceHandler): NAME = \"Digital Input State\" DESCRIPTION = '''\\ The current state of a digital input.''' DATATYPE = DataType.BOOLEAN EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise state = KvStore(namespace=3345).get('state') if state is None: # The value was not set, so it's not found. raise CoapError.NOT_FOUND #state = False print(state) # TODO: print value to stdout #print(0) if __name__ == '__main__': ResourceHandler_3345_5500().main() Modify the /etc/svetovid/dm/3345/resources/5500 file: #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5500(ResourceHandler): NAME = \"Digital Input State\" DESCRIPTION = '''\\ The current state of a digital input.''' DATATYPE = DataType.BOOLEAN EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise state = KvStore(namespace=3345).get('state') if state is None: # The value was not set, so it's not found. raise CoapError.NOT_FOUND #state = False print(state) # TODO: print value to stdout #print(0) if __name__ == '__main__': ResourceHandler_3345_5500().main() Modify the /etc/svetovid/dm/3345/resources/5501 file: #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5501(ResourceHandler): NAME = \"Digital Input Counter\" DESCRIPTION = '''\\ The cumulative value of active state detected.''' DATATYPE = DataType.INTEGER EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise value = KvStore(namespace=3345).get('counter') if value is None: # The value was not set, so it's not found. # raise CoapError.NOT_FOUND value = 0 print(value) # TODO: print value to stdout # print(0) if __name__ == '__main__': ResourceHandler_3345_5501().main() Plug in the push button to digital port D3 of the GrovePi/Sense HAT. Restart Svetovid: sudo systemctl restart svetovid.service --now Refresh device state in Coiote and see if the Multiple Axis Joystick object 3345 has appeared in the Objects tab and values are reported for the Digital Input State 5500 and Digital Input Counter 5501 resources:","title":"Tutorial: Implementing LwM2M objects on RaspberryPi"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/#tutorial-implementing-lwm2m-objects-on-raspberrypi","text":"","title":"Tutorial: Implementing LwM2M objects on RaspberryPi"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/#introduction","text":"Svetovid is a LwM2M client that gives you tools to implement selected LwM2M objects for RaspberryPi-based IoT devices. The Python programming language is used to implement LwM2M objects. Svetovid is based on a state-of-the-art LwM2M client Anjay developed by AVSystem. It features the FSDM (File System Data Model) in which LwM2M objects are mapped to folders that follow a particular schema, and executables behave as expected by the LwM2M client that loads and manages them. This tutorial will show you how to implement a temperature LwM2M object on your device and a push button using Svetovid. This will enable live readings of their resources (temperature, push button state and counter) in Coiote DM.","title":"Introduction"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/#prerequisites","text":"Raspberry Pi 3 or 4 with a configured operating system and a set-up WiFi connection. A Sense HAT or a GrovePi with a temperature sensor ( DHT11 or similar) and a push button ( Grove-button or similar). An active Coiote IoT Device Management user account with Cloud admin permissions.","title":"Prerequisites"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/#step-1-prepare-your-sense-hatgrovepi","text":"","title":"Step 1: Prepare your Sense HAT/GrovePi"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/#sense-hat","text":"Install the Sense HAT packages: sudo apt-get install sense-hat Check if Sense HAT is working correctly: Create a hello_world.py file: from sense_hat import SenseHat sense = SenseHat() sense.show_message(\"Hello World!\") Run the program: python hello_world.py If a Hello World! message is displayed, you're good to proceed. Note If you're new to Sense HAT, follow the getting started tutorial .","title":"Sense HAT"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/#grovepi","text":"To install the GrovePi repository, paste and execute the following commands: mkdir ~/Dexter cd /home/pi/Dexter git clone https://github.com/DexterInd/GrovePi cd /home/pi/Dexter/GrovePi/Script bash ./update_grovepi.sh 2. Check if the GrovePi libraries are working correctly: Connect a LED module to GrovePi port D4. In the terminal, type: cd /home/pi/Dexter/GrovePi/Software/Python python grove_led_blink.py The LED should start blinking.","title":"GrovePi"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/#step-2-install-svetovid","text":"To install Svetovid, paste and execute the following commands into your command-line terminal: mkdir ~/AVSystem cd /home/pi/AVSystem git clone https://github.com/AVSystem/Svetovid-raspberry-client.git cd /home/pi/AVsystem/Svetovid-raspberry-client sudo dpkg -i svetovid_20.11-raspberry_armhf.deb sudo dpkg -i svetovid-plugin-fsdm_20.11-raspberry_armhf.deb sudo dpkg -i avsystem_svetovid-20.11-raspberry-Linux-fsdmtool-runtime-python.deb In file /usr/local/share/svetovid/bin/fsdm/lwm2m_object_registry.py , find the https://raw.githubusercontent.com/OpenMobileAlliance/lwm2m-registry/test entry and replace it with https://raw.githubusercontent.com/OpenMobileAlliance/lwm2m-registry/prod .","title":"Step 2: Install Svetovid"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/#step-3-register-your-device-in-coiote-dm","text":"Disable the Svetovid service: sudo systemctl disable svetovid.service --now Set the server connection details: in /etc/svetovid/config/security.json : { \"1\": { \"ssid\": \"1\", \"server_uri\": \"coaps://lwm2m-test.avsystem.io:5684\", \"is_bootstrap\": \"0\", \"security_mode\": \"psk\", \"pubkey_or_identity_hex\": \"XXXX\", \"privkey_or_psk_hex\": \"XXXX\", \"server_pubkey_hex\": \"\", \"holdoff_s\": \"0\", \"bs_timeout_s\": \"0\" } } in /etc/svetovid/config/svd.json : { \"device\": { \"endpoint_name\": \"YYYY\", \"udp_listen_port\": 1234 }, \"logging\": { \"default_log_level\": \"trace\", \"log_level\": { \"svd\": \"trace\" } }, \"lwm2m_version_config\": { \"min\": \"1.0\", \"max\": \"1.1\" }, \"in_buffer_size_b\": 1024, \"out_buffer_size_b\": 1024, \"msg_cache_size_b\": 65536 } Note XXXX and YYYY should be replaced by the chosen values of endpoint name, PSK identity and PSK key. Tip XXXX values are in hex. To convert your plain text, use the following: echo -n 'text-value' | xxd -p Restart the Svetovid service: sudo systemctl start svetovid.service --now Create a device instance in Coiote DM: When logged into your Coiote DM user account, go to Device Inventory and click Add device . Provide Device ID, Key Identity and Key values as in the Svetovid config files from the earlier step. Wait for the connection. Analyze the objects exposed by the device. Note Your RaspberryPi-based device will feature a number of default LwM2M objects provided by Svetovid, for instance the temperature object - 3303 .","title":"Step 3: Register your device in Coiote DM"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/#step-4-implement-the-lwm2m-temperature-object-3303-only-for-grovepi","text":"Disable the Svetovid service: sudo systemctl disable svetovid.service --now Generate a stub object in your dm (data model) Svetovid folder by pasting and executing the following command in the terminal: $ sudo svetovid-fsdmtool generate --object 3303 --output-dir /etc/svetovid/dm --generator python Tip You can analyze the resource implementation in the /etc/svetovid/dm/3303 folder . For more details, see the Svetovid page on GitHub . Modify the python script in the /etc/svetovid/dm/3303/Sensor_Value.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore import grovepi import math # Connect the Grove Temperature & Humidity Sensor Pro to digital port D4 # This example uses the blue colored sensor. # SIG,NC,VCC,GND sensor = 4 # The Sensor goes on digital port 4. # temp_humidity_sensor_type # Grove Base Kit comes with the blue sensor. blue = 0 # The Blue colored sensor. white = 1 # The White colored sensor. class ResourceHandler_3303_5700(ResourceHandler): NAME = \"Sensor Value\" DESCRIPTION = '''\\ Last or Current Measured Value from the Sensor.''' DATATYPE = DataType.FLOAT EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise # TODO: print value to stdout # print(0.0) [temp,humidity] = grovepi.dht(sensor,blue) print(\"%.02f\"%(temp)) if __name__ == '__main__': ResourceHandler_3303_5700().main() Modify the python script in the /etc/svetovid/dm/3303/resources/5700.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore import grovepi import math # Connect the Grove Temperature & Humidity Sensor Pro to digital port D4 # This example uses the blue colored sensor. # SIG,NC,VCC,GND sensor = 4 # The Sensor goes on digital port 4. # temp_humidity_sensor_type # Grove Base Kit comes with the blue sensor. blue = 0 # The Blue colored sensor. white = 1 # The White colored sensor. class ResourceHandler_3303_5700(ResourceHandler): NAME = \"Sensor Value\" DESCRIPTION = '''\\ Last or Current Measured Value from the Sensor.''' DATATYPE = DataType.FLOAT EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise # TODO: print value to stdout # print(0.0) [temp,humidity] = grovepi.dht(sensor,blue) print(\"%.02f\"%(temp)) if __name__ == '__main__': ResourceHandler_3303_5700().main() Plug in the temperature sensor to digital port D4 of the GrovePi. Restart the Svetovid service: sudo systemctl restart svetovid.service --now Refresh device state in Coiote and see if the Temperature object 3303 has appeared in the Objects tab and values are reported for for the Sensor Value 5700 resource:","title":"Step 4: Implement the LwM2M temperature object 3303 (only for GrovePi)"},{"location":"Anjay_integrations/Implementing_LwM2M_objects_on_RaspberryPi/#step-5-implement-the-lwm2m-push-button-based-on-the-multiple-axis-joystick-object-3345","text":"Now you can implement the Push Button module based on the OMA DM Multiple Axis Joystick object (3345). Type in the terminal: $ sudo svetovid-fsdmtool generate --object 3345 --output-dir /etc/svetovid/dm --generator python` Tip You can analyze the resource implementation in the /etc/svetovid/dm/3345 folder. For more details, see the Svetovid page on GitHub . Type in the terminal: cd /etc/svetovid/dm/3345/resources ./5550 read . You should be able to see a default value reported in the command-line terminal. In home directory, create the file ~/button_object_forwarder.py and paste the following into it: SenseHat from sense_hat import SenseHat from time import sleep from fsdm import KvStore sense = SenseHat() sense.clear() #KvStore(namespace=3345).set('counter', 0) #KvStore(namespace=3345).set('state', False) released_before = False counter = 0 while True: for event in sense.stick.get_events(): if event.action == \"pressed\": if event.direction == \"middle\": sense.show_letter(\"M\") KvStore(namespace=3345).set('state', True) if released_before: counter = counter + 1 KvStore(namespace=3345).set('counter', counter) released_before = False elif event.action == \"released\": if event.direction == \"middle\": sense.show_letter(\"m\") KvStore(namespace=3345).set('state', False) released_before = True else: sense.clear() # Wait and clear the screen sleep(0.5) sense.clear() GrovePi from time import sleep import grovepi from fsdm import KvStore button = 3 KvStore(namespace=3345).set('counter', 0) KvStore(namespace=3345).set('state', False) released_before = False counter = 0 grovepi.pinMode(button, \"INPUT\") while True: try: state = grovepi.digitalRead(button) KvStore(namespace=3345).set('state', True) print(\"State:{}\".format(state)) if state == 1: if released_before: counter = counter + 1 print(\"Counter:{}\".format(counter)) KvStore(namespace=3345).set('counter', counter+1) released_before = False KvStore(namespace=3345).set('state', True) else: released_before = True KvStore(namespace=3345).set('state', False) sleep(.2) except IOError: print(\"Error\") Modify the python script in the /etc/svetovid/dm/3345/Digital_Input_Counter.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5501(ResourceHandler): NAME = \"Digital Input Counter\" DESCRIPTION = '''\\ The cumulative value of active state detected.''' DATATYPE = DataType.INTEGER EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise value = KvStore(namespace=3345).get('counter') if value is None: # The value was not set, so it's not found. # raise CoapError.NOT_FOUND value = 0 print(value) # TODO: print value to stdout # print(0) if __name__ == '__main__': ResourceHandler_3345_5501().main() Modify the python script in the /etc/svetovid/dm/3345/Digital_Input_State.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5500(ResourceHandler): NAME = \"Digital Input State\" DESCRIPTION = '''\\ The current state of a digital input.''' DATATYPE = DataType.BOOLEAN EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise state = KvStore(namespace=3345).get('state') if state is None: # The value was not set, so it's not found. raise CoapError.NOT_FOUND #state = False print(state) # TODO: print value to stdout #print(0) if __name__ == '__main__': ResourceHandler_3345_5500().main() Modify the /etc/svetovid/dm/3345/resources/5500 file: #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5500(ResourceHandler): NAME = \"Digital Input State\" DESCRIPTION = '''\\ The current state of a digital input.''' DATATYPE = DataType.BOOLEAN EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise state = KvStore(namespace=3345).get('state') if state is None: # The value was not set, so it's not found. raise CoapError.NOT_FOUND #state = False print(state) # TODO: print value to stdout #print(0) if __name__ == '__main__': ResourceHandler_3345_5500().main() Modify the /etc/svetovid/dm/3345/resources/5501 file: #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5501(ResourceHandler): NAME = \"Digital Input Counter\" DESCRIPTION = '''\\ The cumulative value of active state detected.''' DATATYPE = DataType.INTEGER EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise value = KvStore(namespace=3345).get('counter') if value is None: # The value was not set, so it's not found. # raise CoapError.NOT_FOUND value = 0 print(value) # TODO: print value to stdout # print(0) if __name__ == '__main__': ResourceHandler_3345_5501().main() Plug in the push button to digital port D3 of the GrovePi/Sense HAT. Restart Svetovid: sudo systemctl restart svetovid.service --now Refresh device state in Coiote and see if the Multiple Axis Joystick object 3345 has appeared in the Objects tab and values are reported for the Digital Input State 5500 and Digital Input Counter 5501 resources:","title":"Step 5: Implement the LwM2M push button based on the Multiple Axis Joystick object 3345"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/","text":"Thingy:91 # Integrate your Nordic Thingy:91 board. Prerequisites # The Thingy:91 board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform and appropriate permissions. Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_thingy91_app_signed.hex file. Jump to the flashing part of the tutorial. Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connecting to the LwM2M Server . Part 1: Get Zephyr and Python dependencies # To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project . Part 2: Clone the Anjay Zephyr repository # Enter the command line interface on your machine, then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client Part 3: Compile the example # Connect the Thingy:91 board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Compile the project for Thingy:91 using west build -b thingy91_nrf9160ns in the demo directory. Find the app_signed.hex file under the build/zephyr directory in the project folder. Flash the binaries # To program the board, go through the process of flashing Thingy:91 . Use the nRF Connect Programmer with the downloaded .hex file and follow the program the nRF9160 SiP application section. After successful flashing, reset the board and go to the next step. Connect to the LwM2M Server # To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Endpoint name field, enter your board endpoint name e.g. test_device (remember to set the same name in the next section ). In the Security mode section, select the Pre-Shared Key mode: In the Key identity field, type the same name as in the Endpoint name field. In the Key field, type the shared secret used in the device-server authentication. Note This is your own password which you will need in the next steps. Click the Add device button and Confirm in the confirmation pop-up. While in the Connect your device step, follow the next section to run the client and connect it to the server. Configure the Client # With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Optionally, change the default credentials by following the instructions in the program. Use the anjay start command to run the Client. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view:","title":"Thingy:91"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#thingy91","text":"Integrate your Nordic Thingy:91 board.","title":"Thingy:91"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#prerequisites","text":"The Thingy:91 board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform and appropriate permissions.","title":"Prerequisites"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_thingy91_app_signed.hex file. Jump to the flashing part of the tutorial.","title":"Use an already built binary"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connecting to the LwM2M Server .","title":"Start development using samples"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#part-1-get-zephyr-and-python-dependencies","text":"To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project .","title":"Part 1: Get Zephyr and Python dependencies"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#part-2-clone-the-anjay-zephyr-repository","text":"Enter the command line interface on your machine, then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client","title":"Part 2: Clone the Anjay Zephyr repository"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#part-3-compile-the-example","text":"Connect the Thingy:91 board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Compile the project for Thingy:91 using west build -b thingy91_nrf9160ns in the demo directory. Find the app_signed.hex file under the build/zephyr directory in the project folder.","title":"Part 3: Compile the example"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#flash-the-binaries","text":"To program the board, go through the process of flashing Thingy:91 . Use the nRF Connect Programmer with the downloaded .hex file and follow the program the nRF9160 SiP application section. After successful flashing, reset the board and go to the next step.","title":"Flash the binaries"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#connect-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Endpoint name field, enter your board endpoint name e.g. test_device (remember to set the same name in the next section ). In the Security mode section, select the Pre-Shared Key mode: In the Key identity field, type the same name as in the Endpoint name field. In the Key field, type the shared secret used in the device-server authentication. Note This is your own password which you will need in the next steps. Click the Add device button and Confirm in the confirmation pop-up. While in the Connect your device step, follow the next section to run the client and connect it to the server.","title":"Connect to the LwM2M Server"},{"location":"Anjay_integrations/Anjay_Nordic_integration/Thingy91/#configure-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Optionally, change the default credentials by following the instructions in the program. Use the anjay start command to run the Client. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view:","title":"Configure the Client"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/","text":"nRF9160 # Integrate your Nordic nRF9160 board. Prerequisites # The nRF9160 board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed nrfjprog from Nordic Semiconductor page A user with access to the Coiote IoT Device Management platform and appropriate permissions. Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_nrf9160dk_merged.hex file. To program the board, go through the whole process of flashing nRF described here . Use the nRF Connect Programmer with the downloaded .hex file and execute steps from the Updating the application firmware section. Reset the board and go to the Connecting to the LwM2M Server . Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connecting to the LwM2M Server . Part 1: Getting Zephyr and Python dependencies # To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project (from the set up the OS to installing the Zephyr SDK). Part 2: Cloning the Anjay zephyr repository # Enter the command line interface on your machine and change the directory to the one where you set up the Zephyr project (usually, it's ~/zephyrproject ), then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client Part 3: Compiling the example # Connect the nRF9160 board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Compile the project for nRF9160 : cd Anjay-zephyr-client/demo west build -b nrf9160dk_nrf9160ns Find the app_signed.hex file under the build/zephyr directory in the project folder. Connecting to the LwM2M Server # To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-Shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server. Configuring the Client # With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Optionally, change the default credentials by following the instructions in the program. Use the anjay start command to run the Client. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view:","title":"nRF9160"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/#nrf9160","text":"Integrate your Nordic nRF9160 board.","title":"nRF9160"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/#prerequisites","text":"The nRF9160 board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed nrfjprog from Nordic Semiconductor page A user with access to the Coiote IoT Device Management platform and appropriate permissions.","title":"Prerequisites"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_nrf9160dk_merged.hex file. To program the board, go through the whole process of flashing nRF described here . Use the nRF Connect Programmer with the downloaded .hex file and execute steps from the Updating the application firmware section. Reset the board and go to the Connecting to the LwM2M Server .","title":"Use an already built binary"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connecting to the LwM2M Server .","title":"Start development using samples"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/#part-1-getting-zephyr-and-python-dependencies","text":"To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project (from the set up the OS to installing the Zephyr SDK).","title":"Part 1: Getting Zephyr and Python dependencies"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/#part-2-cloning-the-anjay-zephyr-repository","text":"Enter the command line interface on your machine and change the directory to the one where you set up the Zephyr project (usually, it's ~/zephyrproject ), then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client","title":"Part 2: Cloning the Anjay zephyr repository"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/#part-3-compiling-the-example","text":"Connect the nRF9160 board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Compile the project for nRF9160 : cd Anjay-zephyr-client/demo west build -b nrf9160dk_nrf9160ns Find the app_signed.hex file under the build/zephyr directory in the project folder.","title":"Part 3: Compiling the example"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/#connecting-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-Shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server.","title":"Connecting to the LwM2M Server"},{"location":"Anjay_integrations/Anjay_Nordic_integration/nRF9160/#configuring-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Optionally, change the default credentials by following the instructions in the program. Use the anjay start command to run the Client. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view:","title":"Configuring the Client"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L462E-CELL1-TYPE1SC/","text":"B-L462E-CELL1/TYPE1SC # Integrate your B-L462E-CELL1 Discovery kit board along with the TYPE 1SE module with built-in eSIM (ST4SIM-200M). Prerequisites # The B-L462E-CELL1/TYPE1SC board with a USB cable. Installed STM32CubeIDE . Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform. Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L462RE external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. The board is now flashed: you can go to the Connecting to the LwM2M Server step. Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can go to Connecting to the LwM2M Server right away. Step 1: Cloning the Anjay freeRTOS client repository # Enter the command line interface on your machine and paste the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client Step 2: Compiling the board # Connect the B-L462E-CELL1/TYPE1SC board to a USB port of your machine. Go to the STM32CubeIDE. Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-B-L462E-CELL1-TYPE1SC and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC project: Right-click on the project name and select Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Lauch Configuration Selection , choose the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC option and click OK . After the build and run are complete, the board is now compiled. Connecting to the LwM2M Server # To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-Shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field. In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server. Configuring the Client # With the board still connected to a serial port interface, open a serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented in the program and save it. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use built-in eSIM card truphone then change APN to iot.truphone.com . Note If you use external eSIM card you have to check APN used by SIM card's provider. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"B-L462E-CELL1/TYPE1SC"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L462E-CELL1-TYPE1SC/#b-l462e-cell1type1sc","text":"Integrate your B-L462E-CELL1 Discovery kit board along with the TYPE 1SE module with built-in eSIM (ST4SIM-200M).","title":"B-L462E-CELL1/TYPE1SC"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L462E-CELL1-TYPE1SC/#prerequisites","text":"The B-L462E-CELL1/TYPE1SC board with a USB cable. Installed STM32CubeIDE . Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L462E-CELL1-TYPE1SC/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L462E-CELL1-TYPE1SC/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L462RE external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. The board is now flashed: you can go to the Connecting to the LwM2M Server step.","title":"Use an already built binary"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L462E-CELL1-TYPE1SC/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can go to Connecting to the LwM2M Server right away.","title":"Start development using samples"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L462E-CELL1-TYPE1SC/#step-1-cloning-the-anjay-freertos-client-repository","text":"Enter the command line interface on your machine and paste the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client","title":"Step 1: Cloning the Anjay freeRTOS client repository"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L462E-CELL1-TYPE1SC/#step-2-compiling-the-board","text":"Connect the B-L462E-CELL1/TYPE1SC board to a USB port of your machine. Go to the STM32CubeIDE. Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-B-L462E-CELL1-TYPE1SC and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC project: Right-click on the project name and select Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Lauch Configuration Selection , choose the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC option and click OK . After the build and run are complete, the board is now compiled.","title":"Step 2: Compiling the board"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L462E-CELL1-TYPE1SC/#connecting-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-Shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field. In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server.","title":"Connecting to the LwM2M Server"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L462E-CELL1-TYPE1SC/#configuring-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented in the program and save it. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use built-in eSIM card truphone then change APN to iot.truphone.com . Note If you use external eSIM card you have to check APN used by SIM card's provider. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"Configuring the Client"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/","text":"B-L475E-IOT01A # Integrate your B-L475E-IOT01A Discovery kit board. Prerequisites # The B-L475E-IOT01A board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed ST-Link or OpenOCD debugger. A user with access to the Coiote IoT Device Management platform and appropriate permissions. Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-freertos-client . Download the demo_B-L475E-IOT01A1_merged.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L4IOT external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. The board is now flashed: you can jump to the Connecting to the LwM2M Server section. Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connecting to the LwM2M Server . Part 1: Getting Zephyr and Python dependencies # To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project . Part 2: Cloning the Anjay zephyr repository # Enter the command line interface on your machine, then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client Part 3: Compiling the board # Connect the B-L475E-IOT01A board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , and manifest file to west.yml and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west.yml west update Compile the project for B-L475E-IOT01A using west build -b disco_l475_iot1 in the demo directory. Flash the board using west flash . Connecting to the LwM2M Server # To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-Shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field. In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server. Configuring the Client # With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Optionally, change the default credentials by following the instructions in the program. Use the anjay start command to run the Client. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"B-L475E-IOT01A"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/#b-l475e-iot01a","text":"Integrate your B-L475E-IOT01A Discovery kit board.","title":"B-L475E-IOT01A"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/#prerequisites","text":"The B-L475E-IOT01A board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed ST-Link or OpenOCD debugger. A user with access to the Coiote IoT Device Management platform and appropriate permissions.","title":"Prerequisites"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-freertos-client . Download the demo_B-L475E-IOT01A1_merged.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L4IOT external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. The board is now flashed: you can jump to the Connecting to the LwM2M Server section.","title":"Use an already built binary"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connecting to the LwM2M Server .","title":"Start development using samples"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/#part-1-getting-zephyr-and-python-dependencies","text":"To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project .","title":"Part 1: Getting Zephyr and Python dependencies"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/#part-2-cloning-the-anjay-zephyr-repository","text":"Enter the command line interface on your machine, then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client","title":"Part 2: Cloning the Anjay zephyr repository"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/#part-3-compiling-the-board","text":"Connect the B-L475E-IOT01A board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , and manifest file to west.yml and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west.yml west update Compile the project for B-L475E-IOT01A using west build -b disco_l475_iot1 in the demo directory. Flash the board using west flash .","title":"Part 3: Compiling the board"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/#connecting-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-Shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field. In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server.","title":"Connecting to the LwM2M Server"},{"location":"Anjay_integrations/Anjay_ST_integration/B-L475E-IOT01A/#configuring-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Optionally, change the default credentials by following the instructions in the program. Use the anjay start command to run the Client. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"Configuring the Client"},{"location":"Anjay_integrations/Anjay_ST_integration/B-U585I-IOT02A-BG96/","text":"B-U585I-IOT02A/BG96 # Integrate your B-U585I-IOT02A Discovery kit board along with the default-provided Quectel BG96 modem. Prerequisites # The STM32U585I-IOT02A/BG96 board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform. Optional: installed STM32CubeIDE . Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-B-U585I-IOT02A-BG96.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_U585AI external device. You will see a blinking diode on your board. The diode stops blinking as soon as the flashing is finished. The board is now flashed: you can go to the Connecting to the LwM2M Server step. Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connecting to the LwM2M Server . Part 1: Cloning the Anjay FreeRTOS client repository # Enter the command line interface on your machine and paste the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client Part 2: Compiling the board # Connect the STM32U585I-IOT02A board to a USB port of your machine. Go to the STM32CubeIDE . Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-B-U585I-IOT02A-BG96 and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-B-U585I-IOT02A-BG96 project: Right-click on the project name and select Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Launch Configuration Selection , choose the Anjay-freertos-client-B-U585I-IOT02A-BG96 option and click OK . After the build and run steps are done, the board is now flashed and ready for next steps. Connecting to the LwM2M Server # To connect to Coiote IoT Device Management LwM2M Server, please register here . Note If you use BG96-based configuration, you need to upgrade the modem firmware to at least the BG96MAR02A08M1G revision. Older versions may cause unexpected loss of connection. To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-Shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server. Configuring the Client # With the board still connected to a serial port interface, open a serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key, and in the configuration menu, change the default credentials to your data by following the instructions presented in the program, then save it. Tip LwM2M Server URI, endpoint name and other information you can be found in the configuration tab. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use a built-in truphone eSIM card, change the APN to iot.truphone.com . Note If you use an external eSIM card, you need to verify the APN used by your SIM card provider. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view:","title":"B-U585I-IOT02A/BG96"},{"location":"Anjay_integrations/Anjay_ST_integration/B-U585I-IOT02A-BG96/#b-u585i-iot02abg96","text":"Integrate your B-U585I-IOT02A Discovery kit board along with the default-provided Quectel BG96 modem.","title":"B-U585I-IOT02A/BG96"},{"location":"Anjay_integrations/Anjay_ST_integration/B-U585I-IOT02A-BG96/#prerequisites","text":"The STM32U585I-IOT02A/BG96 board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform. Optional: installed STM32CubeIDE .","title":"Prerequisites"},{"location":"Anjay_integrations/Anjay_ST_integration/B-U585I-IOT02A-BG96/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"Anjay_integrations/Anjay_ST_integration/B-U585I-IOT02A-BG96/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-B-U585I-IOT02A-BG96.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_U585AI external device. You will see a blinking diode on your board. The diode stops blinking as soon as the flashing is finished. The board is now flashed: you can go to the Connecting to the LwM2M Server step.","title":"Use an already built binary"},{"location":"Anjay_integrations/Anjay_ST_integration/B-U585I-IOT02A-BG96/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connecting to the LwM2M Server .","title":"Start development using samples"},{"location":"Anjay_integrations/Anjay_ST_integration/B-U585I-IOT02A-BG96/#part-1-cloning-the-anjay-freertos-client-repository","text":"Enter the command line interface on your machine and paste the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client","title":"Part 1: Cloning the Anjay FreeRTOS client repository"},{"location":"Anjay_integrations/Anjay_ST_integration/B-U585I-IOT02A-BG96/#part-2-compiling-the-board","text":"Connect the STM32U585I-IOT02A board to a USB port of your machine. Go to the STM32CubeIDE . Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-B-U585I-IOT02A-BG96 and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-B-U585I-IOT02A-BG96 project: Right-click on the project name and select Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Launch Configuration Selection , choose the Anjay-freertos-client-B-U585I-IOT02A-BG96 option and click OK . After the build and run steps are done, the board is now flashed and ready for next steps.","title":"Part 2: Compiling the board"},{"location":"Anjay_integrations/Anjay_ST_integration/B-U585I-IOT02A-BG96/#connecting-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management LwM2M Server, please register here . Note If you use BG96-based configuration, you need to upgrade the modem firmware to at least the BG96MAR02A08M1G revision. Older versions may cause unexpected loss of connection. To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-Shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server.","title":"Connecting to the LwM2M Server"},{"location":"Anjay_integrations/Anjay_ST_integration/B-U585I-IOT02A-BG96/#configuring-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key, and in the configuration menu, change the default credentials to your data by following the instructions presented in the program, then save it. Tip LwM2M Server URI, endpoint name and other information you can be found in the configuration tab. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use a built-in truphone eSIM card, change the APN to iot.truphone.com . Note If you use an external eSIM card, you need to verify the APN used by your SIM card provider. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view:","title":"Configuring the Client"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCO-MONARCH/","text":"STM32L496G-DISCO/MONARCH # Integrate your P-L496G-CELL02 Discovery kit board along with the Sequans' Monarch GM01Q-STMOD expansion board. Prerequisites # The STM32L496G-DISCO/MONARCH board with a USB cable. Installed STM32CubeIDE . Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform. Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-STM32L496G-MONARCH.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L496ZG external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. The board is now flashed: you can go to the Connecting to the LwM2M Server step. Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can go to Connecting to the LwM2M Server right away. Part 1: Cloning the Anjay freeRTOS client repository # Enter the command line interface on your machine and paste the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client Part 2: Compiling the board # Connect the STM32L496G-DISCO/MONARCH board to a USB port of your machine. Go to the STM32CubeIDE. Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-STM32L496G-MONARCH and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-STM32L496G-MONARCH project: Right-click on the project name and select Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Lauch Configuration Selection , choose the Anjay-freertos-client-STM32L496G-MONARCH option and click OK . After the build and run are complete, the board is now compiled. Connecting to the LwM2M Server # To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field. In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server. Configuring the Client # With the board still connected to a serial port interface, open a serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented in the program and save it. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use built-in eSIM card truphone then change APN to iot.truphone.com . Note If you use external eSIM card you have to check APN used by SIM card's provider. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"STM32L496G-DISCO/MONARCH"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCO-MONARCH/#stm32l496g-discomonarch","text":"Integrate your P-L496G-CELL02 Discovery kit board along with the Sequans' Monarch GM01Q-STMOD expansion board.","title":"STM32L496G-DISCO/MONARCH"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCO-MONARCH/#prerequisites","text":"The STM32L496G-DISCO/MONARCH board with a USB cable. Installed STM32CubeIDE . Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCO-MONARCH/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCO-MONARCH/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-STM32L496G-MONARCH.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L496ZG external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. The board is now flashed: you can go to the Connecting to the LwM2M Server step.","title":"Use an already built binary"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCO-MONARCH/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can go to Connecting to the LwM2M Server right away.","title":"Start development using samples"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCO-MONARCH/#part-1-cloning-the-anjay-freertos-client-repository","text":"Enter the command line interface on your machine and paste the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client","title":"Part 1: Cloning the Anjay freeRTOS client repository"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCO-MONARCH/#part-2-compiling-the-board","text":"Connect the STM32L496G-DISCO/MONARCH board to a USB port of your machine. Go to the STM32CubeIDE. Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-STM32L496G-MONARCH and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-STM32L496G-MONARCH project: Right-click on the project name and select Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Lauch Configuration Selection , choose the Anjay-freertos-client-STM32L496G-MONARCH option and click OK . After the build and run are complete, the board is now compiled.","title":"Part 2: Compiling the board"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCO-MONARCH/#connecting-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field. In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server.","title":"Connecting to the LwM2M Server"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCO-MONARCH/#configuring-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented in the program and save it. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use built-in eSIM card truphone then change APN to iot.truphone.com . Note If you use external eSIM card you have to check APN used by SIM card's provider. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"Configuring the Client"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCOBG96/","text":"STM32L496G-DISCO/BG96 # Integrate your P-L496G-CELL02 Discovery kit board along with the default-provided Quectel BG96 modem. Prerequisites # The STM32L496G-DISCO/BG96 board with a USB cable. Installed STM32CubeIDE . Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform. Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-STM32L496G-BG96.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L496ZG external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. The board is now flashed: you can go to the Connecting to the LwM2M Server step. Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can go to Connecting to the LwM2M Server right away. Part 1: Cloning the Anjay freeRTOS client repository # Enter the command line interface on your machine and paste the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client Part 2: Compiling the board # Connect the STM32L496G-DISCO board to a USB port of your machine. Go to the STM32CubeIDE. Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-STM32L496G-BG96 and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-STM32L496G-BG96 project: Right-click on the project name and select Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Lauch Configuration Selection , choose the Anjay-freertos-client-STM32L496G-BG96 option and click OK . After the build and run are complete, the board is now compiled. Connecting to the LwM2M Server # To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . Note If you use BG96-based configuration, you must upgrade the firmware of the modem to at least the BG96MAR02A08M1G revision. Older versions may cause unexpected loss of connection. To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-Shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field. In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server. Configuring the Client # With the board still connected to a serial port interface, open a serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented in the program and save it. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use built-in eSIM card truphone then change APN to iot.truphone.com . Note If you use external eSIM card you have to check APN used by SIM card's provider. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"STM32L496G-DISCO/BG96"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCOBG96/#stm32l496g-discobg96","text":"Integrate your P-L496G-CELL02 Discovery kit board along with the default-provided Quectel BG96 modem.","title":"STM32L496G-DISCO/BG96"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCOBG96/#prerequisites","text":"The STM32L496G-DISCO/BG96 board with a USB cable. Installed STM32CubeIDE . Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCOBG96/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCOBG96/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-STM32L496G-BG96.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L496ZG external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. The board is now flashed: you can go to the Connecting to the LwM2M Server step.","title":"Use an already built binary"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCOBG96/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can go to Connecting to the LwM2M Server right away.","title":"Start development using samples"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCOBG96/#part-1-cloning-the-anjay-freertos-client-repository","text":"Enter the command line interface on your machine and paste the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client","title":"Part 1: Cloning the Anjay freeRTOS client repository"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCOBG96/#part-2-compiling-the-board","text":"Connect the STM32L496G-DISCO board to a USB port of your machine. Go to the STM32CubeIDE. Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-STM32L496G-BG96 and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-STM32L496G-BG96 project: Right-click on the project name and select Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Lauch Configuration Selection , choose the Anjay-freertos-client-STM32L496G-BG96 option and click OK . After the build and run are complete, the board is now compiled.","title":"Part 2: Compiling the board"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCOBG96/#connecting-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management LwM2M Server, please register at https://eu.iot.avsystem.cloud . Note If you use BG96-based configuration, you must upgrade the firmware of the modem to at least the BG96MAR02A08M1G revision. Older versions may cause unexpected loss of connection. To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. test_device . In the Security mode section, select the PSK (Pre-Shared Key) mode: In the Key identity field, type the same name as in the Endpoint name field. In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, follow the next section to run the client and connect it to the server.","title":"Connecting to the LwM2M Server"},{"location":"Anjay_integrations/Anjay_ST_integration/STM32L496G-DISCOBG96/#configuring-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented in the program and save it. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use built-in eSIM card truphone then change APN to iot.truphone.com . Note If you use external eSIM card you have to check APN used by SIM card's provider. Go to Coiote DM to check if your device connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"Configuring the Client"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/","text":"Building LwM2M applications for STM boards with I-CUBE-Anjay # Start prototyping custom LwM2M applications on your STMicroelectronics board with I-CUBE-Anjay using STM32CubeMX. Prerequisites # An STM board with a USB cable. Installed STM32CubeMX . Downloaded Anjay I-CUBE pack file . Step 1: Installing the Anjay I-CUBE software pack # Open STM32CUBEMX and in the New project section, select ACCESS TO BOARD SELECTOR . From the list of STM boards, select your board, click Start project and click No in the Initialize all peripherals with their default mode pop-up that appears. In the Pinout & Configuration tab, click Software Packs and select Manage Software Packs . Click From local and select your Anjay I-Cube pack from your local disk. After reading the license agreement, check the license agreement checkbox and click Finish . The pack will be installed in a few seconds. Back in the Pinout & Configuration tab, click Software Packs and select Select Components . From the list of packs, click AVSystem.I-CUBE-Anjay to expand a list of bundles and components. Configure options according to the specific instruction for your board in the Specific CubeMX settings . Step 2: Configuring the Anjay I-CUBE application # Before you generate code for your application, you need to configure it as per the specific requirements for your board: Back in the Pinout & Configuration tab, expand the Software Packs tab that has appeared in the side menu and click AVSystem.I-CUBE-Anjay.x.xx.x : In the Mode window that appears, check all the boxes next to the LwM2M Stack, Device LwM2M Client example, Board Support LwM2M, Board Support X STMOD PLUS MODEMS, Cellular Middleware STM32 Cellular options. In the Configuration window: Go to the Parameter Settings tab and configure your Anjay Library. For a detailed description of all Anjay library configuration options, see here . Go to the Client Settings tab and configure your LwM2M Client parameters like Endpoint name, PSK, PSK identity, server URI and others. In the Pinout & Configuration tab: Expand the Connectivity , Middleware , Security and System Core tabs: Configure options according to the specific instruction for your board in the Specific CubeMX settings . Step 3: Generating application code # Back in your project overview, select the Project Manager tab: In the Project tab: In the Project Name field, provide a name for your project. From the Toolchain/IDE expandable list, select STM32CubeIDE . In linker settings adjust Minimum Heap Size to 0x5000 and Minimum Stack Size to 0xC00. In the Code Generator tab: Check the Generate peripheral initialization as a pair of '.c/.h' files per peripheral . Click GENERATE CODE and confirm by clicking Yes in the pop-up. After the project is generated, you can use it further in the CubeIDE to develop, flash and debug your application. Specific CubeMX settings # B-L462E-CELL1 # Start from board selector with B-L462E-CELL1 board, do not initialize all peripherals with their default mode. Through Select Components menu choose desired components from the pack, in this example select: LwM2M Stack Anjay LwIP mbedtls Device Application - FullExample Board Support LwM2M LwM2M Objects: B-L462E-CELL1 B-L462E-CELL1 BSP Board Support X_STMOD_PLUS_MODEMS - TYPE1SC STM32_Cellular Core Platform config: B-L462E-CELL1 Apply the following settings: Connectivity tab: I2C1 - Enable I2C1 USART1 - Enable Asynchronous, enable global interrupts USART2 - Enable Asynchronous, enable global interrupts USART3 - Enable Asynchronous, enable global interrupts Middleware tab: FreeRTOS Interface - CMSIS_V1 TOTAL_HEAP_SIZE - 32768 Bytes USE_COUNTING_SEMAPHORES - Enabled Project Manager: Code Generator - Enable Generate peripheral initialization as a pair of '.c/.h' files per peripheral. Software Packs: I-CUBE-Anjay - select all enabled components and modify Client Settings with connection parameters. Parameter settings can be modified to alter Anjay LwM2M Library configuration. Generate the project and open it in STM32CubeIDE . Right click on the project Build Configurations -> Set Active -> Release . Select generated project and modify Properties -> C/C++ Build -> Settings -> MCU Settings Change Runtime library to Standard C . Flash the project using Run As -> STM32 Cortex-M C/C++ Application . P-L496G-CELL02 # Start from board selector with STM32L496G-DISCO board, do not initialize all peripherals with their default mode. Through Select Components menu choose desired components from the pack, in this example select: LwM2M Stack Anjay LwIP mbedtls Device Application - FullExample Board Support LwM2M LwM2M Objects: P-L496G-CELL02 P-L496G-CELL02 BSP Board Support X_STMOD_PLUS_MODEMS - BG96 or MONARCH (depending on your setup) STM32_Cellular Core Platform config: P-L496G-CELL02 Apply the following settings: Connectivity tab: I2C1 - Enable I2C USART1 - Enable Asynchronous, enable global interrupts USART2 - Enable Asynchronous, enable global interrupts Security tab: RNG - Enable Middleware tab: FreeRTOS Interface - CMSIS_V1 TOTAL_HEAP_SIZE - 32768 Bytes USE_COUNTING_SEMAPHORES - Enabled USE_TIMERS - Enabled vTaskDelayUntil - Enabled uxTaskGetStackHighWaterMark - Enabled System Core SYS Timebase Source - TIM1 Project Manager: Code Generator - Enable Generate peripheral initialization as a pair of '.c/.h' files per peripheral. Software Packs: I-CUBE-Anjay - select all enabled components and modify Client Settings with connection parameters. Parameter settings can be modified to alter Anjay LwM2M Library configuration. Generate the project and open it in STM32CubeIDE . Select generated project and modify Properties -> C/C++ Build -> Settings -> MCU Settings Change Runtime library to Standard C . Flash the project using Run As -> STM32 Cortex-M C/C++ Application . Compiler-dependent options # When generating code, CubeMX might warn you that USE_NEWLIB_REENTRANT option must be set. However, not all the IDEs have newlib in their toolchain libraries and checking this option can make your project uncompilable. For IAR and Keil simply press Yes to skip it. Depending on the Compiler Toolchain, redirecting standard output into the console via UART and serial port might require additional options in IDE and compiler-specific code. Solutions can be found below as well as in the Pack's demonstration projects. IAR Embedded Workbench # IAR Embedded Workbench for ARM version 9.20.2 or higher is required to compile the project. To compile client application example, navigate to Project -> Options ... -> C/C++ Compiler -> C dialect and set Allow VLA . To allow and handle serial output with application flashed on board and not attached to IAR, Semihosting has to be disabled. Navigate to Project -> Options ... -> General Options -> Library low-level interface implementation and set it to None . In main.c add the following lines of code: #include \"plf_hw_config.h\" #include <stdio.h> #include \"trace_interface.h\" #include <LowLevelIOInterface.h> // ... int iar_fputc(int ch); #define PUTCHAR_PROTOTYPE int iar_fputc(int ch) // ... size_t __write(int file, unsigned char const *ptr, size_t len) { size_t idx; unsigned char const *pdata = ptr; for (idx = 0; idx < len; idx++) { iar_fputc((int)*pdata); pdata++; } return len; } PUTCHAR_PROTOTYPE { /* Place your implementation of putchar here */ /* e.g. write a character to the USART3 and Loop until the end of transmission */ HAL_UART_Transmit(&TRACE_INTERFACE_UART_HANDLE, (uint8_t *)&ch, 1, 0xFFFF); return ch; } Keil uVision # The newest Keil MDK distribution no longer contains Arm Compiler 5, which is a target compiler when generating a project with STM32CubeMX. You have to either install Keil MDK version older than 5.37 or install the missing compiler manually - more information here . Keil's errno defines conflict with LwIP's errno and it must be resolved by adding LwIP's include folder to the list of the system includes. To do so, navigate to Project -> Options for Target (...) -> C/C++ -> Misc Controls and add a following command control option (ensure proper path; incorrect path will not generate an error): -J ../Middlewares/Third_Party/AVSystem_LwM2M_Stack/LwIP/src/include/compat/stdc -J \"$J\" To ensure proper handling of serial output with application flashed on board and not attached to uVision, navigate to Project -> Manage -> Run-Time Environment... -> Compiler -> I/O , select checkboxes and choose User variant for STRERR , STDIN and STDOUT . In main.c add the following lines of code: #include \"plf_hw_config.h\" #include <stdio.h> // ... #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) // ... PUTCHAR_PROTOTYPE { /* Place your implementation of putchar here */ /* e.g. write a character to the USART3 and Loop until the end of transmission */ HAL_UART_Transmit(&TRACE_INTERFACE_UART_HANDLE, (uint8_t *)&ch, 1, 0xFFFF); return ch; }","title":"Building LwM2M applications for STM boards with I-CUBE-Anjay"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#building-lwm2m-applications-for-stm-boards-with-i-cube-anjay","text":"Start prototyping custom LwM2M applications on your STMicroelectronics board with I-CUBE-Anjay using STM32CubeMX.","title":"Building LwM2M applications for STM boards with I-CUBE-Anjay"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#prerequisites","text":"An STM board with a USB cable. Installed STM32CubeMX . Downloaded Anjay I-CUBE pack file .","title":"Prerequisites"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#step-1-installing-the-anjay-i-cube-software-pack","text":"Open STM32CUBEMX and in the New project section, select ACCESS TO BOARD SELECTOR . From the list of STM boards, select your board, click Start project and click No in the Initialize all peripherals with their default mode pop-up that appears. In the Pinout & Configuration tab, click Software Packs and select Manage Software Packs . Click From local and select your Anjay I-Cube pack from your local disk. After reading the license agreement, check the license agreement checkbox and click Finish . The pack will be installed in a few seconds. Back in the Pinout & Configuration tab, click Software Packs and select Select Components . From the list of packs, click AVSystem.I-CUBE-Anjay to expand a list of bundles and components. Configure options according to the specific instruction for your board in the Specific CubeMX settings .","title":"Step 1: Installing the Anjay I-CUBE software pack"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#step-2-configuring-the-anjay-i-cube-application","text":"Before you generate code for your application, you need to configure it as per the specific requirements for your board: Back in the Pinout & Configuration tab, expand the Software Packs tab that has appeared in the side menu and click AVSystem.I-CUBE-Anjay.x.xx.x : In the Mode window that appears, check all the boxes next to the LwM2M Stack, Device LwM2M Client example, Board Support LwM2M, Board Support X STMOD PLUS MODEMS, Cellular Middleware STM32 Cellular options. In the Configuration window: Go to the Parameter Settings tab and configure your Anjay Library. For a detailed description of all Anjay library configuration options, see here . Go to the Client Settings tab and configure your LwM2M Client parameters like Endpoint name, PSK, PSK identity, server URI and others. In the Pinout & Configuration tab: Expand the Connectivity , Middleware , Security and System Core tabs: Configure options according to the specific instruction for your board in the Specific CubeMX settings .","title":"Step 2: Configuring the Anjay I-CUBE application"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#step-3-generating-application-code","text":"Back in your project overview, select the Project Manager tab: In the Project tab: In the Project Name field, provide a name for your project. From the Toolchain/IDE expandable list, select STM32CubeIDE . In linker settings adjust Minimum Heap Size to 0x5000 and Minimum Stack Size to 0xC00. In the Code Generator tab: Check the Generate peripheral initialization as a pair of '.c/.h' files per peripheral . Click GENERATE CODE and confirm by clicking Yes in the pop-up. After the project is generated, you can use it further in the CubeIDE to develop, flash and debug your application.","title":"Step 3: Generating application code"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#specific-cubemx-settings","text":"","title":"Specific CubeMX settings"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#b-l462e-cell1","text":"Start from board selector with B-L462E-CELL1 board, do not initialize all peripherals with their default mode. Through Select Components menu choose desired components from the pack, in this example select: LwM2M Stack Anjay LwIP mbedtls Device Application - FullExample Board Support LwM2M LwM2M Objects: B-L462E-CELL1 B-L462E-CELL1 BSP Board Support X_STMOD_PLUS_MODEMS - TYPE1SC STM32_Cellular Core Platform config: B-L462E-CELL1 Apply the following settings: Connectivity tab: I2C1 - Enable I2C1 USART1 - Enable Asynchronous, enable global interrupts USART2 - Enable Asynchronous, enable global interrupts USART3 - Enable Asynchronous, enable global interrupts Middleware tab: FreeRTOS Interface - CMSIS_V1 TOTAL_HEAP_SIZE - 32768 Bytes USE_COUNTING_SEMAPHORES - Enabled Project Manager: Code Generator - Enable Generate peripheral initialization as a pair of '.c/.h' files per peripheral. Software Packs: I-CUBE-Anjay - select all enabled components and modify Client Settings with connection parameters. Parameter settings can be modified to alter Anjay LwM2M Library configuration. Generate the project and open it in STM32CubeIDE . Right click on the project Build Configurations -> Set Active -> Release . Select generated project and modify Properties -> C/C++ Build -> Settings -> MCU Settings Change Runtime library to Standard C . Flash the project using Run As -> STM32 Cortex-M C/C++ Application .","title":"B-L462E-CELL1"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#p-l496g-cell02","text":"Start from board selector with STM32L496G-DISCO board, do not initialize all peripherals with their default mode. Through Select Components menu choose desired components from the pack, in this example select: LwM2M Stack Anjay LwIP mbedtls Device Application - FullExample Board Support LwM2M LwM2M Objects: P-L496G-CELL02 P-L496G-CELL02 BSP Board Support X_STMOD_PLUS_MODEMS - BG96 or MONARCH (depending on your setup) STM32_Cellular Core Platform config: P-L496G-CELL02 Apply the following settings: Connectivity tab: I2C1 - Enable I2C USART1 - Enable Asynchronous, enable global interrupts USART2 - Enable Asynchronous, enable global interrupts Security tab: RNG - Enable Middleware tab: FreeRTOS Interface - CMSIS_V1 TOTAL_HEAP_SIZE - 32768 Bytes USE_COUNTING_SEMAPHORES - Enabled USE_TIMERS - Enabled vTaskDelayUntil - Enabled uxTaskGetStackHighWaterMark - Enabled System Core SYS Timebase Source - TIM1 Project Manager: Code Generator - Enable Generate peripheral initialization as a pair of '.c/.h' files per peripheral. Software Packs: I-CUBE-Anjay - select all enabled components and modify Client Settings with connection parameters. Parameter settings can be modified to alter Anjay LwM2M Library configuration. Generate the project and open it in STM32CubeIDE . Select generated project and modify Properties -> C/C++ Build -> Settings -> MCU Settings Change Runtime library to Standard C . Flash the project using Run As -> STM32 Cortex-M C/C++ Application .","title":"P-L496G-CELL02"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#compiler-dependent-options","text":"When generating code, CubeMX might warn you that USE_NEWLIB_REENTRANT option must be set. However, not all the IDEs have newlib in their toolchain libraries and checking this option can make your project uncompilable. For IAR and Keil simply press Yes to skip it. Depending on the Compiler Toolchain, redirecting standard output into the console via UART and serial port might require additional options in IDE and compiler-specific code. Solutions can be found below as well as in the Pack's demonstration projects.","title":"Compiler-dependent options"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#iar-embedded-workbench","text":"IAR Embedded Workbench for ARM version 9.20.2 or higher is required to compile the project. To compile client application example, navigate to Project -> Options ... -> C/C++ Compiler -> C dialect and set Allow VLA . To allow and handle serial output with application flashed on board and not attached to IAR, Semihosting has to be disabled. Navigate to Project -> Options ... -> General Options -> Library low-level interface implementation and set it to None . In main.c add the following lines of code: #include \"plf_hw_config.h\" #include <stdio.h> #include \"trace_interface.h\" #include <LowLevelIOInterface.h> // ... int iar_fputc(int ch); #define PUTCHAR_PROTOTYPE int iar_fputc(int ch) // ... size_t __write(int file, unsigned char const *ptr, size_t len) { size_t idx; unsigned char const *pdata = ptr; for (idx = 0; idx < len; idx++) { iar_fputc((int)*pdata); pdata++; } return len; } PUTCHAR_PROTOTYPE { /* Place your implementation of putchar here */ /* e.g. write a character to the USART3 and Loop until the end of transmission */ HAL_UART_Transmit(&TRACE_INTERFACE_UART_HANDLE, (uint8_t *)&ch, 1, 0xFFFF); return ch; }","title":"IAR Embedded Workbench"},{"location":"Anjay_integrations/Anjay_ST_integration/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#keil-uvision","text":"The newest Keil MDK distribution no longer contains Arm Compiler 5, which is a target compiler when generating a project with STM32CubeMX. You have to either install Keil MDK version older than 5.37 or install the missing compiler manually - more information here . Keil's errno defines conflict with LwIP's errno and it must be resolved by adding LwIP's include folder to the list of the system includes. To do so, navigate to Project -> Options for Target (...) -> C/C++ -> Misc Controls and add a following command control option (ensure proper path; incorrect path will not generate an error): -J ../Middlewares/Third_Party/AVSystem_LwM2M_Stack/LwIP/src/include/compat/stdc -J \"$J\" To ensure proper handling of serial output with application flashed on board and not attached to uVision, navigate to Project -> Manage -> Run-Time Environment... -> Compiler -> I/O , select checkboxes and choose User variant for STRERR , STDIN and STDOUT . In main.c add the following lines of code: #include \"plf_hw_config.h\" #include <stdio.h> // ... #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) // ... PUTCHAR_PROTOTYPE { /* Place your implementation of putchar here */ /* e.g. write a character to the USART3 and Loop until the end of transmission */ HAL_UART_Transmit(&TRACE_INTERFACE_UART_HANDLE, (uint8_t *)&ch, 1, 0xFFFF); return ch; }","title":"Keil uVision"},{"location":"Anjay_integrations/ESP32_integration/ESP32-DevKitCBG96/","text":"ESP32-DevKitC with BG96 # Integrate your ESP32-based device with Quectel BG96 module to manage it via Coiote DM. Prerequisites # An ESP32 device. A BG96 module with internet connection (it is strongly recommended to have a BG96 with firmware version BG96MAR03A06M1G). Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform . Step 1: Prepare project # Create a project directory for the integration. Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client --recursive . Run . $HOME/esp/esp-idf/export.sh and idf.py set-target esp32 . Open the menuconfig with the idf.py menuconfig command, navigate to Component config -> anjay-esp32-client . In Choose targeted development board , select ESP32-DevKitC and derivatives from the list of supported boards. In Choose an interface , select External BG96 module . In BG96 module configuration , specify the UART port, Tx pin and Rx pin for the BG96 module. Example port and pin numbers are provided in the screenshot below. In Client options , provide device credentials and Server URI: Endpoint name - your device endpoint name Server URI - the address and port of your Coiote DM installation, e.g. coaps://eu.iot.avsystem.cloud:5684 Security mode - the PSK security mode PSK configuration - the PSK identity and PSK key In the Connection configuration , set APN name to internet for the sake of this tutorial. However, APN name depends on your SIM card operator. Press s on the keyboard to Save the configuration. Step 2: Connect BG96 module to a ESP32-DevKitC # Connect the Tx, Rx and GND pins, respectively, to the ESP32-DevKitC pins selected in the previous step. Step 3: Add device to Coiote DM # To connect your ESP32-DevKitC to the Coiote IoT Device Management LwM2M Server, use your access to a Coiote DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID field, type the endpoint name provided in the IDF menuconfig Client options , e.g. ESP32_test . In the Security mode section, select the PSK mode. In the Key identity field, type the identity provided in the IDF menuconfig Client options , e.g. ESP32_test . In the Key field, type the psk key provided in the IDF menuconfig Client options . Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, the server is waiting for the board to connect. You can now start connecting the device. Step 4: Flash ESP32-DevKitC # Open the command line interface, go to your project directory, and run idf.py flash monitor .","title":"ESP32-DevKitC with BG96"},{"location":"Anjay_integrations/ESP32_integration/ESP32-DevKitCBG96/#esp32-devkitc-with-bg96","text":"Integrate your ESP32-based device with Quectel BG96 module to manage it via Coiote DM.","title":"ESP32-DevKitC with BG96"},{"location":"Anjay_integrations/ESP32_integration/ESP32-DevKitCBG96/#prerequisites","text":"An ESP32 device. A BG96 module with internet connection (it is strongly recommended to have a BG96 with firmware version BG96MAR03A06M1G). Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform .","title":"Prerequisites"},{"location":"Anjay_integrations/ESP32_integration/ESP32-DevKitCBG96/#step-1-prepare-project","text":"Create a project directory for the integration. Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client --recursive . Run . $HOME/esp/esp-idf/export.sh and idf.py set-target esp32 . Open the menuconfig with the idf.py menuconfig command, navigate to Component config -> anjay-esp32-client . In Choose targeted development board , select ESP32-DevKitC and derivatives from the list of supported boards. In Choose an interface , select External BG96 module . In BG96 module configuration , specify the UART port, Tx pin and Rx pin for the BG96 module. Example port and pin numbers are provided in the screenshot below. In Client options , provide device credentials and Server URI: Endpoint name - your device endpoint name Server URI - the address and port of your Coiote DM installation, e.g. coaps://eu.iot.avsystem.cloud:5684 Security mode - the PSK security mode PSK configuration - the PSK identity and PSK key In the Connection configuration , set APN name to internet for the sake of this tutorial. However, APN name depends on your SIM card operator. Press s on the keyboard to Save the configuration.","title":"Step 1: Prepare project"},{"location":"Anjay_integrations/ESP32_integration/ESP32-DevKitCBG96/#step-2-connect-bg96-module-to-a-esp32-devkitc","text":"Connect the Tx, Rx and GND pins, respectively, to the ESP32-DevKitC pins selected in the previous step.","title":"Step 2: Connect BG96 module to a ESP32-DevKitC"},{"location":"Anjay_integrations/ESP32_integration/ESP32-DevKitCBG96/#step-3-add-device-to-coiote-dm","text":"To connect your ESP32-DevKitC to the Coiote IoT Device Management LwM2M Server, use your access to a Coiote DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID field, type the endpoint name provided in the IDF menuconfig Client options , e.g. ESP32_test . In the Security mode section, select the PSK mode. In the Key identity field, type the identity provided in the IDF menuconfig Client options , e.g. ESP32_test . In the Key field, type the psk key provided in the IDF menuconfig Client options . Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, the server is waiting for the board to connect. You can now start connecting the device.","title":"Step 3: Add device to Coiote DM"},{"location":"Anjay_integrations/ESP32_integration/ESP32-DevKitCBG96/#step-4-flash-esp32-devkitc","text":"Open the command line interface, go to your project directory, and run idf.py flash monitor .","title":"Step 4: Flash ESP32-DevKitC"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/","text":"M5StickC # Integrate your ESP32-based device to manage it via Coiote DM. Prerequisites # An M5StickC device. Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform. Step 1: Download the Anjay ESP32 client files # Create a project directory for the integration. Go to https://github.com/AVSystem/Anjay-esp32-client/releases and download m5stickc-plus.bin and nvs_partition_gen.py to your project directory. Step 2: Configure the client using an NVS partition # Create a nvs_config.csv file and save it in your project directory. In the file, provide your credentials in [wifi_ssid], [wifi_password], [endpoint_name], [identity], [psk], [lwm2m_server_uri] (without the [] brackets). Use the following snippet as a template: Important The Identity parameter stands for both the device endpoint name and its PSK identity, therefore these two must be identical in Coiote DM. key,type,encoding,value config,namespace,, wifi_ssid,data,string,[wifi_ssid] wifi_pswd,data,string,[wifi_password] wifi_inter_en,data,u8,1 endpoint_name,data,string,[endpoint_name] identity,data,string,[identity] psk,data,string,[psk] uri,data,string,[lwm2m_server_uri] writable_wifi,namespace,, wifi_ssid,data,string,[wifi_ssid] wifi_pswd,data,string,[wifi_password] wifi_inter_en,data,u8,0 Note The additional parameters under the writable_wifi namespace are used to provide a secondary Wi-Fi configuration (it is not obligatory). This allows for switching between Wi-Fi configurations while the device is running. Note The nvs_config.csv file can also be downloaded from https://github.com/AVSystem/Anjay-esp32-client/releases Open a command line interface, go to your project directory, and generate the NVS partition: Linux pip3 install future cryptography python3 nvs_partition_gen.py generate nvs_config.csv nvs_config.bin 0x4000 Windows pip3 install future cryptography python nvs_partition_gen.py generate nvs_config.csv nvs_config.bin 0x4000 Step 3: Add device to Coiote DM # To connect your M5StickC to the Coiote IoT Device Management LwM2M Server, use your access to a Coiote DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID field, type the endpoint name provided in the nvs_config.csv , e.g. ESP32_test . In the Security mode section, select the PSK mode. In the Key identity field, type the name provided in the nvs_config.csv , e.g. ESP32_test . In the Key field, type the psk key provided in the nvs_config.csv . Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, the server is waiting for the board to connect. You can now start connecting the device. Step 4: Flash the board and run device # Use pre-built binaries to flash the board and provide credentials by flashing the NVS partition binary. Install the esptool.py : pip install esptool Flash the board: Tip Before flashing the device you should erase the flash first to make sure you have correct settings: Linux esptool.py erase_flash Windows esptool erase_flash Linux esptool.py -b 750000 --chip esp32 write_flash 0x0000 m5stickc-plus.bin Windows esptool -b 750000 --chip esp32 write_flash 0x0000 m5stickc-plus.bin Flash the NVS partition binary: Linux esptool.py -b 750000 --chip esp32 write_flash 0x9000 nvs_config.bin Windows esptool -b 750000 --chip esp32 write_flash 0x9000 nvs_config.bin Once executed, the device will be reset and run with the configuration you provided. M5StickC LwM2M objects # After successful connection to Coiote DM, you can explore the available device objects. Target Objects ESP32 common Security (/0) Server (/1) Device (/3) Firmware Update (/5) WLAN connectivity (/12) M5StickC-Plus Push button (/3347) Light control (/3311) Temperature sensor (/3303) Accelerometer (/3313) Gyroscope (/3343) Upgrade device firmware over the air # To perform a FOTA upgrade, you need an established connection between the M5StickC and Coiote DM (see instructions above). Build new firmware version # Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client . Go to the directory of the cloned repository and run idf.py set-target esp32 . Run git submodule update --recursive --init . Run idf.py menuconfig , navigate to Component config/anjay-esp32-client , and from the supported boards, select M5StickC . Press s and enter to save. Run idf.py build . Once executed, check if the binary file has been built in the following path $PROJECT_DIR/build/anjay-esp32-client/build . Schedule upgrade in Coiote DM # In your Coiote DM account, select your device in Device inventory and click the LwM2M Firmware tab. Click Schedule new firmware upgrade . Click Upload to select the binary file from your local drive, select COAP in the Image delivery protocol , and click Upgrade . Tip The COAPS option is also supported. To use it, you may need to additionally provide the Base URI parameter (depending on your server settings). The FOTA upgrade is now scheduled. Note that it might take a few minutes to complete. Once the upgrade is finished, you can check the new version of the firmware under Current firmware .","title":"M5StickC"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/#m5stickc","text":"Integrate your ESP32-based device to manage it via Coiote DM.","title":"M5StickC"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/#prerequisites","text":"An M5StickC device. Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/#step-1-download-the-anjay-esp32-client-files","text":"Create a project directory for the integration. Go to https://github.com/AVSystem/Anjay-esp32-client/releases and download m5stickc-plus.bin and nvs_partition_gen.py to your project directory.","title":"Step 1: Download the Anjay ESP32 client files"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/#step-2-configure-the-client-using-an-nvs-partition","text":"Create a nvs_config.csv file and save it in your project directory. In the file, provide your credentials in [wifi_ssid], [wifi_password], [endpoint_name], [identity], [psk], [lwm2m_server_uri] (without the [] brackets). Use the following snippet as a template: Important The Identity parameter stands for both the device endpoint name and its PSK identity, therefore these two must be identical in Coiote DM. key,type,encoding,value config,namespace,, wifi_ssid,data,string,[wifi_ssid] wifi_pswd,data,string,[wifi_password] wifi_inter_en,data,u8,1 endpoint_name,data,string,[endpoint_name] identity,data,string,[identity] psk,data,string,[psk] uri,data,string,[lwm2m_server_uri] writable_wifi,namespace,, wifi_ssid,data,string,[wifi_ssid] wifi_pswd,data,string,[wifi_password] wifi_inter_en,data,u8,0 Note The additional parameters under the writable_wifi namespace are used to provide a secondary Wi-Fi configuration (it is not obligatory). This allows for switching between Wi-Fi configurations while the device is running. Note The nvs_config.csv file can also be downloaded from https://github.com/AVSystem/Anjay-esp32-client/releases Open a command line interface, go to your project directory, and generate the NVS partition: Linux pip3 install future cryptography python3 nvs_partition_gen.py generate nvs_config.csv nvs_config.bin 0x4000 Windows pip3 install future cryptography python nvs_partition_gen.py generate nvs_config.csv nvs_config.bin 0x4000","title":"Step 2: Configure the client using an NVS partition"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/#step-3-add-device-to-coiote-dm","text":"To connect your M5StickC to the Coiote IoT Device Management LwM2M Server, use your access to a Coiote DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID field, type the endpoint name provided in the nvs_config.csv , e.g. ESP32_test . In the Security mode section, select the PSK mode. In the Key identity field, type the name provided in the nvs_config.csv , e.g. ESP32_test . In the Key field, type the psk key provided in the nvs_config.csv . Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, the server is waiting for the board to connect. You can now start connecting the device.","title":"Step 3: Add device to Coiote DM"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/#step-4-flash-the-board-and-run-device","text":"Use pre-built binaries to flash the board and provide credentials by flashing the NVS partition binary. Install the esptool.py : pip install esptool Flash the board: Tip Before flashing the device you should erase the flash first to make sure you have correct settings: Linux esptool.py erase_flash Windows esptool erase_flash Linux esptool.py -b 750000 --chip esp32 write_flash 0x0000 m5stickc-plus.bin Windows esptool -b 750000 --chip esp32 write_flash 0x0000 m5stickc-plus.bin Flash the NVS partition binary: Linux esptool.py -b 750000 --chip esp32 write_flash 0x9000 nvs_config.bin Windows esptool -b 750000 --chip esp32 write_flash 0x9000 nvs_config.bin Once executed, the device will be reset and run with the configuration you provided.","title":"Step 4: Flash the board and run device"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/#m5stickc-lwm2m-objects","text":"After successful connection to Coiote DM, you can explore the available device objects. Target Objects ESP32 common Security (/0) Server (/1) Device (/3) Firmware Update (/5) WLAN connectivity (/12) M5StickC-Plus Push button (/3347) Light control (/3311) Temperature sensor (/3303) Accelerometer (/3313) Gyroscope (/3343)","title":"M5StickC LwM2M objects"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/#upgrade-device-firmware-over-the-air","text":"To perform a FOTA upgrade, you need an established connection between the M5StickC and Coiote DM (see instructions above).","title":"Upgrade device firmware over the air"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/#build-new-firmware-version","text":"Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client . Go to the directory of the cloned repository and run idf.py set-target esp32 . Run git submodule update --recursive --init . Run idf.py menuconfig , navigate to Component config/anjay-esp32-client , and from the supported boards, select M5StickC . Press s and enter to save. Run idf.py build . Once executed, check if the binary file has been built in the following path $PROJECT_DIR/build/anjay-esp32-client/build .","title":"Build new firmware version"},{"location":"Anjay_integrations/ESP32_integration/M5Stick/#schedule-upgrade-in-coiote-dm","text":"In your Coiote DM account, select your device in Device inventory and click the LwM2M Firmware tab. Click Schedule new firmware upgrade . Click Upload to select the binary file from your local drive, select COAP in the Image delivery protocol , and click Upgrade . Tip The COAPS option is also supported. To use it, you may need to additionally provide the Base URI parameter (depending on your server settings). The FOTA upgrade is now scheduled. Note that it might take a few minutes to complete. Once the upgrade is finished, you can check the new version of the firmware under Current firmware .","title":"Schedule upgrade in Coiote DM"},{"location":"Anjay_integrations/ESP32_integration/M5StickBG96/","text":"M5StickC with BG96 # Integrate your ESP32-based device with Quectel BG96 module to manage it via Coiote DM. Prerequisites # An M5StickC device. A BG96 module with internet connection (it is strongly recommended to have a BG96 with firmware version BG96MAR03A06M1G). Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform . Step 1: Prepare project # Create a project directory for the integration. Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client --recursive . Run . $HOME/esp/esp-idf/export.sh and idf.py set-target esp32 . Open the menuconfig with the idf.py menuconfig command, navigate to Component config -> anjay-esp32-client . In Choose targeted development board , select M5StickC from the list of supported boards. In Choose an interface , select External BG96 module . In BG96 module configuration , specify the UART port, Tx pin and Rx pin for the BG96 module. Example port and pin numbers are provided in the screenshot below. In Client options , provide device credentials and Server URI: Endpoint name - your device endpoint name Server URI - the address and port of your Coiote DM installation, e.g. coaps://eu.iot.avsystem.cloud:5684 Security mode - the PSK security mode PSK configuration - the PSK identity and PSK key In the Connection configuration , set APN name to internet for the sake of this tutorial. However, APN name depends on your SIM card operator. Press s on the keyboard to Save the configuration. Step 2: Connect BG96 module to a M5StickC # Connect the Tx, Rx and GND pins, respectively, to the M5StickC pins selected in the previous step on the basis of the following example connection: M5Stick GND > BG96 6 GND M5Stick G26 > BG96 10 UART Rx M5Stick G0 > BG96 8 UART Tx Step 3: Add device to Coiote DM # To connect your M5StickC to the Coiote IoT Device Management LwM2M Server, use your access to a Coiote DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID field, type the endpoint name provided in the IDF menuconfig Client options , e.g. ESP32BG96 . In the Security mode section, select the PSK mode. In the Key identity field, type the identity provided in the IDF menuconfig Client options , e.g. ESP32BG96 . In the Key field, type the psk key provided in the IDF menuconfig Client options . Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, the server is waiting for the board to connect. You can now start connecting the device. Step 4: Flash M5StickC # Open the command line interface, go to your project directory, and run idf.py -b 750000 flash monitor .","title":"M5StickC with BG96"},{"location":"Anjay_integrations/ESP32_integration/M5StickBG96/#m5stickc-with-bg96","text":"Integrate your ESP32-based device with Quectel BG96 module to manage it via Coiote DM.","title":"M5StickC with BG96"},{"location":"Anjay_integrations/ESP32_integration/M5StickBG96/#prerequisites","text":"An M5StickC device. A BG96 module with internet connection (it is strongly recommended to have a BG96 with firmware version BG96MAR03A06M1G). Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform .","title":"Prerequisites"},{"location":"Anjay_integrations/ESP32_integration/M5StickBG96/#step-1-prepare-project","text":"Create a project directory for the integration. Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client --recursive . Run . $HOME/esp/esp-idf/export.sh and idf.py set-target esp32 . Open the menuconfig with the idf.py menuconfig command, navigate to Component config -> anjay-esp32-client . In Choose targeted development board , select M5StickC from the list of supported boards. In Choose an interface , select External BG96 module . In BG96 module configuration , specify the UART port, Tx pin and Rx pin for the BG96 module. Example port and pin numbers are provided in the screenshot below. In Client options , provide device credentials and Server URI: Endpoint name - your device endpoint name Server URI - the address and port of your Coiote DM installation, e.g. coaps://eu.iot.avsystem.cloud:5684 Security mode - the PSK security mode PSK configuration - the PSK identity and PSK key In the Connection configuration , set APN name to internet for the sake of this tutorial. However, APN name depends on your SIM card operator. Press s on the keyboard to Save the configuration.","title":"Step 1: Prepare project"},{"location":"Anjay_integrations/ESP32_integration/M5StickBG96/#step-2-connect-bg96-module-to-a-m5stickc","text":"Connect the Tx, Rx and GND pins, respectively, to the M5StickC pins selected in the previous step on the basis of the following example connection: M5Stick GND > BG96 6 GND M5Stick G26 > BG96 10 UART Rx M5Stick G0 > BG96 8 UART Tx","title":"Step 2: Connect BG96 module to a M5StickC"},{"location":"Anjay_integrations/ESP32_integration/M5StickBG96/#step-3-add-device-to-coiote-dm","text":"To connect your M5StickC to the Coiote IoT Device Management LwM2M Server, use your access to a Coiote DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board: Log in to Coiote DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID field, type the endpoint name provided in the IDF menuconfig Client options , e.g. ESP32BG96 . In the Security mode section, select the PSK mode. In the Key identity field, type the identity provided in the IDF menuconfig Client options , e.g. ESP32BG96 . In the Key field, type the psk key provided in the IDF menuconfig Client options . Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, the server is waiting for the board to connect. You can now start connecting the device.","title":"Step 3: Add device to Coiote DM"},{"location":"Anjay_integrations/ESP32_integration/M5StickBG96/#step-4-flash-m5stickc","text":"Open the command line interface, go to your project directory, and run idf.py -b 750000 flash monitor .","title":"Step 4: Flash M5StickC"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Configure_Azure_IoT_Central_integration/","text":"Connect integration # To enable communication and data flow between the Azure IoT Central and Coiote DM platforms, you first need to integrate them using the Hyperscaler Integration Center in Coiote DM. Follow the instruction below to learn how to do it. Prerequisites: # An active IoT Central with hub owner access permissions. A Coiote DM user account with permissions to use the Hyperscaler Integration Center. Get the Azure IoT Central integration credentials # In your Azure IoT Central account view, from the left menu, select Application . Under Management , copy the full Application URL (along with '.azureiotcentral.com') into Notepad or other place to keep it for later. From the left menu, click Permissions , select API tokens and click +New . In the dialog window, provide a name for the token and select App Administrator as the role, then click the copy icon for the newly generated token. Now you need to use the obtained credentials in the Coiote DM platform. Set up the Azure IoT Central integration # Use the obtained credentials to establish the integration between Coiote DM and your Azure IoT Central application: In your Coiote DM user account, go to Administration --> Hyperscaler Integration Center In the Integration tab, find the Azure IoT Central tile and click Connect . In the dialog window, paste the previously copied Application URL and API token into the relevant fields. click Save to keep the setting. Your integration should now be established. To get the integration up and running, try synchronizing devices with Azure IoT Central","title":"Configure integration"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Configure_Azure_IoT_Central_integration/#connect-integration","text":"To enable communication and data flow between the Azure IoT Central and Coiote DM platforms, you first need to integrate them using the Hyperscaler Integration Center in Coiote DM. Follow the instruction below to learn how to do it.","title":"Connect integration"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Configure_Azure_IoT_Central_integration/#prerequisites","text":"An active IoT Central with hub owner access permissions. A Coiote DM user account with permissions to use the Hyperscaler Integration Center.","title":"Prerequisites:"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Configure_Azure_IoT_Central_integration/#get-the-azure-iot-central-integration-credentials","text":"In your Azure IoT Central account view, from the left menu, select Application . Under Management , copy the full Application URL (along with '.azureiotcentral.com') into Notepad or other place to keep it for later. From the left menu, click Permissions , select API tokens and click +New . In the dialog window, provide a name for the token and select App Administrator as the role, then click the copy icon for the newly generated token. Now you need to use the obtained credentials in the Coiote DM platform.","title":"Get the Azure IoT Central integration credentials"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Configure_Azure_IoT_Central_integration/#set-up-the-azure-iot-central-integration","text":"Use the obtained credentials to establish the integration between Coiote DM and your Azure IoT Central application: In your Coiote DM user account, go to Administration --> Hyperscaler Integration Center In the Integration tab, find the Azure IoT Central tile and click Connect . In the dialog window, paste the previously copied Application URL and API token into the relevant fields. click Save to keep the setting. Your integration should now be established. To get the integration up and running, try synchronizing devices with Azure IoT Central","title":"Set up the Azure IoT Central integration"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/","text":"Set an Observation # This section describes how to set an Observation in your Azure IoT Central application. Setting an Observation lets your devices know what value changes and for what particular resources they need to notify you about. An Observation can be set for any or all the components of the data model : objects, objects instances, and resources. Whenever there is a change in values, a device will send a Notify message to Coiote DM, which in turn will transfer it to Azure IoT Central. In this section, you learn how to: Assign a device template that acts as a translator between Coiote DM and Azure IoT Central. Create a device group in Azure IoT Central, because an Observation is set at the group level. Run Jobs to add, edit or delete Observations. See value changes for the observed resources. Prerequisites # An active Azure IoT Central with hub owner access permissions. A Coiote DM user account with permissions to use the Azure IoT Central integration. A device group created in Coiote DM. A configured integration between Coiote DM and Azure Iot Central . A configured integration template in Coiote DM, assigned to the device group . A connected device in Coiote DM that has been exported to or imported from Azure IoT Central. Assign a device template # To enable correct communication between Coiote DM and Azure IoT Central, you need two templates. The first template configures the Coiote DM integration with Azure. ( Follow the instruction to learn how to configure it.) The second template builds on the first one and allows to provide information that is used only in Azure IoT Central. For example: a given resource is temperature and is measured in Celsius. Download LwM2M template in Coiote DM # In Coiote DM, go to Administration \u2192 Hyperscaler Integration Center and select the Templates tab. In the list of templates, find the one from which you want to generate the IoT Central template. Attention The template must contain the objects that you want to observe. For example, the Velocity object is contained in the Default rich LwM2M schema template that we use in this tutorial. Click Generate Azure IoT Central template to download the template as a JSON file. Info Default minimal LwM2M schema and Default rich LwM2M schema are the default Azure integration templates that you can use to generate a template for Azure IoT Central. Default minimal LwM2M schema contains only two objects: LwM2M Server and Device that are necessary to connect a device to a LwM2M server. Default rich LwM2M schema contains some additional objects that describe the current state of a device. You can use these default templates to test your integration or for some basic operations. If your device contains other LwM2M objects, then you need to create a new template or copy and edit on of the default templates. Create a device template in Azure IoT Central # From the Overview tab of your Azure IoT Central account, go to IoT Central Application URL . To add a new device template, go to Device templates from the left pane and then click + New . On the Select type page, select the IoT device tile and click Next: Customize . Enter a name for your device template and click Next: Review . Leave the checkbox unticked. In this example, our device template is called template_test_name . On the Review page, click Create . Now you'll be prompted to create a model for your template. Select the Import a model tile. This is where you import the .JSON file you exported from Coiote DM. To publish this device template to the application, click Publish on the Model page. Assign a device template in Azure IoT Central # To assign the published template to a device, go to Devices from the left pane and click on the device you want to observe. In our case, the device is called soilquality . Click Manage templates and choose Assign template . In the dialog that appears, find the template you have previously created in Azure (in our case, this is template_test_name ) and click Assign template . Create a group # Now that you have a device with a template assigned to it, you need to add this device to a group. To create a group: In Azure IoT Central, go to Device groups from the left pane and click + New . Note A device group can only contain devices from a single device template. Fill in the following information: Group name and an optional description. In our case, the group is called device_group_test . Device group access : skip, because LwM2M test application doesn\u2019t use organizations. Create a device query : from the Value drop-down menu, select the name of the device template you created in the previous step ( template_test_name ). Click Run query . After running a query, you'll see the list of devices that are associated with this template. In our case it\u2019s the device called soilquality . Click Save . Set up an Observation # Let\u2019s set an Observation operation on resource ID 6/0/4 . This is Velocity, and the data is sent as Telemetry. To add an Observation, you need to use the Jobs tab. In Azure IoT Central, go to Jobs from the left pane and click + New job . Now configure your job: Name *: Provide a name and an optional description of the job. Access : skip, because LwM2M test application doesn\u2019t use organizations. Target devices : select the device group this job will run on. In our case this is device_group_test . Job properties : Set Job type as Property . Under the Name field, select Velocity attribute / Observed and turn the toggle to True . Add the attributes to this observation. Click + Add and select Velocity attributes / Observation attributes / <name> from the drop-down menu. In the dialog that appears, specify the name of the attribute: pmin . Close the dialog. Enter a value of Velocity attributes / Observation attributes / pmin . In this tutorial the value is set at 1 , which means that notifications will be sent every second. Click Next . Info pmin - the minimum time in seconds between two notifications. pmax - the maximum time in seconds between two notifications. The notification is sent even if the value didn't change. Read more about other attributes in our Brief description of OMA LwM2M . In Delivery options , click Next . In Schedule , click Next . Review the job: n6n0n4 stands for Velocity. Note that objects, object instances, and resources are separated by n in Azure IoT Central. observed is set at true The attribute pmin is set at 1 second. Click Run . See the value changes in Azure IoT Central # In Azure IoT Central, go to Devices from the left pane and click on the device you're observing. You'll see the list of messages that notify about any changes in the desired and reported properties for this device. In the Raw data tab, unfold one of the recent messages. Note that this tab contains all the messages received from your device, and some of them might relate to other objects. Look for a recent message where the JSON snippet contains the information that the Observation has been set for the telemetry resource n6n0n4 (Velocity). To see the data received about the value changes, scroll right until you see the Velocity column. Tip If you don\u2019t see any value in the relevant column (e.g., Velocity), scroll all the way right to the very last column Unmodeled data . If it contains an entry similar to {\"n6n0n4\":\"1634741504000\"} , it means there is a mismatch between Coiote DM and the Azure IoT Central templates. Velocity is a Telemetry resource, but apparently it's set as Property in Azure. To fix this error, go to Device templates in Azure IoT Central, select the relevant template and find the resource you want to edit. In the Capability type column, select Telemetry from the drop-down menu so that it\u2019s consistent with what you have in Coiote DM. Click Save . Go back to Devices and refresh the page to see the changes. Edit or delete an Observation # To edit or delete an Observation, you need to create a new job. In Azure IoT Central, go to Jobs from the left pane and click + New job . Alternatively, you can copy an existing job: Select the job and then click Copy job . To edit the Observation attributes , change the value in the text box. To change the map keys (e.g., pmax to pmin), click on the Ellipse button. To delete an Observation, turn off the toggle to False . Check an Observation in Coiote DM # This step is optional. If you want to make sure that the Observation has been set in Coiote DM as well, do the following: In Coiote DM, go to Device inventory and click on the observed device. From the left pane of the device panel, go to Objects . Find the resource you want to check. In our example, this is 4 Velocity resource in the 6 Location object. Click the refresh button to the left from the Value tracking . You'll see that checkboxes next to Value tracking and Attributes are now filled in green. Next steps # Air quality monitoring - tutorial","title":"Set an Observation"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#set-an-observation","text":"This section describes how to set an Observation in your Azure IoT Central application. Setting an Observation lets your devices know what value changes and for what particular resources they need to notify you about. An Observation can be set for any or all the components of the data model : objects, objects instances, and resources. Whenever there is a change in values, a device will send a Notify message to Coiote DM, which in turn will transfer it to Azure IoT Central. In this section, you learn how to: Assign a device template that acts as a translator between Coiote DM and Azure IoT Central. Create a device group in Azure IoT Central, because an Observation is set at the group level. Run Jobs to add, edit or delete Observations. See value changes for the observed resources.","title":"Set an Observation"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#prerequisites","text":"An active Azure IoT Central with hub owner access permissions. A Coiote DM user account with permissions to use the Azure IoT Central integration. A device group created in Coiote DM. A configured integration between Coiote DM and Azure Iot Central . A configured integration template in Coiote DM, assigned to the device group . A connected device in Coiote DM that has been exported to or imported from Azure IoT Central.","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#assign-a-device-template","text":"To enable correct communication between Coiote DM and Azure IoT Central, you need two templates. The first template configures the Coiote DM integration with Azure. ( Follow the instruction to learn how to configure it.) The second template builds on the first one and allows to provide information that is used only in Azure IoT Central. For example: a given resource is temperature and is measured in Celsius.","title":"Assign a device template"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#download-lwm2m-template-in-coiote-dm","text":"In Coiote DM, go to Administration \u2192 Hyperscaler Integration Center and select the Templates tab. In the list of templates, find the one from which you want to generate the IoT Central template. Attention The template must contain the objects that you want to observe. For example, the Velocity object is contained in the Default rich LwM2M schema template that we use in this tutorial. Click Generate Azure IoT Central template to download the template as a JSON file. Info Default minimal LwM2M schema and Default rich LwM2M schema are the default Azure integration templates that you can use to generate a template for Azure IoT Central. Default minimal LwM2M schema contains only two objects: LwM2M Server and Device that are necessary to connect a device to a LwM2M server. Default rich LwM2M schema contains some additional objects that describe the current state of a device. You can use these default templates to test your integration or for some basic operations. If your device contains other LwM2M objects, then you need to create a new template or copy and edit on of the default templates.","title":"Download LwM2M template in Coiote DM"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#create-a-device-template-in-azure-iot-central","text":"From the Overview tab of your Azure IoT Central account, go to IoT Central Application URL . To add a new device template, go to Device templates from the left pane and then click + New . On the Select type page, select the IoT device tile and click Next: Customize . Enter a name for your device template and click Next: Review . Leave the checkbox unticked. In this example, our device template is called template_test_name . On the Review page, click Create . Now you'll be prompted to create a model for your template. Select the Import a model tile. This is where you import the .JSON file you exported from Coiote DM. To publish this device template to the application, click Publish on the Model page.","title":"Create a device template in Azure IoT Central"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#assign-a-device-template-in-azure-iot-central","text":"To assign the published template to a device, go to Devices from the left pane and click on the device you want to observe. In our case, the device is called soilquality . Click Manage templates and choose Assign template . In the dialog that appears, find the template you have previously created in Azure (in our case, this is template_test_name ) and click Assign template .","title":"Assign a device template in Azure IoT Central"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#create-a-group","text":"Now that you have a device with a template assigned to it, you need to add this device to a group. To create a group: In Azure IoT Central, go to Device groups from the left pane and click + New . Note A device group can only contain devices from a single device template. Fill in the following information: Group name and an optional description. In our case, the group is called device_group_test . Device group access : skip, because LwM2M test application doesn\u2019t use organizations. Create a device query : from the Value drop-down menu, select the name of the device template you created in the previous step ( template_test_name ). Click Run query . After running a query, you'll see the list of devices that are associated with this template. In our case it\u2019s the device called soilquality . Click Save .","title":"Create a group"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#set-up-an-observation","text":"Let\u2019s set an Observation operation on resource ID 6/0/4 . This is Velocity, and the data is sent as Telemetry. To add an Observation, you need to use the Jobs tab. In Azure IoT Central, go to Jobs from the left pane and click + New job . Now configure your job: Name *: Provide a name and an optional description of the job. Access : skip, because LwM2M test application doesn\u2019t use organizations. Target devices : select the device group this job will run on. In our case this is device_group_test . Job properties : Set Job type as Property . Under the Name field, select Velocity attribute / Observed and turn the toggle to True . Add the attributes to this observation. Click + Add and select Velocity attributes / Observation attributes / <name> from the drop-down menu. In the dialog that appears, specify the name of the attribute: pmin . Close the dialog. Enter a value of Velocity attributes / Observation attributes / pmin . In this tutorial the value is set at 1 , which means that notifications will be sent every second. Click Next . Info pmin - the minimum time in seconds between two notifications. pmax - the maximum time in seconds between two notifications. The notification is sent even if the value didn't change. Read more about other attributes in our Brief description of OMA LwM2M . In Delivery options , click Next . In Schedule , click Next . Review the job: n6n0n4 stands for Velocity. Note that objects, object instances, and resources are separated by n in Azure IoT Central. observed is set at true The attribute pmin is set at 1 second. Click Run .","title":"Set up an Observation"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#see-the-value-changes-in-azure-iot-central","text":"In Azure IoT Central, go to Devices from the left pane and click on the device you're observing. You'll see the list of messages that notify about any changes in the desired and reported properties for this device. In the Raw data tab, unfold one of the recent messages. Note that this tab contains all the messages received from your device, and some of them might relate to other objects. Look for a recent message where the JSON snippet contains the information that the Observation has been set for the telemetry resource n6n0n4 (Velocity). To see the data received about the value changes, scroll right until you see the Velocity column. Tip If you don\u2019t see any value in the relevant column (e.g., Velocity), scroll all the way right to the very last column Unmodeled data . If it contains an entry similar to {\"n6n0n4\":\"1634741504000\"} , it means there is a mismatch between Coiote DM and the Azure IoT Central templates. Velocity is a Telemetry resource, but apparently it's set as Property in Azure. To fix this error, go to Device templates in Azure IoT Central, select the relevant template and find the resource you want to edit. In the Capability type column, select Telemetry from the drop-down menu so that it\u2019s consistent with what you have in Coiote DM. Click Save . Go back to Devices and refresh the page to see the changes.","title":"See the value changes in Azure IoT Central"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#edit-or-delete-an-observation","text":"To edit or delete an Observation, you need to create a new job. In Azure IoT Central, go to Jobs from the left pane and click + New job . Alternatively, you can copy an existing job: Select the job and then click Copy job . To edit the Observation attributes , change the value in the text box. To change the map keys (e.g., pmax to pmin), click on the Ellipse button. To delete an Observation, turn off the toggle to False .","title":"Edit or delete an Observation"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#check-an-observation-in-coiote-dm","text":"This step is optional. If you want to make sure that the Observation has been set in Coiote DM as well, do the following: In Coiote DM, go to Device inventory and click on the observed device. From the left pane of the device panel, go to Objects . Find the resource you want to check. In our example, this is 4 Velocity resource in the 6 Location object. Click the refresh button to the left from the Value tracking . You'll see that checkboxes next to Value tracking and Attributes are now filled in green.","title":"Check an Observation in Coiote DM"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Set_an_Observation/#next-steps","text":"Air quality monitoring - tutorial","title":"Next steps"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Device_operations/Overview/","text":"Overview # How synchronization works # Coiote DM provides zero-touch provisioning for devices synchronized with Azure IoT Central. This means any devices imported using a CSV file are automatically created within Coiote DM and Azure IoT Central and from this time on are synchronized periodically. Therefore, after any successful synchronization, you can be sure that any devices that have been imported via Coiote DM will be presented in their actual state within Azure IoT Central.","title":"Overview"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Device_operations/Overview/#overview","text":"","title":"Overview"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Device_operations/Overview/#how-synchronization-works","text":"Coiote DM provides zero-touch provisioning for devices synchronized with Azure IoT Central. This means any devices imported using a CSV file are automatically created within Coiote DM and Azure IoT Central and from this time on are synchronized periodically. Therefore, after any successful synchronization, you can be sure that any devices that have been imported via Coiote DM will be presented in their actual state within Azure IoT Central.","title":"How synchronization works"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Central/","text":"Synchronize devices with Azure IoT Central # Importing devices to Coiote DM and synchronizing them with Azure IoT Central is a quick way to start using your Coiote DM - Azure IoT Central integration. The import operation will do two basic operations automatically: Create device entities in Coiote DM with the credentials that you specified, create the devices' \"counterparts\" within Azure IoT Central and synchronize them with Coiote DM. Prerequisites # A connected Azure IoT Central integration in the Hyperscaler Integration Center. Import devices from CSV using a default integration template # In the import process, you will need a list of devices that you want to import along with an integration template to be used by Azure IoT Central. To learn more about Azure integration templates, see the Configure integration templates section. In Coiote DM, go to Administration -> Hyperscaler Integration Center . Make sure you have an integration connected in the Integration tab. Go to the Device list tab and click Import devices . In the Import devices wizard: From the Select template field, select one of two default integration templates: Default minimal LwM2M schema - a pre-defined template implementing a basic device data model. Default rich LwM2M schema - a pre-defined template implementing an extended device data model. Note Integration templates are crucial in the device import process. Optionally, you can create your custom device template and use it in importing. Check the instructions in the Configure integration templates section. In the Import devices from a CSV file section: If you already have a CSV file with devices for import, click Browse and select the file. If you don't have a CSV with devices for import yet, click the device template link to download an empty template that you can fill in with your data: DeviceId - provide your device ID. For LwM2M-enabled devices, device ID usually equals the endpoint name. IMSI - provide a random but unique number for each entry (or provide IMSI number if your device has one). PSK_Identity_Key - provide a unique plain-text PSK identity key used for secure communication between the device and Coiote DM. PSK_Key - provide a unique HEX-encoded PSK key used for secure communication between the device and Coiote DM. Save the template and upload it using the Browse button and dialog window. Click Sync with Azure . After a moment, the import operation should finish successfully. Now you can connect your physical devices to Coiote DM using their credentials and the dedicated URL displayed after the successful device import. What the import operation does # Once the devices from the CSV template are imported into Coiote DM, the following actions are performed: In Coiote DM, device entities are created based on the credentials provided in the template. All such entities are visible in the Device list tab: In Coiote DM, a dedicated integration group is automatically created (with name built up by the hyperscalercenter prefix and the template ID, e.g. 618238c8bcafcb43b2911261 ). In your Azure IoT Central, devices are created and ready for operation. Check device error logs # Logs may come helpful for diagnosing and troubleshooting issues with the communication between the three actors in the integration: the device, Coiote DM, and Azure IoT Central. To see logs for your integrated devices: Go to the single device view and from the left menu, select the Logs tile. In the Logs panel, expand the view by clicking on More and configure the following: Store from level - select Use custom and set log level to DEBUG for 1 hour. Tags - select HYPERSCALERS The communication logs will be displayed, allowing you to check, diagnose, or debug any issues.","title":"Synchronize devices with Azure IoT Central"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Central/#synchronize-devices-with-azure-iot-central","text":"Importing devices to Coiote DM and synchronizing them with Azure IoT Central is a quick way to start using your Coiote DM - Azure IoT Central integration. The import operation will do two basic operations automatically: Create device entities in Coiote DM with the credentials that you specified, create the devices' \"counterparts\" within Azure IoT Central and synchronize them with Coiote DM.","title":"Synchronize devices with Azure IoT Central"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Central/#prerequisites","text":"A connected Azure IoT Central integration in the Hyperscaler Integration Center.","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Central/#import-devices-from-csv-using-a-default-integration-template","text":"In the import process, you will need a list of devices that you want to import along with an integration template to be used by Azure IoT Central. To learn more about Azure integration templates, see the Configure integration templates section. In Coiote DM, go to Administration -> Hyperscaler Integration Center . Make sure you have an integration connected in the Integration tab. Go to the Device list tab and click Import devices . In the Import devices wizard: From the Select template field, select one of two default integration templates: Default minimal LwM2M schema - a pre-defined template implementing a basic device data model. Default rich LwM2M schema - a pre-defined template implementing an extended device data model. Note Integration templates are crucial in the device import process. Optionally, you can create your custom device template and use it in importing. Check the instructions in the Configure integration templates section. In the Import devices from a CSV file section: If you already have a CSV file with devices for import, click Browse and select the file. If you don't have a CSV with devices for import yet, click the device template link to download an empty template that you can fill in with your data: DeviceId - provide your device ID. For LwM2M-enabled devices, device ID usually equals the endpoint name. IMSI - provide a random but unique number for each entry (or provide IMSI number if your device has one). PSK_Identity_Key - provide a unique plain-text PSK identity key used for secure communication between the device and Coiote DM. PSK_Key - provide a unique HEX-encoded PSK key used for secure communication between the device and Coiote DM. Save the template and upload it using the Browse button and dialog window. Click Sync with Azure . After a moment, the import operation should finish successfully. Now you can connect your physical devices to Coiote DM using their credentials and the dedicated URL displayed after the successful device import.","title":"Import devices from CSV using a default integration template"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Central/#what-the-import-operation-does","text":"Once the devices from the CSV template are imported into Coiote DM, the following actions are performed: In Coiote DM, device entities are created based on the credentials provided in the template. All such entities are visible in the Device list tab: In Coiote DM, a dedicated integration group is automatically created (with name built up by the hyperscalercenter prefix and the template ID, e.g. 618238c8bcafcb43b2911261 ). In your Azure IoT Central, devices are created and ready for operation.","title":"What the import operation does"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Central_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Central/#check-device-error-logs","text":"Logs may come helpful for diagnosing and troubleshooting issues with the communication between the three actors in the integration: the device, Coiote DM, and Azure IoT Central. To see logs for your integrated devices: Go to the single device view and from the left menu, select the Logs tile. In the Logs panel, expand the view by clicking on More and configure the following: Store from level - select Use custom and set log level to DEBUG for 1 hour. Tags - select HYPERSCALERS The communication logs will be displayed, allowing you to check, diagnose, or debug any issues.","title":"Check device error logs"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_DPS_integration/Configuring_Azure_IoT_DPS_integration_extension/","text":"Connect integration # Azure IoT Hub Device Provisioning Service (DPS) is a helper service for Azure IoT Hub that enables zero-touch provisioning of IoT devices at scale. Azure DPS ensures high availability by providing load balancing across multiple hubs and supporting reprovisioning based on a change in the device. For more information about Azure DPS, refer to the official documentation . Coiote DM communicates with Azure DPS to add a device to the right IoT hub and then receives the credentials to connect to the selected hub. To enable communication between Azure DPS and Coiote DM, you first need to connect them using the Hyperscaler Integration Center in Coiote DM. Follow the instruction below to learn how to do it. Prerequisites # An active DPS with linked IoT hubs . An active IoT Hub with hub owner access permissions. Read here how to create a hub. A Coiote DM user account with permissions to use the Azure DPS integration. Create an Enrollment group # This step describes how to create an Enrollment group. If you already have one, proceed to the Get the credentials section. A device can be enrolled in Azure DPS either individually or as a group of devices that share a specific attestation mechanism. Currently, Coiote DM doesn't support Individual Enrollments, so you need to choose the Enrollment group option. To create an Enrollment group: Log in to the Azure portal and click on your Device Provisioning Service . Go to Manage enrollments from the left pane. Click + Add enrollment group . Provide the group name and select the Symmetric key option from the Attestation Type. Make sure that the Auto-generate keys checkbox is ticked. Click Save . You\u2019ve just created your enrollment group. The generated Symmetric Key will be used in the next step. Info On the Enrollment Group Details page, you can also select to which hub the enrollment group will be assigned. The list of hubs that are connected to this DPS is displayed in the drop-down menu under Select the IoT hubs this group can be assigned to . To add more hubs to this list, click Link a new IoT hub or go to the Linked IoT hubs page from the left pane. You can also define how devices should be assigned to hubs. From the Select how you want to assign devices to hubs drop-down menu, the following options are available: Lowest latency, Evenly weighted distribution, Static configuration, or Custom. For more information, refer to the official Azure DPS documentation . Get the credentials # This step explains where you can get the credentials for setting up the Azure DPS integration in Coiote DM. ID Scope # The ID Scope is used to identify the specific provisioning service for the device registration. The ID Scope is automatically generated and unique. Log in to the Azure portal and click on your Device Provisioning Service . On the Overview page, locate the ID Scope under the Essentials section. Paste it into Notepad or another place to keep it for later. Enrollment group key # Select Manage enrollments from the left pane of your Azure DPS. Under the Enrollment Groups tab, click on the group that you want to use. In the Settings tab, under Attestation Type, copy Primary Key. Set up the Azure DPS integration # In your Coiote DM account, go to Administration \u2014> Hyperscaler Integration Center . In the Integration tab, locate the Azure DPS tale and click Connect . In the dialog that appears, provide the credentials for your Azure DPS integration: ID Scope : paste the ID Scope copied from the Overview page. Enrollment group key: paste the Primary Key copied from the Enrollment group. Device Provisioning Service hostname: API HTTP host. It can be left as it is: global.azure-devices-provisioning.net What happens next # After you set up Azure DPS and connect your Azure DPS integration in Coiote DM, device provisioning and reprovisioning to the proper IoT hub are automated. You aren\u2019t required to make any changes in Coiote DM. Importing and exporting devices, upgrading device firmware, and setting observations\u2014all these operations happen at the level of individual hubs. The detailed instructions are provided in our Azure IoT Hub documentation . To see to which hub a device has been assigned: Go to Manage enrollments from the left pane. Under the Enrollment Groups tab, click on the group. Select the Registration Records tab and see the Assigned IoT Hub column. Next steps # Device operations on Azure IoT Hub Azure DPS documentation","title":"Configure integration"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_DPS_integration/Configuring_Azure_IoT_DPS_integration_extension/#connect-integration","text":"Azure IoT Hub Device Provisioning Service (DPS) is a helper service for Azure IoT Hub that enables zero-touch provisioning of IoT devices at scale. Azure DPS ensures high availability by providing load balancing across multiple hubs and supporting reprovisioning based on a change in the device. For more information about Azure DPS, refer to the official documentation . Coiote DM communicates with Azure DPS to add a device to the right IoT hub and then receives the credentials to connect to the selected hub. To enable communication between Azure DPS and Coiote DM, you first need to connect them using the Hyperscaler Integration Center in Coiote DM. Follow the instruction below to learn how to do it.","title":"Connect integration"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_DPS_integration/Configuring_Azure_IoT_DPS_integration_extension/#prerequisites","text":"An active DPS with linked IoT hubs . An active IoT Hub with hub owner access permissions. Read here how to create a hub. A Coiote DM user account with permissions to use the Azure DPS integration.","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_DPS_integration/Configuring_Azure_IoT_DPS_integration_extension/#create-an-enrollment-group","text":"This step describes how to create an Enrollment group. If you already have one, proceed to the Get the credentials section. A device can be enrolled in Azure DPS either individually or as a group of devices that share a specific attestation mechanism. Currently, Coiote DM doesn't support Individual Enrollments, so you need to choose the Enrollment group option. To create an Enrollment group: Log in to the Azure portal and click on your Device Provisioning Service . Go to Manage enrollments from the left pane. Click + Add enrollment group . Provide the group name and select the Symmetric key option from the Attestation Type. Make sure that the Auto-generate keys checkbox is ticked. Click Save . You\u2019ve just created your enrollment group. The generated Symmetric Key will be used in the next step. Info On the Enrollment Group Details page, you can also select to which hub the enrollment group will be assigned. The list of hubs that are connected to this DPS is displayed in the drop-down menu under Select the IoT hubs this group can be assigned to . To add more hubs to this list, click Link a new IoT hub or go to the Linked IoT hubs page from the left pane. You can also define how devices should be assigned to hubs. From the Select how you want to assign devices to hubs drop-down menu, the following options are available: Lowest latency, Evenly weighted distribution, Static configuration, or Custom. For more information, refer to the official Azure DPS documentation .","title":"Create an Enrollment group"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_DPS_integration/Configuring_Azure_IoT_DPS_integration_extension/#get-the-credentials","text":"This step explains where you can get the credentials for setting up the Azure DPS integration in Coiote DM.","title":"Get the credentials"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_DPS_integration/Configuring_Azure_IoT_DPS_integration_extension/#id-scope","text":"The ID Scope is used to identify the specific provisioning service for the device registration. The ID Scope is automatically generated and unique. Log in to the Azure portal and click on your Device Provisioning Service . On the Overview page, locate the ID Scope under the Essentials section. Paste it into Notepad or another place to keep it for later.","title":"ID Scope"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_DPS_integration/Configuring_Azure_IoT_DPS_integration_extension/#enrollment-group-key","text":"Select Manage enrollments from the left pane of your Azure DPS. Under the Enrollment Groups tab, click on the group that you want to use. In the Settings tab, under Attestation Type, copy Primary Key.","title":"Enrollment group key"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_DPS_integration/Configuring_Azure_IoT_DPS_integration_extension/#set-up-the-azure-dps-integration","text":"In your Coiote DM account, go to Administration \u2014> Hyperscaler Integration Center . In the Integration tab, locate the Azure DPS tale and click Connect . In the dialog that appears, provide the credentials for your Azure DPS integration: ID Scope : paste the ID Scope copied from the Overview page. Enrollment group key: paste the Primary Key copied from the Enrollment group. Device Provisioning Service hostname: API HTTP host. It can be left as it is: global.azure-devices-provisioning.net","title":"Set up the Azure DPS integration"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_DPS_integration/Configuring_Azure_IoT_DPS_integration_extension/#what-happens-next","text":"After you set up Azure DPS and connect your Azure DPS integration in Coiote DM, device provisioning and reprovisioning to the proper IoT hub are automated. You aren\u2019t required to make any changes in Coiote DM. Importing and exporting devices, upgrading device firmware, and setting observations\u2014all these operations happen at the level of individual hubs. The detailed instructions are provided in our Azure IoT Hub documentation . To see to which hub a device has been assigned: Go to Manage enrollments from the left pane. Under the Enrollment Groups tab, click on the group. Select the Registration Records tab and see the Assigned IoT Hub column.","title":"What happens next"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_DPS_integration/Configuring_Azure_IoT_DPS_integration_extension/#next-steps","text":"Device operations on Azure IoT Hub Azure DPS documentation","title":"Next steps"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Configure_Azure_IoT_Hub_integration/","text":"Connect integration # To enable communication and data flow between the Azure IoT Hub and Coiote DM platforms, you first need to integrate them using the Hyperscaler Integration Center in Coiote DM. Follow the instructions below to learn how to do it. Prerequisites # An active IoT Hub with hub owner access permissions. Check here how to create a hub. A Coiote DM user account with permissions to use the Hyperscaler Integration Center. An active Azure Blob Storage account (creating a new dedicated account for the integration is required). Get the IoT Hub connection string # The Azure IoT Hub connection string is required in the integration process. Here is how to obtain it: In your IoT Hub general view, go to Shared access policies : From the list of policies, click the iothubowner policy. From the keys section, click the copy icon for the Primary connection string and paste it into Notepad or any other safe place to keep it for later. Info For detailed information about the IoT Hub permissions, please visit the Control access to IoT Hub section of the Azure IoT Hub documentation. Get the Azure Blob storage connection string # Important For the integration to work properly, it is required to have an empty Azure Blob storage account dedicated exclusively for the integration. An Azure Blob storage connection string is required in the integration process. Here is how to obtain it: In your Azure Blob storage account, go to Access keys . Click Show keys , click the copy icon next to the connection string and paste it into Notepad or any other safe place to keep it for later. Set up the Azure IoT Hub integration # Use the obtained credentials to establish the integration between Coiote DM and your Azure IoT hub: In your Coiote DM user account, go to Administration --> Hyperscaler Integration Center In the Integration tab, find the Azure IoT Hub tile and click Connect . In the dialog window, paste the previously copied IoT Hub connection string and Azure Blob storage connection string into the relevant fields. click Save to keep the setting. Your integration should now be established. To get the integration up and running, try synchronizing devices with Azure IoT Hub","title":"Configure integration"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Configure_Azure_IoT_Hub_integration/#connect-integration","text":"To enable communication and data flow between the Azure IoT Hub and Coiote DM platforms, you first need to integrate them using the Hyperscaler Integration Center in Coiote DM. Follow the instructions below to learn how to do it.","title":"Connect integration"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Configure_Azure_IoT_Hub_integration/#prerequisites","text":"An active IoT Hub with hub owner access permissions. Check here how to create a hub. A Coiote DM user account with permissions to use the Hyperscaler Integration Center. An active Azure Blob Storage account (creating a new dedicated account for the integration is required).","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Configure_Azure_IoT_Hub_integration/#get-the-iot-hub-connection-string","text":"The Azure IoT Hub connection string is required in the integration process. Here is how to obtain it: In your IoT Hub general view, go to Shared access policies : From the list of policies, click the iothubowner policy. From the keys section, click the copy icon for the Primary connection string and paste it into Notepad or any other safe place to keep it for later. Info For detailed information about the IoT Hub permissions, please visit the Control access to IoT Hub section of the Azure IoT Hub documentation.","title":"Get the IoT Hub connection string"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Configure_Azure_IoT_Hub_integration/#get-the-azure-blob-storage-connection-string","text":"Important For the integration to work properly, it is required to have an empty Azure Blob storage account dedicated exclusively for the integration. An Azure Blob storage connection string is required in the integration process. Here is how to obtain it: In your Azure Blob storage account, go to Access keys . Click Show keys , click the copy icon next to the connection string and paste it into Notepad or any other safe place to keep it for later.","title":"Get the Azure Blob storage connection string"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Configure_Azure_IoT_Hub_integration/#set-up-the-azure-iot-hub-integration","text":"Use the obtained credentials to establish the integration between Coiote DM and your Azure IoT hub: In your Coiote DM user account, go to Administration --> Hyperscaler Integration Center In the Integration tab, find the Azure IoT Hub tile and click Connect . In the dialog window, paste the previously copied IoT Hub connection string and Azure Blob storage connection string into the relevant fields. click Save to keep the setting. Your integration should now be established. To get the integration up and running, try synchronizing devices with Azure IoT Hub","title":"Set up the Azure IoT Hub integration"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Execute/","text":"Perform LwM2M Execute # This section describes how to perform a LwM2M EXECUTE operation in your Azure IoT Hub. An EXECUTE operation lets you perform operations on IoT devices such as a reboot or a firmware upgrade, only on individual resources. In this section, you learn how to: Perform a LwM2M EXECUTE operation on a resource Prerequisites # An active Azure IoT Hub with hub owner access permissions. A Coiote DM user account with permissions to use the integration extension. A device group created in Coiote DM. A configured extension between Coiote DM and Azure Iot Hub . A configured integration template in Coiote DM, assigned to the device group . A connected device . Perform EXECUTE # Let\u2019s perform an EXECUTE operation on the Factory Reset resource with ID 3/0/5 . Note From the Azure IoT integration standpoint, Factory Reset is interpreted as a Command . Read more about how LwM2M data model is mapped to Azure IoT Hub mechanisms in Concepts . In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Direct method . As Method name , type execute . In Payload , paste the following snippet and click Invoke method : { \"path\": \"3.0.5\" } Note The exact LwM2M path of the Factory reset resource depends on the LwM2M client used and may vary slightly, e.g. in the object instance number: 3/1/5 . For the purpose of this tutorial, the Anjay LwM2M Client is used. If needed, modify the snippet according to your case. See value changes in Azure IoT Hub # The result of the EXECUTE operation is displayed in the same Direct method tab. Scroll down to the Result field and check the HTTP code. The following result means that the device has executed the resource successfully: {\"status\":200,\"payload\":\"Executed `3.0.5` successfully\"}","title":"Perform LwM2M Execute"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Execute/#perform-lwm2m-execute","text":"This section describes how to perform a LwM2M EXECUTE operation in your Azure IoT Hub. An EXECUTE operation lets you perform operations on IoT devices such as a reboot or a firmware upgrade, only on individual resources. In this section, you learn how to: Perform a LwM2M EXECUTE operation on a resource","title":"Perform LwM2M Execute"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Execute/#prerequisites","text":"An active Azure IoT Hub with hub owner access permissions. A Coiote DM user account with permissions to use the integration extension. A device group created in Coiote DM. A configured extension between Coiote DM and Azure Iot Hub . A configured integration template in Coiote DM, assigned to the device group . A connected device .","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Execute/#perform-execute","text":"Let\u2019s perform an EXECUTE operation on the Factory Reset resource with ID 3/0/5 . Note From the Azure IoT integration standpoint, Factory Reset is interpreted as a Command . Read more about how LwM2M data model is mapped to Azure IoT Hub mechanisms in Concepts . In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Direct method . As Method name , type execute . In Payload , paste the following snippet and click Invoke method : { \"path\": \"3.0.5\" } Note The exact LwM2M path of the Factory reset resource depends on the LwM2M client used and may vary slightly, e.g. in the object instance number: 3/1/5 . For the purpose of this tutorial, the Anjay LwM2M Client is used. If needed, modify the snippet according to your case.","title":"Perform EXECUTE"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Execute/#see-value-changes-in-azure-iot-hub","text":"The result of the EXECUTE operation is displayed in the same Direct method tab. Scroll down to the Result field and check the HTTP code. The following result means that the device has executed the resource successfully: {\"status\":200,\"payload\":\"Executed `3.0.5` successfully\"}","title":"See value changes in Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Read_Write/","text":"Perform LwM2M Read and Write # This section describes how to perform a LwM2M WRITE and READ operations in your Azure IoT Hub and Coiote DM. A WRITE operation lets you change the current value on the given data model component: object, object instance, and resource. The READ enables you to see the updated value of an object, object instance, or resource. In this section, you learn how to: Perform WRITE on resources Check for the reported value changes in resources Perform READ on resources Prerequisites # An active Azure IoT Hub with hub owner access permissions. A Coiote DM user account with permissions to use the integration extension. A device group created in Coiote DM. A configured extension between Coiote DM and Azure Iot Hub . A configured integration template in Coiote DM, assigned to the device group . A connected device . Perform WRITE # Let\u2019s perform a WRITE operation on the Lifetime resource with ID 1/1/1 . From the Azure IoT integration standpoint, Lifetime it is interpreted as a Property . In Azure IoT Hub, value changes for both Telemetry and Property are stored in the Device twin . To perform a WRITE operation, do the following: In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Device twin . Find the desired property in the JSON snippet. This is where you define what needs to be observed. To the 1/1/1 (Lifetime) resource, add the following snippet under the \"desired\": { property and click Save : \"lwm2m\": { \"1\": { \"1\": { \"0\": {}, \"1\": { \"value\": 60 }, } }, }, Note The exact LwM2M path of the Lifetime resource depends on the LwM2M client used and may vary slightly, e.g. in the object instance number: 1/0/1 . For the purpose of this tutorial, the Anjay LwM2M Client is used. If needed, modify the snippet according to your case. After you click Save , the line with value: 60 will trigger the WRITE operation. See value changes # In Azure IoT Hub # The value change for the resource is displayed in the same Device Twin JSON snippet. Scroll down to the Reported property and find the value line for the 1/1/1 resource. \"reported\": { \"lwm2m\": { \"1\": { \"1\": { \"0\": {}, \"1\": { \"value\": 60 }, If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether the WRITE operation has been performed in Coiote DM as well. In Coiote DM # This step is optional. If you want to make sure the WRITE has been correctly performed in Coiote DM, do the following: In Coiote DM, go to your device and select the Data model tab. Expand the LwM2M Server object, find the Lifetime (1/1/1) resource in the list. If there is no change in data, use the Refresh icon in the top right corner of the screen. You have successfully performed a LwM2M WRITE on a resource. Perform READ # Let\u2019s perform a READ operation on the Temperature object's Sensor Value resource with ID 3303/0/5700 defined as a Property in the integration template in Coiote DM . To learn more about reading value changes for both Telemetry and Property , refer to LwM2M mappings for Azure IoT Hub . To perform a READ operation, do the following: In Coiote DM, go to your device and select the Data model tab. Expand the Temperature object, and find the Sensor Value (3303/0/5700) resource in the list. Click the Read resource icon located under the OPERATIONS column. The READ is scheduled - if there is any value change, it should be displayed in a few moments (depending on device settings, like the Lifetime resource). See value change in Azure IoT Hub # The value change for the resource is displayed in the Device Twin JSON snippet. Scroll down to the Reported property and find the value line for the 3303/0/5700 resource. \"reported\": { \"lwm2m\": { \"3303\": { \"0\": { \"5601\": {}, \"5602\": {}, \"5603\": {}, \"5604\": {}, \"5700\": { \"value\": 18 }, If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether the READ operation has been performed in Coiote DM as well. Next steps # Air quality monitoring - tutorial","title":"Perform LwM2M Read and Write"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Read_Write/#perform-lwm2m-read-and-write","text":"This section describes how to perform a LwM2M WRITE and READ operations in your Azure IoT Hub and Coiote DM. A WRITE operation lets you change the current value on the given data model component: object, object instance, and resource. The READ enables you to see the updated value of an object, object instance, or resource. In this section, you learn how to: Perform WRITE on resources Check for the reported value changes in resources Perform READ on resources","title":"Perform LwM2M Read and Write"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Read_Write/#prerequisites","text":"An active Azure IoT Hub with hub owner access permissions. A Coiote DM user account with permissions to use the integration extension. A device group created in Coiote DM. A configured extension between Coiote DM and Azure Iot Hub . A configured integration template in Coiote DM, assigned to the device group . A connected device .","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Read_Write/#perform-write","text":"Let\u2019s perform a WRITE operation on the Lifetime resource with ID 1/1/1 . From the Azure IoT integration standpoint, Lifetime it is interpreted as a Property . In Azure IoT Hub, value changes for both Telemetry and Property are stored in the Device twin . To perform a WRITE operation, do the following: In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Device twin . Find the desired property in the JSON snippet. This is where you define what needs to be observed. To the 1/1/1 (Lifetime) resource, add the following snippet under the \"desired\": { property and click Save : \"lwm2m\": { \"1\": { \"1\": { \"0\": {}, \"1\": { \"value\": 60 }, } }, }, Note The exact LwM2M path of the Lifetime resource depends on the LwM2M client used and may vary slightly, e.g. in the object instance number: 1/0/1 . For the purpose of this tutorial, the Anjay LwM2M Client is used. If needed, modify the snippet according to your case. After you click Save , the line with value: 60 will trigger the WRITE operation.","title":"Perform WRITE"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Read_Write/#see-value-changes","text":"","title":"See value changes"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Read_Write/#in-azure-iot-hub","text":"The value change for the resource is displayed in the same Device Twin JSON snippet. Scroll down to the Reported property and find the value line for the 1/1/1 resource. \"reported\": { \"lwm2m\": { \"1\": { \"1\": { \"0\": {}, \"1\": { \"value\": 60 }, If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether the WRITE operation has been performed in Coiote DM as well.","title":"In Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Read_Write/#in-coiote-dm","text":"This step is optional. If you want to make sure the WRITE has been correctly performed in Coiote DM, do the following: In Coiote DM, go to your device and select the Data model tab. Expand the LwM2M Server object, find the Lifetime (1/1/1) resource in the list. If there is no change in data, use the Refresh icon in the top right corner of the screen. You have successfully performed a LwM2M WRITE on a resource.","title":"In Coiote DM"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Read_Write/#perform-read","text":"Let\u2019s perform a READ operation on the Temperature object's Sensor Value resource with ID 3303/0/5700 defined as a Property in the integration template in Coiote DM . To learn more about reading value changes for both Telemetry and Property , refer to LwM2M mappings for Azure IoT Hub . To perform a READ operation, do the following: In Coiote DM, go to your device and select the Data model tab. Expand the Temperature object, and find the Sensor Value (3303/0/5700) resource in the list. Click the Read resource icon located under the OPERATIONS column. The READ is scheduled - if there is any value change, it should be displayed in a few moments (depending on device settings, like the Lifetime resource).","title":"Perform READ"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Read_Write/#see-value-change-in-azure-iot-hub","text":"The value change for the resource is displayed in the Device Twin JSON snippet. Scroll down to the Reported property and find the value line for the 3303/0/5700 resource. \"reported\": { \"lwm2m\": { \"3303\": { \"0\": { \"5601\": {}, \"5602\": {}, \"5603\": {}, \"5604\": {}, \"5700\": { \"value\": 18 }, If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether the READ operation has been performed in Coiote DM as well.","title":"See value change in Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Perform_Read_Write/#next-steps","text":"Air quality monitoring - tutorial","title":"Next steps"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Set_an_Observation/","text":"Set an Observation # This section describes how to set an Observation in your Azure IoT Hub. Setting an Observation lets your devices know what value changes and for what particular resources they need to notify you about. An Observation can be set for any or all the components of the data model : objects, objects instances, and resources. Whenever there is a change in values, a device will send a Notify message to Coiote DM, which in turn will transfer it to Azure IoT Hub. In this section, you learn how to: Set an Observation on objects and resources Define Observation attributes See value changes for the observed objects and resources Prerequisites # An active Azure IoT Hub with hub owner access permissions. A Coiote DM user account with permissions to use the integration extension. A device group created in Coiote DM. A configured extension between Coiote DM and Azure Iot Hub . A configured integration template in Coiote DM, assigned to the device group . A connected device . Set an Observation and define its attributes # Let\u2019s set two Observations: one on the whole object with ID 1/1 (1 LwM2M Server, 1 Lifetime) and on the resource with ID 3/0/13 (3 Device, 13 Current time). Both of them are Properties. In Azure IoT Hub, value changes for both Telemetry and Property are stored in Device twin , because Observation is a Property in itself and it does not keep track of historical changes in values. To set an Observation, do the following: In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Device twin . Find the desired property in the JSON snippet. This is where you define what needs to be observed. To set an Observation on object 1/1 (Lifetime) and resource 3/0/13 (Current time) , add the following fragment under the \"desired\": { property: \"lwm2m\": { \"1\": { \"1\": { \"observed\": true, \"attributes\": { \"pmin\": 60 } } }, \"3\": { \"0\": { \"13\": { \"observed\": true, \"attributes\": { \"pmin\": 1 } } } } }, The line with \u201cobserved\u201d: true sets an Observation. The line with \u201cattributes\u201d specifies the conditions under which notifications will be sent: \u201cpmin\u201d: 1 means that notifications will be sent every second. Info pmin - the minimum time in seconds between two notifications. pmax - the maximum time in seconds between two notifications. The notification is sent even if the value didn't change. Read more about other attributes in our Brief description of OMA LwM2M . Click Save . See value changes # In Azure IoT Hub # The value changes for the observed object and resource are displayed in the same JSON snippet where you set an Observation. Scroll down to the Reported property and find the value line. \"13\": { \"value\": 1634653218000, \"attributes\": { \"pmin\": \"1\" }, \"observed\": true } Because we have specified in the Desired properties that the maximum time between two notifications for the Current time (3/0/13) resource is 1 second ( pmax: 1 ), the number next to value will be changing every 1 second. E.g., 163465321 8 000 will become 163465321 9 000. If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether observation has been set in Coiote DM as well. In Coiote DM # This step is optional. If you want to make sure the Observation has been correctly set in Coiote DM, do the following: In Coiote, go to Device inventory --> Objects . For the Observation set on the whole object (1/1) , click the vertical Ellipse button next the search field and then click Refresh . If the Observation has been set correctly, the checkboxes will be filled in green. For the Observation set on the specific resource (3/0/13) , find this resource in the list and click the Refresh button to the left from the Value tracking. You will see that checkboxes next to Value tracking and Attributes are now filled in green. Click Value tracking . You will see pmin set to 1, which is the same as you defined in the JSON in Azure IoT Hub. You have successfully set an Observation on LwM2M object and resource. To add another Observation, add the lines in the same JSON snippet, as described in Step 4 . Delete an Observation # To stop observing an object or resource, do the following: In Azure IoT Hub, click on the device and then go to Device twin . In the JSON snippet, change \"observed\" from true to false . In Coiote, you can now go to Device inventory --> Objects and see how Value tracking and Attributes boxes are now unchecked. Next steps # Air quality monitoring - tutorial","title":"Set an Observation"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Set_an_Observation/#set-an-observation","text":"This section describes how to set an Observation in your Azure IoT Hub. Setting an Observation lets your devices know what value changes and for what particular resources they need to notify you about. An Observation can be set for any or all the components of the data model : objects, objects instances, and resources. Whenever there is a change in values, a device will send a Notify message to Coiote DM, which in turn will transfer it to Azure IoT Hub. In this section, you learn how to: Set an Observation on objects and resources Define Observation attributes See value changes for the observed objects and resources","title":"Set an Observation"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Set_an_Observation/#prerequisites","text":"An active Azure IoT Hub with hub owner access permissions. A Coiote DM user account with permissions to use the integration extension. A device group created in Coiote DM. A configured extension between Coiote DM and Azure Iot Hub . A configured integration template in Coiote DM, assigned to the device group . A connected device .","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Set_an_Observation/#set-an-observation-and-define-its-attributes","text":"Let\u2019s set two Observations: one on the whole object with ID 1/1 (1 LwM2M Server, 1 Lifetime) and on the resource with ID 3/0/13 (3 Device, 13 Current time). Both of them are Properties. In Azure IoT Hub, value changes for both Telemetry and Property are stored in Device twin , because Observation is a Property in itself and it does not keep track of historical changes in values. To set an Observation, do the following: In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Device twin . Find the desired property in the JSON snippet. This is where you define what needs to be observed. To set an Observation on object 1/1 (Lifetime) and resource 3/0/13 (Current time) , add the following fragment under the \"desired\": { property: \"lwm2m\": { \"1\": { \"1\": { \"observed\": true, \"attributes\": { \"pmin\": 60 } } }, \"3\": { \"0\": { \"13\": { \"observed\": true, \"attributes\": { \"pmin\": 1 } } } } }, The line with \u201cobserved\u201d: true sets an Observation. The line with \u201cattributes\u201d specifies the conditions under which notifications will be sent: \u201cpmin\u201d: 1 means that notifications will be sent every second. Info pmin - the minimum time in seconds between two notifications. pmax - the maximum time in seconds between two notifications. The notification is sent even if the value didn't change. Read more about other attributes in our Brief description of OMA LwM2M . Click Save .","title":"Set an Observation and define its attributes"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Set_an_Observation/#see-value-changes","text":"","title":"See value changes"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Set_an_Observation/#in-azure-iot-hub","text":"The value changes for the observed object and resource are displayed in the same JSON snippet where you set an Observation. Scroll down to the Reported property and find the value line. \"13\": { \"value\": 1634653218000, \"attributes\": { \"pmin\": \"1\" }, \"observed\": true } Because we have specified in the Desired properties that the maximum time between two notifications for the Current time (3/0/13) resource is 1 second ( pmax: 1 ), the number next to value will be changing every 1 second. E.g., 163465321 8 000 will become 163465321 9 000. If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether observation has been set in Coiote DM as well.","title":"In Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Set_an_Observation/#in-coiote-dm","text":"This step is optional. If you want to make sure the Observation has been correctly set in Coiote DM, do the following: In Coiote, go to Device inventory --> Objects . For the Observation set on the whole object (1/1) , click the vertical Ellipse button next the search field and then click Refresh . If the Observation has been set correctly, the checkboxes will be filled in green. For the Observation set on the specific resource (3/0/13) , find this resource in the list and click the Refresh button to the left from the Value tracking. You will see that checkboxes next to Value tracking and Attributes are now filled in green. Click Value tracking . You will see pmin set to 1, which is the same as you defined in the JSON in Azure IoT Hub. You have successfully set an Observation on LwM2M object and resource. To add another Observation, add the lines in the same JSON snippet, as described in Step 4 .","title":"In Coiote DM"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Set_an_Observation/#delete-an-observation","text":"To stop observing an object or resource, do the following: In Azure IoT Hub, click on the device and then go to Device twin . In the JSON snippet, change \"observed\" from true to false . In Coiote, you can now go to Device inventory --> Objects and see how Value tracking and Attributes boxes are now unchecked.","title":"Delete an Observation"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Set_an_Observation/#next-steps","text":"Air quality monitoring - tutorial","title":"Next steps"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Overview/","text":"Overview # How synchronization works # Coiote DM provides zero-touch provisioning for devices synchronized with Azure IoT Hub. This means any devices imported using a CSV file are automatically created within Coiote DM and Azure IoT Hub and from this time on are synchronized periodically. Therefore, after any successful synchronization, you can be sure that any devices that have been imported via Coiote DM will be presented in their actual state within Azure IoT Hub.","title":"Overview"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Overview/#overview","text":"","title":"Overview"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Overview/#how-synchronization-works","text":"Coiote DM provides zero-touch provisioning for devices synchronized with Azure IoT Hub. This means any devices imported using a CSV file are automatically created within Coiote DM and Azure IoT Hub and from this time on are synchronized periodically. Therefore, after any successful synchronization, you can be sure that any devices that have been imported via Coiote DM will be presented in their actual state within Azure IoT Hub.","title":"How synchronization works"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Hub/","text":"Synchronize devices with Azure IoT Hub # Importing devices to Coiote DM and synchronizing them with Azure IoT Hub is a quick way to start using your Coiote DM - Azure IoT Hub integration. The import operation will do two basic operations automatically: Create device entities in Coiote DM with the credentials that you specified, create the devices' \"counterparts\" within Azure IoT Hub and synchronize them with Coiote DM. Prerequisites # A connected Azure IoT Hub integration in the Hyperscaler Integration Center. Import devices from CSV using a default integration template # In the import process, you will need a list of devices that you want to import along with an integration template to be used by the Azure IoT Hub. To learn more about Azure integration templates, see the Configure integration templates section. In Coiote DM, go to Administration -> Hyperscaler Integration Center . Make sure you have an integration connected in the Integration tab. Go to the Device list tab and click Import devices . In the Import devices wizard: From the Select template field, select one of two default integration templates: Default minimal LwM2M schema - a pre-defined template implementing a basic device data model. Default rich LwM2M schema - a pre-defined template implementing an extended device data model. Note Integration templates are crucial in the device import process. Optionally, you can create your custom device template and use it in importing. Check the instructions in the Configure integration templates section. In the Import devices from a CSV file section: If you already have a CSV file with devices for import, click Browse and select the file. If you don't have a CSV with devices for import yet, click the device template link to download an empty template that you can fill in with your data: DeviceId - provide your device ID. For LwM2M-enabled devices, device ID usually equals the endpoint name. IMSI - provide a random but unique number for each entry (or provide IMSI number if your device has one). PSK_Identity_Key - provide a unique plain-text PSK identity key used for secure communication between the device and Coiote DM. PSK_Key - provide a unique HEX-encoded PSK key used for secure communication between the device and Coiote DM. Save the template and upload it using the Browse button and dialog window. Click Sync with Azure . After a moment, the import operation should finish successfully. Now you can connect your physical devices to Coiote DM using their credentials and the dedicated URL displayed after the successful device import. What the import operation does # Once the devices from the CSV template are imported into Coiote DM, the following actions are performed: In Coiote DM, device entities are created based on the credentials provided in the template. All such entities are visible in the Device list tab. In Coiote DM, a dedicated integration group is automatically created (with the name built up by the hyperscalercenter prefix and the template ID, e.g. 618238c8bcafcb43b2911262 ). In your Azure IoT hub, devices are created and ready for operation. Check device error logs # Logs may come helpful for diagnosing and troubleshooting issues with the communication between the three actors in the integration: the device, Coiote DM, and Azure IoT Hub. To see logs for your integrated devices: Go to the single device view and from the left menu, select the Logs tile. In the Logs panel, expand the view by clicking on More and configure the following: Store from level - select Use custom and set log level to DEBUG for 1 hour. Tags - select HYPERSCALERS The communication logs will be displayed, allowing you to check, diagnose, or debug any issues.","title":"Synchronize devices with Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Hub/#synchronize-devices-with-azure-iot-hub","text":"Importing devices to Coiote DM and synchronizing them with Azure IoT Hub is a quick way to start using your Coiote DM - Azure IoT Hub integration. The import operation will do two basic operations automatically: Create device entities in Coiote DM with the credentials that you specified, create the devices' \"counterparts\" within Azure IoT Hub and synchronize them with Coiote DM.","title":"Synchronize devices with Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Hub/#prerequisites","text":"A connected Azure IoT Hub integration in the Hyperscaler Integration Center.","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Hub/#import-devices-from-csv-using-a-default-integration-template","text":"In the import process, you will need a list of devices that you want to import along with an integration template to be used by the Azure IoT Hub. To learn more about Azure integration templates, see the Configure integration templates section. In Coiote DM, go to Administration -> Hyperscaler Integration Center . Make sure you have an integration connected in the Integration tab. Go to the Device list tab and click Import devices . In the Import devices wizard: From the Select template field, select one of two default integration templates: Default minimal LwM2M schema - a pre-defined template implementing a basic device data model. Default rich LwM2M schema - a pre-defined template implementing an extended device data model. Note Integration templates are crucial in the device import process. Optionally, you can create your custom device template and use it in importing. Check the instructions in the Configure integration templates section. In the Import devices from a CSV file section: If you already have a CSV file with devices for import, click Browse and select the file. If you don't have a CSV with devices for import yet, click the device template link to download an empty template that you can fill in with your data: DeviceId - provide your device ID. For LwM2M-enabled devices, device ID usually equals the endpoint name. IMSI - provide a random but unique number for each entry (or provide IMSI number if your device has one). PSK_Identity_Key - provide a unique plain-text PSK identity key used for secure communication between the device and Coiote DM. PSK_Key - provide a unique HEX-encoded PSK key used for secure communication between the device and Coiote DM. Save the template and upload it using the Browse button and dialog window. Click Sync with Azure . After a moment, the import operation should finish successfully. Now you can connect your physical devices to Coiote DM using their credentials and the dedicated URL displayed after the successful device import.","title":"Import devices from CSV using a default integration template"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Hub/#what-the-import-operation-does","text":"Once the devices from the CSV template are imported into Coiote DM, the following actions are performed: In Coiote DM, device entities are created based on the credentials provided in the template. All such entities are visible in the Device list tab. In Coiote DM, a dedicated integration group is automatically created (with the name built up by the hyperscalercenter prefix and the template ID, e.g. 618238c8bcafcb43b2911262 ). In your Azure IoT hub, devices are created and ready for operation.","title":"What the import operation does"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Synchronize_devices_with_Azure_IoT_Hub/#check-device-error-logs","text":"Logs may come helpful for diagnosing and troubleshooting issues with the communication between the three actors in the integration: the device, Coiote DM, and Azure IoT Hub. To see logs for your integrated devices: Go to the single device view and from the left menu, select the Logs tile. In the Logs panel, expand the view by clicking on More and configure the following: Store from level - select Use custom and set log level to DEBUG for 1 hour. Tags - select HYPERSCALERS The communication logs will be displayed, allowing you to check, diagnose, or debug any issues.","title":"Check device error logs"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Upgrading_firmware/","text":"Upgrade device firmware # If you would like to upgrade the firmware of devices using the Azure IoT Hub, follow the instruction below. Prerequisites # At least one synchronized Coiote DM - Azure IoT Hub device. A firmware file hosted on an HTTP server that is reachable by the Coiote DM server. Note In this stage of integration, no authentication method is supported for this endpoint - it is required that the firmware is publicly available (or hosted in a private network but with access granted for the Coiote DM server). Scheduling a firmware upgrade # Introduction # The process of upgrading device firmware for Azure IoT Hub devices synchronized with Coiote DM is based on two main elements: the Azure Direct Method mechanism and the Coiote DM Firmware Upgrade task. In the process, the Azure scheduleFirmwareUpdate direct method is invoked, enabling the Coiote DM to download the specified firmware file and add it to its resources. Then, an XML task is scheduled in Coiote DM and the upgrade is performed on the device. Info For firmware file recognition in Coiote, global identifiers are used. This means that it is recommended to name your firmware files using the format: yourdomainName + randomized value. If the same firmware file name is used again, then Coiote DM will be able to utilize the once downloaded resource without the need to download it again. Step 1: Invoking the Azure scheduleFirmwareUpdate direct method # To initiate the firmware upgrade procedure for your device: Go to your Azure hub account and under Explorers , select IoT devices . From the list, choose the device for which you want to upgrade the firmware. In the device view, select the Direct Method tab. Provide data for the following fields: Method Name - paste the scheduleFirmwareUpdate direct method name here. Payload - use the following payload with firmware upgrade parameters (remember to replace the example values where needed): { \"name\": \"anjay-firmware\", \"firmwareUrl\": \"https://example.repository.com/artifactory/gitlfs/demo.fw-pkg\", // optional - default=\"1200s\", any valid duration in format \"<length><unit>\" \"timeout\": \"1200s\", // optional - default=\"COAP\" \"protocolType\": \"COAP\", // optional - default=null <-> keep firmware file forever, any valid duration in format \"<length><unit>\" or null \"retentionPeriod\": \"300s\", // optional - default=\"\" \"description\": \"This is anjay demo firmware\", // optional - default=false \"useQuota\": false, // optional - default=false \"useCachedData\": false, // optional - default=false \"resumeAfterDownlinkFailure\": false, // optional - default=\"pull\", possible values = [\"pull\", \"push\"] \"imageDeliveryMethod\": \"pull\", // optional - default=\"WithoutObservations\", possible values = [\"ObservationTrigger\", \"WithoutObservations\", \"ObservationBased\", \"SendBased\"] \"upgradeStrategy\": \"WithoutObservations\", // optional - default=\"always\", possible values = [\"always\", \"weekends\", \"nights-home\", \"nights-enterprise-weekends\", \"nights-enterprise\", user-defined schedules] \"schedule\": \"always\" } Connection timeout - specify a timeout for the Azure - Coiote DM connection (the recommended value is not less than 5 seconds). Method timeout - specify a timeout for direct method result notification. Once you have provided the required data, click Invoke method . After a short moment, you should be able to see the direct method result in the Result field. The 200 as the \"status\" parameter value means that the firmware upgrade task was completed successfully. Importantly, the result \"payload\" value will be needed for other FOTA actions like status check or cancellation, so be sure to copy it to your clipboard if needed. Tip Out of all the parameters provided in Firmware upgrade direct method payload, only two are mandatory: name - the unique file name used for firmware identification. firmwareUrl - the URL used by Coiote DM to download the firmware file and include it as a resource. Therefore it is correct to include only those two in the payload, as in here: { \"name\": \"anjay-firmware\", \"firmwareUrl\": \"https://example.repository.com/artifactory/gitlfs/demo.fw-pkg\", } Step 2: Checking the firmware upgrade result # To check the status of a scheduled firmware upgrade, follow these steps: In the Direct Method tab of your device, provide data for the following fields: Method Name - paste the checkFirmwareUpdateStatus direct method name here. Payload - use the payload displayed in the Firmware upgrade result field (remember to replace the placeholder value with your copied value): { \"fotaId\": \"fotaIdReturnedByScheduleOperation\" } Click Invoke method . Check the direct method status in the Result field: Step 3: Checking Coiote DM FOTA task execution # Once you have executed the Azure-side steps of the procedure, you can check its status from the side of Coiote DM. Go to your Coiote DM account and in the Device Inventory , select your device. In the Device Management Center, enter the LwM2M firmware tab. Check the status of the FOTA task execution for your device: In the Current firmware section, check if the device firmware is updated to the newest version. In the Installation history section, check if the lwm2mFirmwareUpdate task invoked earlier by the Azure scheduleFirmwareUpdate direct method has been completed with success. Cancelling the firmware upgrade procedure # To cancel the firmware upgrade procedure, follow these steps: In the Direct Method tab of your device, provide data for the following fields: Method Name - paste the cancelFirmwareUpdate direct method name here. Payload - use the payload displayed in the Firmware upgrade result field (remember to replace the placeholder value with your copied value): { \"fotaId\": \"fotaIdReturnedByScheduleOperation\" } Click Invoke method . Check the direct method status in the Result field: See also # See the relevant section of LwM2M mappings to learn the details of how Azure IoT Hub Direct Methods are mapped in Coiote DM.","title":"Upgrade device firmware"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Upgrading_firmware/#upgrade-device-firmware","text":"If you would like to upgrade the firmware of devices using the Azure IoT Hub, follow the instruction below.","title":"Upgrade device firmware"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Upgrading_firmware/#prerequisites","text":"At least one synchronized Coiote DM - Azure IoT Hub device. A firmware file hosted on an HTTP server that is reachable by the Coiote DM server. Note In this stage of integration, no authentication method is supported for this endpoint - it is required that the firmware is publicly available (or hosted in a private network but with access granted for the Coiote DM server).","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Upgrading_firmware/#scheduling-a-firmware-upgrade","text":"","title":"Scheduling a firmware upgrade"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Upgrading_firmware/#introduction","text":"The process of upgrading device firmware for Azure IoT Hub devices synchronized with Coiote DM is based on two main elements: the Azure Direct Method mechanism and the Coiote DM Firmware Upgrade task. In the process, the Azure scheduleFirmwareUpdate direct method is invoked, enabling the Coiote DM to download the specified firmware file and add it to its resources. Then, an XML task is scheduled in Coiote DM and the upgrade is performed on the device. Info For firmware file recognition in Coiote, global identifiers are used. This means that it is recommended to name your firmware files using the format: yourdomainName + randomized value. If the same firmware file name is used again, then Coiote DM will be able to utilize the once downloaded resource without the need to download it again.","title":"Introduction"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Upgrading_firmware/#step-1-invoking-the-azure-schedulefirmwareupdate-direct-method","text":"To initiate the firmware upgrade procedure for your device: Go to your Azure hub account and under Explorers , select IoT devices . From the list, choose the device for which you want to upgrade the firmware. In the device view, select the Direct Method tab. Provide data for the following fields: Method Name - paste the scheduleFirmwareUpdate direct method name here. Payload - use the following payload with firmware upgrade parameters (remember to replace the example values where needed): { \"name\": \"anjay-firmware\", \"firmwareUrl\": \"https://example.repository.com/artifactory/gitlfs/demo.fw-pkg\", // optional - default=\"1200s\", any valid duration in format \"<length><unit>\" \"timeout\": \"1200s\", // optional - default=\"COAP\" \"protocolType\": \"COAP\", // optional - default=null <-> keep firmware file forever, any valid duration in format \"<length><unit>\" or null \"retentionPeriod\": \"300s\", // optional - default=\"\" \"description\": \"This is anjay demo firmware\", // optional - default=false \"useQuota\": false, // optional - default=false \"useCachedData\": false, // optional - default=false \"resumeAfterDownlinkFailure\": false, // optional - default=\"pull\", possible values = [\"pull\", \"push\"] \"imageDeliveryMethod\": \"pull\", // optional - default=\"WithoutObservations\", possible values = [\"ObservationTrigger\", \"WithoutObservations\", \"ObservationBased\", \"SendBased\"] \"upgradeStrategy\": \"WithoutObservations\", // optional - default=\"always\", possible values = [\"always\", \"weekends\", \"nights-home\", \"nights-enterprise-weekends\", \"nights-enterprise\", user-defined schedules] \"schedule\": \"always\" } Connection timeout - specify a timeout for the Azure - Coiote DM connection (the recommended value is not less than 5 seconds). Method timeout - specify a timeout for direct method result notification. Once you have provided the required data, click Invoke method . After a short moment, you should be able to see the direct method result in the Result field. The 200 as the \"status\" parameter value means that the firmware upgrade task was completed successfully. Importantly, the result \"payload\" value will be needed for other FOTA actions like status check or cancellation, so be sure to copy it to your clipboard if needed. Tip Out of all the parameters provided in Firmware upgrade direct method payload, only two are mandatory: name - the unique file name used for firmware identification. firmwareUrl - the URL used by Coiote DM to download the firmware file and include it as a resource. Therefore it is correct to include only those two in the payload, as in here: { \"name\": \"anjay-firmware\", \"firmwareUrl\": \"https://example.repository.com/artifactory/gitlfs/demo.fw-pkg\", }","title":"Step 1: Invoking the Azure scheduleFirmwareUpdate direct method"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Upgrading_firmware/#step-2-checking-the-firmware-upgrade-result","text":"To check the status of a scheduled firmware upgrade, follow these steps: In the Direct Method tab of your device, provide data for the following fields: Method Name - paste the checkFirmwareUpdateStatus direct method name here. Payload - use the payload displayed in the Firmware upgrade result field (remember to replace the placeholder value with your copied value): { \"fotaId\": \"fotaIdReturnedByScheduleOperation\" } Click Invoke method . Check the direct method status in the Result field:","title":"Step 2: Checking the firmware upgrade result"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Upgrading_firmware/#step-3-checking-coiote-dm-fota-task-execution","text":"Once you have executed the Azure-side steps of the procedure, you can check its status from the side of Coiote DM. Go to your Coiote DM account and in the Device Inventory , select your device. In the Device Management Center, enter the LwM2M firmware tab. Check the status of the FOTA task execution for your device: In the Current firmware section, check if the device firmware is updated to the newest version. In the Installation history section, check if the lwm2mFirmwareUpdate task invoked earlier by the Azure scheduleFirmwareUpdate direct method has been completed with success.","title":"Step 3: Checking Coiote DM FOTA task execution"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Upgrading_firmware/#cancelling-the-firmware-upgrade-procedure","text":"To cancel the firmware upgrade procedure, follow these steps: In the Direct Method tab of your device, provide data for the following fields: Method Name - paste the cancelFirmwareUpdate direct method name here. Payload - use the payload displayed in the Firmware upgrade result field (remember to replace the placeholder value with your copied value): { \"fotaId\": \"fotaIdReturnedByScheduleOperation\" } Click Invoke method . Check the direct method status in the Result field:","title":"Cancelling the firmware upgrade procedure"},{"location":"Azure_IoT_Integration_Guide/Azure_IoT_Hub_integration/Device_operations/Upgrading_firmware/#see-also","text":"See the relevant section of LwM2M mappings to learn the details of how Azure IoT Hub Direct Methods are mapped in Coiote DM.","title":"See also"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Central/","text":"LwM2M mappings - Azure IoT Central # In this section you'll get to know how the mappings are arranged between the LwM2M protocol as used in Coiote DM and the data retrieval and processing mechanisms of Azure IoT Central. These processing mechanisms of Azure IoT Central have the same names as data formats in Coiote DM: Properties, Command, and Telemetry. Properties describe the actual value, Command executes commands, and Telemetry observes changes in values over time. Introduction # The LwM2M protocol data model is organized as a three-level tree that has the following structure: object (e.g. a 'temperature sensor') object instance (e.g. 'temperature sensor #1', 'temperature sensor #2' etc.) resource (e.g. 'current temperature value') In terms of operations that can be performed on an LwM2M Client, an LwM2M Server can READ all of the data model entities, and, depending on their characteristics, may also WRITE to some of them, and execute some of them (COMMAND). Additionally, an LwM2M Server can also OBSERVE selected resources. Info If you would like to dive deeper into the details of the Lightweight M2M protocol, please refer to our brief introduction to LwM2M . This division into readable, writable, executable and observable data model entities is the basis for the mapping of LwM2M resources (as interpreted by Coiote DM) into the Azure IoT Central data processing mechanisms. LwM2M readable and writable resources # Within the Coiote DM - Azure IoT Central integration , readable and writable resources are interpreted as Properties. The data structure is represented in one line where objects, object instances, and resources are separated by n . For example: n1n0n3 , where 1 is object, 0 is object instance, and 3 is resource. In Azure IoT Central, Properties as well as other device capabilities (Telemetry and Command, read more on them below) are defined in a model which is part of the device template . The device template defines the characteristics of the device that is connected to your IoT Central application. READ - Communication flow # Data model resources that are read-only, such as Manufacturer (with ID 3/0/0 ) will be mapped to Azure IoT Central as a reported property. WRITE - Communication flow # On the other hand, a writable resource, such as Lifetime (with ID 1/0/1 ), apart from being represented as a reported property, can be additionally mapped as a desired property. This enables you to synchronize the device data model and configuration between Azure and Coiote DM. In Azure IoT Central, changing the value of a writable resource is done by running a job . LwM2M executable resources # As a rule, LwM2M resources that can be executable translate into Commands in Azure IoT Central. This means that by invoking Command from Azure, you can trigger a COMMAND operation on a chosen resource available for your device and the request will be transferred immediately by the LwM2M Server to the device. Note To learn about Commands, read the respective subsection in the Message payloads section. To do so, select a device from the Devices page in Azure IoT Central and click the Commands tab. Click Run to run a necessary command. COMMAND - Communication flow # Invoking Command from Azure IoT Central and handling it by Coiote DM in the form of a COMMAND operation passed to the device has the following flow: LwM2M observable resources # In Coiote DM, some of the resources within the device data model can be observed for changes in value. These are generally resources related to telemetry data or other measurements. Their value changes can be monitored by Coiote DM and reported to Azure IoT Central with help of Telemetry device capability. Note To learn more about Telemetry, go to the respective subsection of the Azure IoT Central documentation. Observe - Communication flow # Setting an Observe operation on a resource in Coiote DM, for instance a temperature reading, will result in a Notify message sent by the device upon value change. Then Coiote DM transfers this message to Azure IoT Central using Telemetry. To set an Observe operation in Azure IoT Central, you need to add a Job in the IoT Central application. As you can see in the Devices > Raw data tab, an Observation is represented in the following format: \u201cn1n1n1_attributes\u201d: \u201c(\\\u201dobserved\\\u201d:true,\\\u201dpmin\\\u201d:20}\u201d Next steps Configure integration templates","title":"LwM2M mappings - Azure IoT Central"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Central/#lwm2m-mappings-azure-iot-central","text":"In this section you'll get to know how the mappings are arranged between the LwM2M protocol as used in Coiote DM and the data retrieval and processing mechanisms of Azure IoT Central. These processing mechanisms of Azure IoT Central have the same names as data formats in Coiote DM: Properties, Command, and Telemetry. Properties describe the actual value, Command executes commands, and Telemetry observes changes in values over time.","title":"LwM2M mappings - Azure IoT Central"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Central/#introduction","text":"The LwM2M protocol data model is organized as a three-level tree that has the following structure: object (e.g. a 'temperature sensor') object instance (e.g. 'temperature sensor #1', 'temperature sensor #2' etc.) resource (e.g. 'current temperature value') In terms of operations that can be performed on an LwM2M Client, an LwM2M Server can READ all of the data model entities, and, depending on their characteristics, may also WRITE to some of them, and execute some of them (COMMAND). Additionally, an LwM2M Server can also OBSERVE selected resources. Info If you would like to dive deeper into the details of the Lightweight M2M protocol, please refer to our brief introduction to LwM2M . This division into readable, writable, executable and observable data model entities is the basis for the mapping of LwM2M resources (as interpreted by Coiote DM) into the Azure IoT Central data processing mechanisms.","title":"Introduction"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Central/#lwm2m-readable-and-writable-resources","text":"Within the Coiote DM - Azure IoT Central integration , readable and writable resources are interpreted as Properties. The data structure is represented in one line where objects, object instances, and resources are separated by n . For example: n1n0n3 , where 1 is object, 0 is object instance, and 3 is resource. In Azure IoT Central, Properties as well as other device capabilities (Telemetry and Command, read more on them below) are defined in a model which is part of the device template . The device template defines the characteristics of the device that is connected to your IoT Central application.","title":"LwM2M readable and writable resources"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Central/#read-communication-flow","text":"Data model resources that are read-only, such as Manufacturer (with ID 3/0/0 ) will be mapped to Azure IoT Central as a reported property.","title":"READ - Communication flow"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Central/#write-communication-flow","text":"On the other hand, a writable resource, such as Lifetime (with ID 1/0/1 ), apart from being represented as a reported property, can be additionally mapped as a desired property. This enables you to synchronize the device data model and configuration between Azure and Coiote DM. In Azure IoT Central, changing the value of a writable resource is done by running a job .","title":"WRITE - Communication flow"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Central/#lwm2m-executable-resources","text":"As a rule, LwM2M resources that can be executable translate into Commands in Azure IoT Central. This means that by invoking Command from Azure, you can trigger a COMMAND operation on a chosen resource available for your device and the request will be transferred immediately by the LwM2M Server to the device. Note To learn about Commands, read the respective subsection in the Message payloads section. To do so, select a device from the Devices page in Azure IoT Central and click the Commands tab. Click Run to run a necessary command.","title":"LwM2M executable resources"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Central/#command-communication-flow","text":"Invoking Command from Azure IoT Central and handling it by Coiote DM in the form of a COMMAND operation passed to the device has the following flow:","title":"COMMAND - Communication flow"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Central/#lwm2m-observable-resources","text":"In Coiote DM, some of the resources within the device data model can be observed for changes in value. These are generally resources related to telemetry data or other measurements. Their value changes can be monitored by Coiote DM and reported to Azure IoT Central with help of Telemetry device capability. Note To learn more about Telemetry, go to the respective subsection of the Azure IoT Central documentation.","title":"LwM2M observable resources"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Central/#observe-communication-flow","text":"Setting an Observe operation on a resource in Coiote DM, for instance a temperature reading, will result in a Notify message sent by the device upon value change. Then Coiote DM transfers this message to Azure IoT Central using Telemetry. To set an Observe operation in Azure IoT Central, you need to add a Job in the IoT Central application. As you can see in the Devices > Raw data tab, an Observation is represented in the following format: \u201cn1n1n1_attributes\u201d: \u201c(\\\u201dobserved\\\u201d:true,\\\u201dpmin\\\u201d:20}\u201d Next steps Configure integration templates","title":"Observe - Communication flow"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Hub/","text":"LwM2M mappings - Azure IoT Hub # In this section you'll get to know how the mappings are arranged between the LwM2M protocol as used in Coiote DM and the data retrieval and processing mechanisms of the Azure IoT Hub. Introduction # The LwM2M protocol data model is organized as a three-level tree that has the following structure: object (e.g. a 'temperature sensor') object instance (e.g. 'temperature sensor #1', 'temperature sensor #2' etc.) resource (e.g. 'current temperature value') In terms of operations that can be performed on an LwM2M Client, an LwM2M Server can READ all of the data model entities, and, depending on their characteristics, may also WRITE to some of them, and EXECUTE some of them. Additionally, an LwM2M Server can also OBSERVE selected resources. Info If you would like to dive deeper into the details of the Lightweight M2M protocol, please refer to our brief introduction to LwM2M . This division into readable, writable, executable and observable data model entities is the basis for the mapping of LwM2M resources (as interpreted by Coiote DM) into Azure IoT Hub data processing mechanisms. LwM2M readable and writable resources # Within the Coiote DM - Azure IoT Hub integration, readable and writable resources are usually interpreted as part of Azure Device twin data structure. Note To learn more about Device twins, go to the Understand and use Device twins section of the Azure IoT Hub documentation. For instance, the sample JSON snippet below is a tree with nested resources to represent a fragment of the LwM2M data model with path /3/1/1 : { \"deviceId\": \"airquality-0\", ... \"properties\": { \"reported\": { \"lwm2m\": { \"1\": { \"0\": { \"0\": {}, \"1\": { \"value\": 90 }, \"4\": {}, \"6\": {}, \"7\": {}, \"8\": {} } }, \"3\": { \"1\": { \"1\": { \"value\": \"airquality-0-Valparaiso\" } } }, ... READ - Communication flow # Data model resources that are read-only, such as Manufacturer (with ID 3/0/0 ) will be mapped into the Device twin as a reported property in Azure IoT Hub. WRITE - Communication flow # On the other hand, a writable resource, such as Lifetime (with ID 1/0/1 ), apart from being represented as a reported property, can be additionally mapped as a desired property. This enables you to synchronize the device data model and configuration between Azure and Coiote DM. In Azure IoT Hub , changing the value of a writable resource involves creating a properly formatted JSON snippet in the desired property field within the Device twin that introduces a value change: ... \"properties\": { \"desired\": { \"lwm2m\": { \"1\": { \"0\": { \"0\": {}, \"1\": { \"value\": 30 } } } }, ... After JSON is saved, Azure notifies Coiote DM of the desired change which is then transferred to the device in form of a WRITE command. Once the value is changed on the device, Coiote DM reports back to Azure that the value of the corresponding reported property should be updated in the Device twin JSON structure. LwM2M executable resources # As a rule, LwM2M resources that can be executable translate into Direct methods in Azure IoT Hub. This means that by invoking a direct method or Command from Azure, you can trigger an EXECUTE operation on a chosen resource available for your device and the request will be transferred immediately by the LwM2M Server to the device. Note To learn more about Direct methods, go to the Understand Direct methods section of the Azure IoT Hub documentation. In Azure IoT Hub , an executable LwM2M resource ID is mapped to a direct method in the following way: method name: execute { path: \"object.objectInstance.resource\", [args: \"optional arguments to execute\"] } Thus, for instance, to execute a factory reset on a device, you need to invoke a direct method with the execute name and the following payload: { \"path\": \"3.0.5\" } EXECUTE - Communication flow # Invoking a direct method from Azure IoT Hub and handling it by Coiote DM in the form of an EXECUTE operation passed to the device has the following flow: LwM2M observable resources # In Coiote DM, some of the resources within the device data model can be observed for changes in value. These are generally resources related to telemetry data or other measurements. Their value changes can be monitored by Coiote DM and reported to the Azure IoT Hub Device-to-cloud mechanism. Note To learn more about the Azure Device-to-cloud, go to sending device-to-cloud messages section of the Azure IoT Hub documentation. Observe - Communication flow # Setting an Observe operation on a resource in Coiote DM, for instance a temperature reading, will result in a Notify message sent by the device upon value change that Coiote DM will transfer to the Device-to-cloud mechanism of Azure IoT Hub . What is more, you can set observations on LwM2M resources from the Azure IoT Hub level by adding appropriate attributes to the resource as a Device twin desired property. For instance, an Observe operation on resource ID 3303/1/5700 is set in the following way: ... \"properties\": { \"desired\": { \"lwm2m\": { \"3303\": { \"1\": { \"5700\": { \"observed\": true, \"attributes\": { \"pmin\": 60 } } } } } ... After JSON is saved, Azure notifies Coiote DM of the desired attribute setting which is then transferred to the device in form of an Observe operation. Once Coiote DM is notified of a value change, it is reported to the Azure Device-to-cloud mechanism. Next steps Configure integration templates","title":"LwM2M mappings - Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Hub/#lwm2m-mappings-azure-iot-hub","text":"In this section you'll get to know how the mappings are arranged between the LwM2M protocol as used in Coiote DM and the data retrieval and processing mechanisms of the Azure IoT Hub.","title":"LwM2M mappings - Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Hub/#introduction","text":"The LwM2M protocol data model is organized as a three-level tree that has the following structure: object (e.g. a 'temperature sensor') object instance (e.g. 'temperature sensor #1', 'temperature sensor #2' etc.) resource (e.g. 'current temperature value') In terms of operations that can be performed on an LwM2M Client, an LwM2M Server can READ all of the data model entities, and, depending on their characteristics, may also WRITE to some of them, and EXECUTE some of them. Additionally, an LwM2M Server can also OBSERVE selected resources. Info If you would like to dive deeper into the details of the Lightweight M2M protocol, please refer to our brief introduction to LwM2M . This division into readable, writable, executable and observable data model entities is the basis for the mapping of LwM2M resources (as interpreted by Coiote DM) into Azure IoT Hub data processing mechanisms.","title":"Introduction"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Hub/#lwm2m-readable-and-writable-resources","text":"Within the Coiote DM - Azure IoT Hub integration, readable and writable resources are usually interpreted as part of Azure Device twin data structure. Note To learn more about Device twins, go to the Understand and use Device twins section of the Azure IoT Hub documentation. For instance, the sample JSON snippet below is a tree with nested resources to represent a fragment of the LwM2M data model with path /3/1/1 : { \"deviceId\": \"airquality-0\", ... \"properties\": { \"reported\": { \"lwm2m\": { \"1\": { \"0\": { \"0\": {}, \"1\": { \"value\": 90 }, \"4\": {}, \"6\": {}, \"7\": {}, \"8\": {} } }, \"3\": { \"1\": { \"1\": { \"value\": \"airquality-0-Valparaiso\" } } }, ...","title":"LwM2M readable and writable resources"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Hub/#read-communication-flow","text":"Data model resources that are read-only, such as Manufacturer (with ID 3/0/0 ) will be mapped into the Device twin as a reported property in Azure IoT Hub.","title":"READ - Communication flow"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Hub/#write-communication-flow","text":"On the other hand, a writable resource, such as Lifetime (with ID 1/0/1 ), apart from being represented as a reported property, can be additionally mapped as a desired property. This enables you to synchronize the device data model and configuration between Azure and Coiote DM. In Azure IoT Hub , changing the value of a writable resource involves creating a properly formatted JSON snippet in the desired property field within the Device twin that introduces a value change: ... \"properties\": { \"desired\": { \"lwm2m\": { \"1\": { \"0\": { \"0\": {}, \"1\": { \"value\": 30 } } } }, ... After JSON is saved, Azure notifies Coiote DM of the desired change which is then transferred to the device in form of a WRITE command. Once the value is changed on the device, Coiote DM reports back to Azure that the value of the corresponding reported property should be updated in the Device twin JSON structure.","title":"WRITE - Communication flow"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Hub/#lwm2m-executable-resources","text":"As a rule, LwM2M resources that can be executable translate into Direct methods in Azure IoT Hub. This means that by invoking a direct method or Command from Azure, you can trigger an EXECUTE operation on a chosen resource available for your device and the request will be transferred immediately by the LwM2M Server to the device. Note To learn more about Direct methods, go to the Understand Direct methods section of the Azure IoT Hub documentation. In Azure IoT Hub , an executable LwM2M resource ID is mapped to a direct method in the following way: method name: execute { path: \"object.objectInstance.resource\", [args: \"optional arguments to execute\"] } Thus, for instance, to execute a factory reset on a device, you need to invoke a direct method with the execute name and the following payload: { \"path\": \"3.0.5\" }","title":"LwM2M executable resources"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Hub/#execute-communication-flow","text":"Invoking a direct method from Azure IoT Hub and handling it by Coiote DM in the form of an EXECUTE operation passed to the device has the following flow:","title":"EXECUTE - Communication flow"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Hub/#lwm2m-observable-resources","text":"In Coiote DM, some of the resources within the device data model can be observed for changes in value. These are generally resources related to telemetry data or other measurements. Their value changes can be monitored by Coiote DM and reported to the Azure IoT Hub Device-to-cloud mechanism. Note To learn more about the Azure Device-to-cloud, go to sending device-to-cloud messages section of the Azure IoT Hub documentation.","title":"LwM2M observable resources"},{"location":"Azure_IoT_Integration_Guide/Concepts/LwM2M_mappings_Hub/#observe-communication-flow","text":"Setting an Observe operation on a resource in Coiote DM, for instance a temperature reading, will result in a Notify message sent by the device upon value change that Coiote DM will transfer to the Device-to-cloud mechanism of Azure IoT Hub . What is more, you can set observations on LwM2M resources from the Azure IoT Hub level by adding appropriate attributes to the resource as a Device twin desired property. For instance, an Observe operation on resource ID 3303/1/5700 is set in the following way: ... \"properties\": { \"desired\": { \"lwm2m\": { \"3303\": { \"1\": { \"5700\": { \"observed\": true, \"attributes\": { \"pmin\": 60 } } } } } ... After JSON is saved, Azure notifies Coiote DM of the desired attribute setting which is then transferred to the device in form of an Observe operation. Once Coiote DM is notified of a value change, it is reported to the Azure Device-to-cloud mechanism. Next steps Configure integration templates","title":"Observe - Communication flow"},{"location":"Azure_IoT_Integration_Guide/Configure_integration_templates/Azure_integration_templates/","text":"Configure integration templates # Integration templates define the format in which the data is exchanged between devices and Azure. The data can be either a property or a telemetry. Property describes the actual value. For example: at 1:00 PM a thermometer shows 5\u00b0C, and only this value is sent. Telemetry is used to observe changes in values. For example: it was 5\u00b0C at 1:00 PM, and one hour later it\u2019s 6\u00b0C. In other words, you need to decide whether you want to send and receive historical data or not. If you select the Property option, then Coiote DM reports data to Azure using Device Twins. For the Telemetry data it uses Azure IoT Hub Device-to-cloud mechanism. Read more about these key concepts in the LwM2M mappings section. Follow the instruction below to create integration templates and learn how they work. Prerequisites # An active Azure IoT Central, IoT Hub, or DPS with hub owner access permissions. A Coiote DM user account with permissions to use Hyperscaler Integration Center. Create a new template # In your Coiote DM user account, go to Hyperscaler Integration Center and select the Templates tab. Click Add new in the top-right corner. In the Create new template wizard that appears, provide the Basic data: Template name Azure IoT Central template model ID . This step is optional. If it's enabled, copy and paste the model ID of a device template from the Azure public model repository . This model ID will be used as DPS payload while the device is connected to Azure IoT Central. In this case, Coiote DM won\u2019t generate the template for Azure IoT Central. Note that the assigned model ID can\u2019t be changed. Click Next step . The Data model scheme page displays the list of all LwM2M objects that are available to you. Info If you don't specify the Azure IoT Central template model ID , the Data model scheme by default will contain only two objects: LwM2M Server and Device that are necessary to connect a device to a LwM2M server. You can use this default template to test your integration or for some basic operations. If you have a more complex case (for example, your device contains other LwM2M objects), then you need to add missing objects. To choose the objects and resources that you want to report to Azure, expand the lists and check the respective boxes. To add more objects or resources, click Add missing objects . Select the type of data that needs to be reported (Capability type): Telemetry, Property, or Command. Example Manufacturer is unlikely to change over time, so it is a Property . Reboot is an executable Command . Battery Level is more ambiguous: it can be a property if we just want to have the actual value. But because we want to have its historical values, it is a Telemetry . Click Next step . Check the Summary and click Save template . How integration templates work # As you now know, the Azure integration template is based on a data model which consists of the objects and resources. Coiote DM sends data to Azure every time a device data model is changed, provided that you have set an Observation on the objects and resources in this data model. (Read about setting an Observation in Azure IoT Hub and Azure IoT Central .) Let\u2019s illustrate the process with two examples. In the first case, the change in the data model is triggered by the device. Battery level is defined as a property. When the value of the Battery level resource changes, the device sends Send or Notify messages via LwM2M. The device information in Coiote DM is then updated and translated to Device Twin JSON, which in turn is sent to Azure. Info When Battery level is defined as a telemetry, then Device-to-cloud messages are used. In the second example, the change in the data model is triggered by Coiote DM. When you set an Observation on the Battery level , this information is sent to Azure in the Device Twin JSON. To check whether the values of the Battery level resource on the device and Coiote DM are the same, Coiote DM performs a READ operation on this resource. If the value is different, a WRITE operation is performed to change the value in Coiote DM. Then the Device Twin JSON is updated and sent to Azure. Next steps # Air quality monitoring - tutorial","title":"Configure integration templates"},{"location":"Azure_IoT_Integration_Guide/Configure_integration_templates/Azure_integration_templates/#configure-integration-templates","text":"Integration templates define the format in which the data is exchanged between devices and Azure. The data can be either a property or a telemetry. Property describes the actual value. For example: at 1:00 PM a thermometer shows 5\u00b0C, and only this value is sent. Telemetry is used to observe changes in values. For example: it was 5\u00b0C at 1:00 PM, and one hour later it\u2019s 6\u00b0C. In other words, you need to decide whether you want to send and receive historical data or not. If you select the Property option, then Coiote DM reports data to Azure using Device Twins. For the Telemetry data it uses Azure IoT Hub Device-to-cloud mechanism. Read more about these key concepts in the LwM2M mappings section. Follow the instruction below to create integration templates and learn how they work.","title":"Configure integration templates"},{"location":"Azure_IoT_Integration_Guide/Configure_integration_templates/Azure_integration_templates/#prerequisites","text":"An active Azure IoT Central, IoT Hub, or DPS with hub owner access permissions. A Coiote DM user account with permissions to use Hyperscaler Integration Center.","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Configure_integration_templates/Azure_integration_templates/#create-a-new-template","text":"In your Coiote DM user account, go to Hyperscaler Integration Center and select the Templates tab. Click Add new in the top-right corner. In the Create new template wizard that appears, provide the Basic data: Template name Azure IoT Central template model ID . This step is optional. If it's enabled, copy and paste the model ID of a device template from the Azure public model repository . This model ID will be used as DPS payload while the device is connected to Azure IoT Central. In this case, Coiote DM won\u2019t generate the template for Azure IoT Central. Note that the assigned model ID can\u2019t be changed. Click Next step . The Data model scheme page displays the list of all LwM2M objects that are available to you. Info If you don't specify the Azure IoT Central template model ID , the Data model scheme by default will contain only two objects: LwM2M Server and Device that are necessary to connect a device to a LwM2M server. You can use this default template to test your integration or for some basic operations. If you have a more complex case (for example, your device contains other LwM2M objects), then you need to add missing objects. To choose the objects and resources that you want to report to Azure, expand the lists and check the respective boxes. To add more objects or resources, click Add missing objects . Select the type of data that needs to be reported (Capability type): Telemetry, Property, or Command. Example Manufacturer is unlikely to change over time, so it is a Property . Reboot is an executable Command . Battery Level is more ambiguous: it can be a property if we just want to have the actual value. But because we want to have its historical values, it is a Telemetry . Click Next step . Check the Summary and click Save template .","title":"Create a new template"},{"location":"Azure_IoT_Integration_Guide/Configure_integration_templates/Azure_integration_templates/#how-integration-templates-work","text":"As you now know, the Azure integration template is based on a data model which consists of the objects and resources. Coiote DM sends data to Azure every time a device data model is changed, provided that you have set an Observation on the objects and resources in this data model. (Read about setting an Observation in Azure IoT Hub and Azure IoT Central .) Let\u2019s illustrate the process with two examples. In the first case, the change in the data model is triggered by the device. Battery level is defined as a property. When the value of the Battery level resource changes, the device sends Send or Notify messages via LwM2M. The device information in Coiote DM is then updated and translated to Device Twin JSON, which in turn is sent to Azure. Info When Battery level is defined as a telemetry, then Device-to-cloud messages are used. In the second example, the change in the data model is triggered by Coiote DM. When you set an Observation on the Battery level , this information is sent to Azure in the Device Twin JSON. To check whether the values of the Battery level resource on the device and Coiote DM are the same, Coiote DM performs a READ operation on this resource. If the value is different, a WRITE operation is performed to change the value in Coiote DM. Then the Device Twin JSON is updated and sent to Azure.","title":"How integration templates work"},{"location":"Azure_IoT_Integration_Guide/Configure_integration_templates/Azure_integration_templates/#next-steps","text":"Air quality monitoring - tutorial","title":"Next steps"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/","text":"Air quality monitoring - tutorial # The Coiote DM and Azure IoT Hub integration lets you create custom use cases with data visualization. See the video and have a sneak peek at the possibilities that the Coiote DM - Azure IoT Hub integration offers you. In the tutorial, you will see how to leverage the integration to create an air quality monitoring in just a few steps. The text version of the tutorial, complete with the necessary steps and code snippets, is available below: Prerequisites # An active Azure subscription. An active Coiote DM account. Please refer to Coiote DM home page for details on how to get it. An active Microsoft Power BI account. An OpenWeatherMap account with a free API token. An active and configured Azure CLI - please refer to the Azure CLI installation guide for details. Creating and configuring an Azure IoT hub and storage account # First you need to add a new IoT hub and a storage account in Azure. Here's how to do it: Creating an IoT hub # In your Azure portal home view, go to IoT Hub and select Add . In the Basics tab: select your subscription and resource group, pick your region, provide a name for your IoT hub. In the Management tab: in Pricing and scale tier select, optionally, turn off Defender for IoT . In the Review + create tab, click Create . Creating a storage account # While your new IoT hub is deploying, you can add a new storage account: In the Azure portal, go to Storage accounts and select Add . In the Basics tab: select your subscription and resource group, provide a name for your storage account, pick your location. In the Review + create tab, click Create . Configuring the Azure IoT Hub integration extension # Once the deployments are complete, go to Coiote DM to set up the Azure IoT Hub extension. If you haven't done this yet, please follow the instruction for the Azure IoT Hub integration configuration . Adding and connecting LwM2M air quality meter simulators to Coiote DM and Azure IoT Hub # Go to your Azure IoT Hub and add new devices: Under Explorers , select IoT Devices and click + New . Provide the name for your first device: air-quality-meter-example-0 . Click Save . Repeat the procedure for the other 5 devices (increase the number included in the device name). Go to Coiote DM and sync the previously added devices: In Device inventory , select Sync with IoT platform -> Azure IoT Hub . In the pop-up, click Sync devices . Devices should then be visible in Device inventory Go to your command line and register the device simulators: Paste and run the following command to create a container group: az container create -g coiote-dm-experiments --name air-quality-meter-example-0 --image avsystemcom/air-quality-meter-example --environment-variables DEVICEID=air-quality-meter-example-0 SERVER_ADDRESS=eu.iot.avsystem.cloud OPEN_WEATHER_API_TOKEN=exampletoken Note Remember to change the command parameters accordingly so that they are in line with your naming and credentials. once the command is executed, you should see a JSON payload that describes the content of the container instance. Go back to Coiote DM and in Device inventory , check if the devices have registered to the platform and if their data model has been updated. Click the Refresh data icon if needed. Click on a device and in the Device Management Center , select the Actions panel. Select the Refresh data model from device link and confirm by clicking Yes, execute task now . Go to the Objects panel to see if the data model for the device has been updated. You should be able to see objects such as 3 Device (along with the Model number resource which shows the name of the city of the temperature reading), 3303 Temperature , and 3428 Air quality . Bidirectional communication using Device Twin # From Coiote DM to Azure IoT Hub # In your Coiote DM account, go to Device inventory , select a device. In the Device Management Center , go to the Objects panel. In the 1 LwM2M Server object, find the Lifetime resource. Click the pen icon next to it, change the lifetime value and click the Apply link. Go to your Azure IoT hub, select IoT devices , click your device and select the Device Twin panel. Click Refresh and check in the JSON payload if the reported property for the 1/0/1 (Lifetime) resource has changed. From Azure IoT Hub to Coiote DM # Note To read more about how the Device Twins work in the Coiote DM - Azure IoT Hub integration, please refer to the LwM2M Mappings section . In your Azure IoT hub, select IoT devices , click one of your added devices and select the Device Twin panel. To change the Lifetime resource in Coiote DM, you need to modify the relevant Device Twin desired property. under the properties tag in the Device Twin JSON payload, paste the following nested structure: \"reported\": { \"lwm2m\": { \"1\": { \"0\": { \"0\": {}, \"1\": { \"value\": 45 } } } } }, - Click Save and Refresh . The value of the resource should now be changed in the Device Twin reported properties as well as in the Coiote DM Objects panel, in the Lifetime resource of the 1 LwM2M Server object. Passing telemetry to Azure IoT Hub # Setting group value tracking on resources in Coiote DM # In Coiote DM, go to Device inventory and use the search option to display your air quality meter devices. Then, click the Add to group icon. In the pop-up, click Add to new group , provide a name for your group (following the pattern root.iothubexample.airqualitymeter), click Confirm and Yes . Go to the Group management panel, select your group and click Devices to see if all of your devices are added to the group. Go to the Value tracking panel and click Add new . In the pop-up: Add value tracking for the Temperature resource: Provide the resource path: Temperature.1.Sensor Value . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Add value tracking for the Air quality PM10 resource: Provide the resource path: Air quality.1.PM10 . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Add value tracking for the Air quality PM2.5 resource: Provide the resource path: Air quality.1.PM2_5 . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Go back to Device inventory and select a device of your group. In the Dashboard view , you should be able to see the value tracking parameters as in the picture below: Configuring message routing for sending telemetry data in Azure IoT Hub # Go to your Azure IoT hub and add message routing: Under Messaging , select Message routing and click + Add . Provide a name for your event, for example EventRoute . From the Endpoint drop-down list, select events . In the Routing query , paste the following: IS_DEFINED($body.lwm2m.3303.1.5700.value) OR IS_DEFINED($body.lwm2m.3428.1.1.value) OR IS_DEFINED($body.lwm2m.3428.1.3.value) Click Save . While in the Message routing panel, go to the Enrich messages tab to set up location tracking: For latitude: Name - type lat Value - copy and paste $twin.properties.reported.lwm2m.6.1.0.value Endpoint(s) - select events For longitude: Name - type lon Value - copy and paste $twin.properties.reported.lwm2m.6.1.1.value Endpoint(s) - select events For longitude: Name - type deviceId Value - copy and paste $twin.properties.reported.lwm2m.3.1.1.value Endpoint(s) - select events Use search to go to Stream analytics jobs and create a job for transferring the gathered data to Power BI. Click + Add and provide the following: Job name - e.g. avsystem-iot-hub-to-powerbi . Resource group - pick your resource group. Click Create . Once your deployment is complete, click Go to resource . While in your Stream Analytics job panel, add a stream input and output and write a query: Under Job topology , select Inputs . From the + Add stream input drop-down list, select Iot Hub and provide the following: Input alias - e.g. avsystem-iot-hub-input . Consumer group - pick the $Default group. Click Save . Under Job topology , select Outputs . From the + Add drop-down list, select Power BI and click Authorize . Log in to Power BI using your Azure account. In the Power BI right-hand side panel, provide the following: Output alias - e.g. avsystem-iot-hub-output Dataset name - e.g. AVSystemIoTHubDataSet Table name - e.g. Data Click Save . Under Job topology , select Query . Paste the following query into the query input field (remember to adjust your naming inside the query if needed): SELECT CAST(lwm2m.\"3303.\"1\".\"5700\".value as float) as temperature, CAST(lwm2m.\"3428.\"1\".\"1\".value as float) as pm10, CAST(lwm2m.\"3428.\"1\".\"3\".value as float) as pm25, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User].[lat]') as lat, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User],[lon]') as lon, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User],[deviceId]') as deviceId2, EventProcessedUtcTime as processedTimestamp, IoTHub.EnqueuedTime as iotHubTimestamp, IoTHub.ConnectionDeviceId as deviceId INTO \"avsystem-iot-hub-output\" FROM \"avsystem-iot-hub-input\" Click Save query . In your Stream analytics job, go to Overview and click Start and confirm by clicking Start in the Start job window to run the created query. Data visualization using Power BI # Once the query is finished, you can go to Power BI to create a visualization for the data you have gathered. Go to https://powerbi.microsoft.com/ and sign in to your account. Go to My workspace and find your recently created dataset. Click the more options icon and select Create report From the Visualizations menu, select the table icon and drag and drop it to the work space. From the Fields menu, select the deviceId2 , temperature , pm10 and pm25 parameters. In the Values submenu, expand the drop-down list for the temperature , pm10 and pm25 parameters and select Average for each. Create a map with air quality indicators: From the Visualizations menu, click the get more visuals icon and select Get more visuals . Use search to find the Heatmap and click Add . From the Visualizations menu, click the Heatmap icon. Add the relevant parameters to the map data fields: To the Latitude data field, drag and drop the lat parameter from the Fields menu. To the Longitude data field, drag and drop the lon parameter from the Fields menu. To the Value data field, drag and drop the pm10 parameter from the Fields menu. In the Value data field, expand the drop-down list and select Average . To refresh the displayed data, click the Refresh button located in the upper navigation bar.","title":"Air quality monitoring - tutorial"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#air-quality-monitoring-tutorial","text":"The Coiote DM and Azure IoT Hub integration lets you create custom use cases with data visualization. See the video and have a sneak peek at the possibilities that the Coiote DM - Azure IoT Hub integration offers you. In the tutorial, you will see how to leverage the integration to create an air quality monitoring in just a few steps. The text version of the tutorial, complete with the necessary steps and code snippets, is available below:","title":"Air quality monitoring - tutorial"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#prerequisites","text":"An active Azure subscription. An active Coiote DM account. Please refer to Coiote DM home page for details on how to get it. An active Microsoft Power BI account. An OpenWeatherMap account with a free API token. An active and configured Azure CLI - please refer to the Azure CLI installation guide for details.","title":"Prerequisites"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#creating-and-configuring-an-azure-iot-hub-and-storage-account","text":"First you need to add a new IoT hub and a storage account in Azure. Here's how to do it:","title":"Creating and configuring an Azure IoT hub and storage account"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#creating-an-iot-hub","text":"In your Azure portal home view, go to IoT Hub and select Add . In the Basics tab: select your subscription and resource group, pick your region, provide a name for your IoT hub. In the Management tab: in Pricing and scale tier select, optionally, turn off Defender for IoT . In the Review + create tab, click Create .","title":"Creating an IoT hub"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#creating-a-storage-account","text":"While your new IoT hub is deploying, you can add a new storage account: In the Azure portal, go to Storage accounts and select Add . In the Basics tab: select your subscription and resource group, provide a name for your storage account, pick your location. In the Review + create tab, click Create .","title":"Creating a storage account"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#configuring-the-azure-iot-hub-integration-extension","text":"Once the deployments are complete, go to Coiote DM to set up the Azure IoT Hub extension. If you haven't done this yet, please follow the instruction for the Azure IoT Hub integration configuration .","title":"Configuring the Azure IoT Hub integration extension"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#adding-and-connecting-lwm2m-air-quality-meter-simulators-to-coiote-dm-and-azure-iot-hub","text":"Go to your Azure IoT Hub and add new devices: Under Explorers , select IoT Devices and click + New . Provide the name for your first device: air-quality-meter-example-0 . Click Save . Repeat the procedure for the other 5 devices (increase the number included in the device name). Go to Coiote DM and sync the previously added devices: In Device inventory , select Sync with IoT platform -> Azure IoT Hub . In the pop-up, click Sync devices . Devices should then be visible in Device inventory Go to your command line and register the device simulators: Paste and run the following command to create a container group: az container create -g coiote-dm-experiments --name air-quality-meter-example-0 --image avsystemcom/air-quality-meter-example --environment-variables DEVICEID=air-quality-meter-example-0 SERVER_ADDRESS=eu.iot.avsystem.cloud OPEN_WEATHER_API_TOKEN=exampletoken Note Remember to change the command parameters accordingly so that they are in line with your naming and credentials. once the command is executed, you should see a JSON payload that describes the content of the container instance. Go back to Coiote DM and in Device inventory , check if the devices have registered to the platform and if their data model has been updated. Click the Refresh data icon if needed. Click on a device and in the Device Management Center , select the Actions panel. Select the Refresh data model from device link and confirm by clicking Yes, execute task now . Go to the Objects panel to see if the data model for the device has been updated. You should be able to see objects such as 3 Device (along with the Model number resource which shows the name of the city of the temperature reading), 3303 Temperature , and 3428 Air quality .","title":"Adding and connecting LwM2M air quality meter simulators to Coiote DM and Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#bidirectional-communication-using-device-twin","text":"","title":"Bidirectional communication using Device Twin"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#from-coiote-dm-to-azure-iot-hub","text":"In your Coiote DM account, go to Device inventory , select a device. In the Device Management Center , go to the Objects panel. In the 1 LwM2M Server object, find the Lifetime resource. Click the pen icon next to it, change the lifetime value and click the Apply link. Go to your Azure IoT hub, select IoT devices , click your device and select the Device Twin panel. Click Refresh and check in the JSON payload if the reported property for the 1/0/1 (Lifetime) resource has changed.","title":"From Coiote DM to Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#from-azure-iot-hub-to-coiote-dm","text":"Note To read more about how the Device Twins work in the Coiote DM - Azure IoT Hub integration, please refer to the LwM2M Mappings section . In your Azure IoT hub, select IoT devices , click one of your added devices and select the Device Twin panel. To change the Lifetime resource in Coiote DM, you need to modify the relevant Device Twin desired property. under the properties tag in the Device Twin JSON payload, paste the following nested structure: \"reported\": { \"lwm2m\": { \"1\": { \"0\": { \"0\": {}, \"1\": { \"value\": 45 } } } } }, - Click Save and Refresh . The value of the resource should now be changed in the Device Twin reported properties as well as in the Coiote DM Objects panel, in the Lifetime resource of the 1 LwM2M Server object.","title":"From Azure IoT Hub to Coiote DM"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#passing-telemetry-to-azure-iot-hub","text":"","title":"Passing telemetry to Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#setting-group-value-tracking-on-resources-in-coiote-dm","text":"In Coiote DM, go to Device inventory and use the search option to display your air quality meter devices. Then, click the Add to group icon. In the pop-up, click Add to new group , provide a name for your group (following the pattern root.iothubexample.airqualitymeter), click Confirm and Yes . Go to the Group management panel, select your group and click Devices to see if all of your devices are added to the group. Go to the Value tracking panel and click Add new . In the pop-up: Add value tracking for the Temperature resource: Provide the resource path: Temperature.1.Sensor Value . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Add value tracking for the Air quality PM10 resource: Provide the resource path: Air quality.1.PM10 . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Add value tracking for the Air quality PM2.5 resource: Provide the resource path: Air quality.1.PM2_5 . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Go back to Device inventory and select a device of your group. In the Dashboard view , you should be able to see the value tracking parameters as in the picture below:","title":"Setting group value tracking on resources in Coiote DM"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#configuring-message-routing-for-sending-telemetry-data-in-azure-iot-hub","text":"Go to your Azure IoT hub and add message routing: Under Messaging , select Message routing and click + Add . Provide a name for your event, for example EventRoute . From the Endpoint drop-down list, select events . In the Routing query , paste the following: IS_DEFINED($body.lwm2m.3303.1.5700.value) OR IS_DEFINED($body.lwm2m.3428.1.1.value) OR IS_DEFINED($body.lwm2m.3428.1.3.value) Click Save . While in the Message routing panel, go to the Enrich messages tab to set up location tracking: For latitude: Name - type lat Value - copy and paste $twin.properties.reported.lwm2m.6.1.0.value Endpoint(s) - select events For longitude: Name - type lon Value - copy and paste $twin.properties.reported.lwm2m.6.1.1.value Endpoint(s) - select events For longitude: Name - type deviceId Value - copy and paste $twin.properties.reported.lwm2m.3.1.1.value Endpoint(s) - select events Use search to go to Stream analytics jobs and create a job for transferring the gathered data to Power BI. Click + Add and provide the following: Job name - e.g. avsystem-iot-hub-to-powerbi . Resource group - pick your resource group. Click Create . Once your deployment is complete, click Go to resource . While in your Stream Analytics job panel, add a stream input and output and write a query: Under Job topology , select Inputs . From the + Add stream input drop-down list, select Iot Hub and provide the following: Input alias - e.g. avsystem-iot-hub-input . Consumer group - pick the $Default group. Click Save . Under Job topology , select Outputs . From the + Add drop-down list, select Power BI and click Authorize . Log in to Power BI using your Azure account. In the Power BI right-hand side panel, provide the following: Output alias - e.g. avsystem-iot-hub-output Dataset name - e.g. AVSystemIoTHubDataSet Table name - e.g. Data Click Save . Under Job topology , select Query . Paste the following query into the query input field (remember to adjust your naming inside the query if needed): SELECT CAST(lwm2m.\"3303.\"1\".\"5700\".value as float) as temperature, CAST(lwm2m.\"3428.\"1\".\"1\".value as float) as pm10, CAST(lwm2m.\"3428.\"1\".\"3\".value as float) as pm25, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User].[lat]') as lat, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User],[lon]') as lon, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User],[deviceId]') as deviceId2, EventProcessedUtcTime as processedTimestamp, IoTHub.EnqueuedTime as iotHubTimestamp, IoTHub.ConnectionDeviceId as deviceId INTO \"avsystem-iot-hub-output\" FROM \"avsystem-iot-hub-input\" Click Save query . In your Stream analytics job, go to Overview and click Start and confirm by clicking Start in the Start job window to run the created query.","title":"Configuring message routing for sending telemetry data in Azure IoT Hub"},{"location":"Azure_IoT_Integration_Guide/Tutorials/Air_quality_monitoring_tutorial/#data-visualization-using-power-bi","text":"Once the query is finished, you can go to Power BI to create a visualization for the data you have gathered. Go to https://powerbi.microsoft.com/ and sign in to your account. Go to My workspace and find your recently created dataset. Click the more options icon and select Create report From the Visualizations menu, select the table icon and drag and drop it to the work space. From the Fields menu, select the deviceId2 , temperature , pm10 and pm25 parameters. In the Values submenu, expand the drop-down list for the temperature , pm10 and pm25 parameters and select Average for each. Create a map with air quality indicators: From the Visualizations menu, click the get more visuals icon and select Get more visuals . Use search to find the Heatmap and click Add . From the Visualizations menu, click the Heatmap icon. Add the relevant parameters to the map data fields: To the Latitude data field, drag and drop the lat parameter from the Fields menu. To the Longitude data field, drag and drop the lon parameter from the Fields menu. To the Value data field, drag and drop the pm10 parameter from the Fields menu. In the Value data field, expand the drop-down list and select Average . To refresh the displayed data, click the Refresh button located in the upper navigation bar.","title":"Data visualization using Power BI"},{"location":"Coiote_DM_Device_Onboarding/Device_Center/","text":"Device Center # Important This chapter refers to the beta version of the new Device Center. It replaces the previous Device Management Center view (DMC) which is still supported - use the Go to previous version button and the Go to new Device Center link to switch between them. For documentation of the previous version, check the in-platform Coiote DM User Guide. The Device Center is designed for effective management of single devices. It enables IoT developers to build LwM2M applications quickly and intuitively and features actionable sections for quick access to the most important device info and data. To enter the Device Center, go to Device inventory and click on the Management (or Bootstrap , if applicable) link next to the device name in the table. Summary sidebar # Use it to have the essential device info, status and actions always at hand. Device actions include: Reboot - make the device reboot by executing the Reboot resource from device data model. Data model refresh - make the device refresh its data model to check for new objects, object instances or resources. This is done by executing the LwM2M Discover operation on the device. Clear DTLS context - erase the context established between the device and the server during the DTLS handshake. A DTLS handshake will be performed to create a new DTLS context for communication. Delete device - permanently deletes the device entity and its data. Device summary lets you quickly check connection status and essential info about the device: Overview tab # Use this tab to see widgets related to device status and connectivity, and view Device location on the map and check location details: Note The information displayed in this tab is taken from the device data model in most cases. See more about the device data model in the Data model tab section. Configuration tab # Quickly view, copy and edit device connection parameters and edit device details such as Friendly name and image. To upload device image, click Upload device image , browse an image from your local drive and click Save . To change device Friendly name , click on the pen icon next to the device name in the widget. To copy each connection parameter, use the copy icon next to a given field. To change connection parameters, e.g. Security mode , click on the pen icon in the top right corner, change the required data and click Save . Data model tab # Perform or schedule operations on device objects, object instances, and resources: To search the data model for device objects, object instances, and resources, start typing in the Search field to see results: Read # To perform a LwM2M READ operation on an object, object instance, or resource, click the circular icon in the Operations column (or via the 3 vertical dots menu in case of objects and object instances). Write # To perform a LwM2M WRITE operation on an object, object instance, or resource, click the pen icon in the Operations column. In the side navigation menu, type the desired value and click Set value . Execute # To perform a LwM2M EXECUTE operation on a resource, click the cogwheel icon in the Operations column and select Execute , or Execute with parameters to set additional EXECUTE conditions. Set observation # To set an observation on a resource (and, effectively, start performing LwM2M OBSERVE operations on the device): Click the eye icon in the Operations column. In the side navigation menu, enable the desired attributes, fill in the values, and click Set observation . Info Not more often than once every - the minimum time in seconds between two notifications. At least once every - the maximum time in seconds between two notifications. The notification is sent even if the value hasn't changed. Read more about other attributes in our Brief description of OMA LwM2M . To set an observation on an object or object instance, click on the 3 vertical dots menu and select Set observation , then follow the steps described above.","title":"Device Center"},{"location":"Coiote_DM_Device_Onboarding/Device_Center/#device-center","text":"Important This chapter refers to the beta version of the new Device Center. It replaces the previous Device Management Center view (DMC) which is still supported - use the Go to previous version button and the Go to new Device Center link to switch between them. For documentation of the previous version, check the in-platform Coiote DM User Guide. The Device Center is designed for effective management of single devices. It enables IoT developers to build LwM2M applications quickly and intuitively and features actionable sections for quick access to the most important device info and data. To enter the Device Center, go to Device inventory and click on the Management (or Bootstrap , if applicable) link next to the device name in the table.","title":"Device Center"},{"location":"Coiote_DM_Device_Onboarding/Device_Center/#summary-sidebar","text":"Use it to have the essential device info, status and actions always at hand. Device actions include: Reboot - make the device reboot by executing the Reboot resource from device data model. Data model refresh - make the device refresh its data model to check for new objects, object instances or resources. This is done by executing the LwM2M Discover operation on the device. Clear DTLS context - erase the context established between the device and the server during the DTLS handshake. A DTLS handshake will be performed to create a new DTLS context for communication. Delete device - permanently deletes the device entity and its data. Device summary lets you quickly check connection status and essential info about the device:","title":"Summary sidebar"},{"location":"Coiote_DM_Device_Onboarding/Device_Center/#overview-tab","text":"Use this tab to see widgets related to device status and connectivity, and view Device location on the map and check location details: Note The information displayed in this tab is taken from the device data model in most cases. See more about the device data model in the Data model tab section.","title":"Overview tab"},{"location":"Coiote_DM_Device_Onboarding/Device_Center/#configuration-tab","text":"Quickly view, copy and edit device connection parameters and edit device details such as Friendly name and image. To upload device image, click Upload device image , browse an image from your local drive and click Save . To change device Friendly name , click on the pen icon next to the device name in the widget. To copy each connection parameter, use the copy icon next to a given field. To change connection parameters, e.g. Security mode , click on the pen icon in the top right corner, change the required data and click Save .","title":"Configuration tab"},{"location":"Coiote_DM_Device_Onboarding/Device_Center/#data-model-tab","text":"Perform or schedule operations on device objects, object instances, and resources: To search the data model for device objects, object instances, and resources, start typing in the Search field to see results:","title":"Data model tab"},{"location":"Coiote_DM_Device_Onboarding/Device_Center/#read","text":"To perform a LwM2M READ operation on an object, object instance, or resource, click the circular icon in the Operations column (or via the 3 vertical dots menu in case of objects and object instances).","title":"Read"},{"location":"Coiote_DM_Device_Onboarding/Device_Center/#write","text":"To perform a LwM2M WRITE operation on an object, object instance, or resource, click the pen icon in the Operations column. In the side navigation menu, type the desired value and click Set value .","title":"Write"},{"location":"Coiote_DM_Device_Onboarding/Device_Center/#execute","text":"To perform a LwM2M EXECUTE operation on a resource, click the cogwheel icon in the Operations column and select Execute , or Execute with parameters to set additional EXECUTE conditions.","title":"Execute"},{"location":"Coiote_DM_Device_Onboarding/Device_Center/#set-observation","text":"To set an observation on a resource (and, effectively, start performing LwM2M OBSERVE operations on the device): Click the eye icon in the Operations column. In the side navigation menu, enable the desired attributes, fill in the values, and click Set observation . Info Not more often than once every - the minimum time in seconds between two notifications. At least once every - the maximum time in seconds between two notifications. The notification is sent even if the value hasn't changed. Read more about other attributes in our Brief description of OMA LwM2M . To set an observation on an object or object instance, click on the 3 vertical dots menu and select Set observation , then follow the steps described above.","title":"Set observation"},{"location":"Coiote_DM_Device_Onboarding/Device_onboarding/","text":"Device onboarding # This guide will walk you through the process of adding new devices to Coiote DM. You will learn how to onboard devices using different scenarios: connection via the Management server, via the Bootstrap server, or running a simulated test device with the Anjay LwM2M Client. Prerequisites # An active Coiote DM user account with appropriate role assigned. A LwM2M device (except for the simulated test device scenario). An Anjay SDK repository (only for the simulated test device scenario). A configured Bootstrap server (only for the Bootstrap server scenario). Add a device via the Management server # To add a device using the Management server: From the navigation menu, select Device Inventory and click the Add device button. Note If you're a new user with no added devices, the Add your LwM2M device panel will be displayed upon logging in to the platform. Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step, provide the following: Device ID - enter the endpoint name of your LwM2M device. Friendly name (optional) - enter a name for your device that will help user identify it in the platform. Security mode: PSK - authorize your device using a pre-shared key. To use this option, provide the following: Key identity - define the name that the device will use during DTLS handshake. Can be equal with the LwM2M device endpoint name. Key - provide the shared secret used in the device-server authentication. Select the Key in hexadecimal check box to enable specifying the key in hexadecimal format. NoSec - use the device with no security established for the device-server communication. Using this mode is not recommended except for testing purposes. Certificate - secure your device-server communication with a certificate: Select Use a previously uploaded certificate if you have already uploaded a certificate to the platform using the DTLS/TLS Certificates panel. Select Upload a new certificate to load your certificate file using the Browse button. Click the Add device button and Confirm in the confirmation pop-up. Important At this stage, your device will be already visible in the platform. However, to get your device connected, you need to configure it using the credentials from the next step. In the Connect your device step, insert the given connection parameters into your device to start connection. Click Go to device to see your added device dashboard. Add a device via the Bootstrap server # To add a device using the Bootstrap server: From the navigation menu, select Device Inventory and click the Add device button. Note If you're a new user with no added devices, the Add your LwM2M device panel will be displayed upon logging in to the platform. Select the Connect your LwM2M device via the Bootstrap server tile. In the Device credentials step, provide the following: Device ID - enter the endpoint name of your LwM2M device. Friendly name (optional) - enter a name for your device that will help user identify it in the platform. Security mode: PSK - authorize your device using a pre-shared key. To use this option, provide the following: Key identity - define the name that the device will use during DTLS handshake. Can be equal with the LwM2M device endpoint name. Key - provide the shared secret used in the device-server authentication. Select the Key in hexadecimal check box to enable specifying the key in hexadecimal format. NoSec - use the device with no security established for the device-server communication. It is recommended to use this mode only for testing purposes. Certificate - secure your device-server communication with a certificate: Select Use a previously uploaded certificate if you have already uploaded a certificate to the platform using the DTLS/TLS Certificates panel. Select Upload a new certificate to load your certificate file using the Browse button. Click the Configuration button to go to the next step. In the Configuration step, select a Management server for your device from the drop-down list: Use the bootstrap configuration set as default for your domain - use this setting if you want to make use of the inherited bootstrap settings for your domain. This Coiote DM Management Server (Cert with EST) - use this setting if you have chosen the Certificate mode in the Device credentials step. This Coiote DM Management Server NoSec - use this setting to establish the device-server communication with no security. Using this mode is not recommended except for testing purposes. This Coiote DM Management Server PSK - use this setting to authorize the device-server communication using a pre-shared key. Your custom bootstrap setting - this type of setting will appear if you have configured a bootstrap server setting using the Bootstrap configuration panel. Click the Add device button and Confirm in the confirmation pop-up. Important At this stage, your device will be already visible in the platform. However, to get your device connected, you need to configure it using the credentials from the next step. In the Connect your device step, insert the given connection parameters into your device to start connection. Click Go to device to see your added device dashboard. Add a device using the Anjay LwM2M Client # To add a simulated device with the Anjay LwM2M Client: From the navigation menu, select Device Inventory and click the Add device button. Note If you're a new user with no added devices, the Add your LwM2M device panel will be displayed upon logging in to the platform. Select the Run your device using the Anjay LwM2M Client tile. Open a command line interface in your Anjay SDK repository folder and run the command displayed inside the command field. Click Go to device to see your added device dashboard.","title":"Device onboarding"},{"location":"Coiote_DM_Device_Onboarding/Device_onboarding/#device-onboarding","text":"This guide will walk you through the process of adding new devices to Coiote DM. You will learn how to onboard devices using different scenarios: connection via the Management server, via the Bootstrap server, or running a simulated test device with the Anjay LwM2M Client.","title":"Device onboarding"},{"location":"Coiote_DM_Device_Onboarding/Device_onboarding/#prerequisites","text":"An active Coiote DM user account with appropriate role assigned. A LwM2M device (except for the simulated test device scenario). An Anjay SDK repository (only for the simulated test device scenario). A configured Bootstrap server (only for the Bootstrap server scenario).","title":"Prerequisites"},{"location":"Coiote_DM_Device_Onboarding/Device_onboarding/#add-a-device-via-the-management-server","text":"To add a device using the Management server: From the navigation menu, select Device Inventory and click the Add device button. Note If you're a new user with no added devices, the Add your LwM2M device panel will be displayed upon logging in to the platform. Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step, provide the following: Device ID - enter the endpoint name of your LwM2M device. Friendly name (optional) - enter a name for your device that will help user identify it in the platform. Security mode: PSK - authorize your device using a pre-shared key. To use this option, provide the following: Key identity - define the name that the device will use during DTLS handshake. Can be equal with the LwM2M device endpoint name. Key - provide the shared secret used in the device-server authentication. Select the Key in hexadecimal check box to enable specifying the key in hexadecimal format. NoSec - use the device with no security established for the device-server communication. Using this mode is not recommended except for testing purposes. Certificate - secure your device-server communication with a certificate: Select Use a previously uploaded certificate if you have already uploaded a certificate to the platform using the DTLS/TLS Certificates panel. Select Upload a new certificate to load your certificate file using the Browse button. Click the Add device button and Confirm in the confirmation pop-up. Important At this stage, your device will be already visible in the platform. However, to get your device connected, you need to configure it using the credentials from the next step. In the Connect your device step, insert the given connection parameters into your device to start connection. Click Go to device to see your added device dashboard.","title":"Add a device via the Management server"},{"location":"Coiote_DM_Device_Onboarding/Device_onboarding/#add-a-device-via-the-bootstrap-server","text":"To add a device using the Bootstrap server: From the navigation menu, select Device Inventory and click the Add device button. Note If you're a new user with no added devices, the Add your LwM2M device panel will be displayed upon logging in to the platform. Select the Connect your LwM2M device via the Bootstrap server tile. In the Device credentials step, provide the following: Device ID - enter the endpoint name of your LwM2M device. Friendly name (optional) - enter a name for your device that will help user identify it in the platform. Security mode: PSK - authorize your device using a pre-shared key. To use this option, provide the following: Key identity - define the name that the device will use during DTLS handshake. Can be equal with the LwM2M device endpoint name. Key - provide the shared secret used in the device-server authentication. Select the Key in hexadecimal check box to enable specifying the key in hexadecimal format. NoSec - use the device with no security established for the device-server communication. It is recommended to use this mode only for testing purposes. Certificate - secure your device-server communication with a certificate: Select Use a previously uploaded certificate if you have already uploaded a certificate to the platform using the DTLS/TLS Certificates panel. Select Upload a new certificate to load your certificate file using the Browse button. Click the Configuration button to go to the next step. In the Configuration step, select a Management server for your device from the drop-down list: Use the bootstrap configuration set as default for your domain - use this setting if you want to make use of the inherited bootstrap settings for your domain. This Coiote DM Management Server (Cert with EST) - use this setting if you have chosen the Certificate mode in the Device credentials step. This Coiote DM Management Server NoSec - use this setting to establish the device-server communication with no security. Using this mode is not recommended except for testing purposes. This Coiote DM Management Server PSK - use this setting to authorize the device-server communication using a pre-shared key. Your custom bootstrap setting - this type of setting will appear if you have configured a bootstrap server setting using the Bootstrap configuration panel. Click the Add device button and Confirm in the confirmation pop-up. Important At this stage, your device will be already visible in the platform. However, to get your device connected, you need to configure it using the credentials from the next step. In the Connect your device step, insert the given connection parameters into your device to start connection. Click Go to device to see your added device dashboard.","title":"Add a device via the Bootstrap server"},{"location":"Coiote_DM_Device_Onboarding/Device_onboarding/#add-a-device-using-the-anjay-lwm2m-client","text":"To add a simulated device with the Anjay LwM2M Client: From the navigation menu, select Device Inventory and click the Add device button. Note If you're a new user with no added devices, the Add your LwM2M device panel will be displayed upon logging in to the platform. Select the Run your device using the Anjay LwM2M Client tile. Open a command line interface in your Anjay SDK repository folder and run the command displayed inside the command field. Click Go to device to see your added device dashboard.","title":"Add a device using the Anjay LwM2M Client"},{"location":"Coiote_DM_Device_Onboarding/Quick_start/","text":"Quick start # Learn how to onboard a LwM2M device in just a few clicks. Prerequisites # An active Coiote DM user account with appropriate role assigned. A LwM2M device (except for the simulated test device scenario). Onboard a device via the Management server with PSK security mode # Upon logging in to Coiote DM, you will see the Add your LwM2M device panel. Note If you have added a device already, the panel will not show. In this case, from the navigation menu, select Device Inventory and click the Add device button. Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your LwM2M device endpoint name, e.g. test_device . In the Security mode section, select the PSK mode: In the Key identity field, type test_device In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, insert the given connection parameters into your device to start connection. Click Go to device to see your added device dashboard.","title":"Quick start"},{"location":"Coiote_DM_Device_Onboarding/Quick_start/#quick-start","text":"Learn how to onboard a LwM2M device in just a few clicks.","title":"Quick start"},{"location":"Coiote_DM_Device_Onboarding/Quick_start/#prerequisites","text":"An active Coiote DM user account with appropriate role assigned. A LwM2M device (except for the simulated test device scenario).","title":"Prerequisites"},{"location":"Coiote_DM_Device_Onboarding/Quick_start/#onboard-a-device-via-the-management-server-with-psk-security-mode","text":"Upon logging in to Coiote DM, you will see the Add your LwM2M device panel. Note If you have added a device already, the panel will not show. In this case, from the navigation menu, select Device Inventory and click the Add device button. Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your LwM2M device endpoint name, e.g. test_device . In the Security mode section, select the PSK mode: In the Key identity field, type test_device In the Key field, type the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. In the Connect your device step, insert the given connection parameters into your device to start connection. Click Go to device to see your added device dashboard.","title":"Onboard a device via the Management server with PSK security mode"},{"location":"Device_tests/Configure_tests/","text":"Configure tests # Introduction # This chapter covers the configuration aspects of the device tests. It explains how to list and view the configuration of tests, and how to add, edit, delete, import, and export them. Note The configuration of tests is device-independent, which means that all the configured tests can be applied for all the devices that have registered to the platform. Device test repository panel # In this section you'll learn about the layout and main features of the Device test repository panel. To enter the panel, select Device test repository and then Server simulator in the navigation menu. Search \u2013 use it to search the test list. Filter - use it to filter tests either per domain or per test type (Automated or Semi-Manual). Add test \u2013 use it to add a test manually or import tests from a .conf file. 'Select all' checkbox \u2013 use it to select or deselect all tests visible in the list. Actions \u2013 drop-down menu \u2013 use it to download or delete selected tests. Actions \u2013 context menu - use it to preview, download, or delete selected tests. Test list \u2013 it features all the tests available for you at the moment, or all the tests meeting the search criteria (if entered). Test type \u2013 it shows the test type: either Automated or Semi-Manual. Domain name \u2013 it shows the names of domains and subdomains to which your test belong. Creation date \u2013 it shows the date when the test was created. Last modified \u2013 it shows the date when the test was last modified. Description \u2013 it shows a test description, if the test has any. Listing tests # The tests appearing in the Device test repository panel are presented in the form of a searchable alphabetical list to ensure their convenient viewing and management. Read on this section to learn how to use the search to list your tests. Using the search # To search the list of configured tests, start typing your entry into the search field. The matching items will appear in the list. Tip Note that if you select a test from the filtered list and then erase your entry from the search field, the selection is carried over to the complete list view. Similarly, if you use the Select all checkbox in the full list view and then filter the list using the search, the selection is carried over to the filtered list view. Viewing test configuration # Read this section to learn how to view the configuration of an individual test: From the navigation menu, select Device test repository . In the list, find the test you want to view and click its name. In the action list, expand the action items by clicking the \u02c5 icon. To expand or collapse the complete action list, use the Expand all and Collapse all buttons. Optionally, you can use the Edit test button to edit your test or click the trash bin icon to delete it. Adding new tests # Read this section to learn how to add a new test. You can either add a test manually or import tests as a .conf file. Add a test manually # From the navigation menu, select Device test repository . Click Add test and select Add test manually Configure your test: Enter your Test name (this field is mandatory). Enter your Test description (this field is optional). Select your Reference device (this field is optional). You can either: type the exact device ID in the Reference device search field and hit Enter , click Select reference device and select your device from the list. If you can't see your device in the list, start typing its name in the search field to get matching results. In the Action list , specify your actions: To add your first action item, choose its name from the drop-down list, or type its name in the Specify action field. Within the action, fill in the mandatory attributes field. To add another action item, use the Add action button and specify your next action. To change the order of actions within the test, drag and drop the action item you want to move by using the drag icon. To copy an action item, click the copy icon (except for the Loop action). To delete an action item, click the trash bin icon. If your test is ready and all the mandatory fields are filled, click Add a new test . Note To learn more about individual test actions, see the Test action chapter. Import tests from .conf file # From the navigation menu, select Device test repository . Click Add test and select Import tests from .conf file . A dialogue box prompting you to import a .conf file appears. Add the file and click Import . Tip To download tests into a .conf file, check the Downloading tests section. Editing tests # Read this section to learn how to edit a test. Note If you edit a test that was executed before, the existing historical results for this test will no longer be available. From the navigation menu, select Device test repository . From the list, choose the test you want to edit and click its name. Click Edit test in the top-right corner. Edit your test: Modify your Test name (this field is mandatory). Modify your Test description (this field is optional). Change or add your Reference device (this field is optional). You can either: type the exact device ID in the Reference device search field and hit Enter , click Select reference device and select your device from the list. If you can't see your device in the list, start typing its name in the search field to get matching results. In the Action list , edit your actions: Edit an existing action item by changing its name, modifying its attributes. Add another action item using the Add action button. Change the order of actions within the test by dragging and dropping the action item you want to move using the drag icon. Copy an action item by clicking on the copy icon (except for the Loop action). Delete an action item by clicking on the trash bin icon. If you are done editing your test and all the mandatory fields remain filled, click Save changes . Deleting tests # Read this section to learn how to delete tests. From the navigation menu, select Device test repository . From the list, select the tests you want to delete. There are two ways to delete the selected tests: Click the Actions drop-down menu and select Delete . Click the context menu on the right and select Delete . In the dialog that appears, click Delete . The test will be permanently deleted and you won't be able to recover it. Downloading tests # Read this section to learn how to export tests. From the navigation menu, select Device test repository . From the list, select the test(s) you want to export. There are two ways to download the selected tests: for batch export, click the Actions drop-down menu and select Download tests . for single test export, click the context menu on the right the test entry and select Download test . The tests are downloaded in the .conf format. Tip Edit the exported tests using Windows Notepad or other standard text editor. Previewing test # Select the test you want to preview. Click the context menu on the right and select Preview test .","title":"Configure tests"},{"location":"Device_tests/Configure_tests/#configure-tests","text":"","title":"Configure tests"},{"location":"Device_tests/Configure_tests/#introduction","text":"This chapter covers the configuration aspects of the device tests. It explains how to list and view the configuration of tests, and how to add, edit, delete, import, and export them. Note The configuration of tests is device-independent, which means that all the configured tests can be applied for all the devices that have registered to the platform.","title":"Introduction"},{"location":"Device_tests/Configure_tests/#device-test-repository-panel","text":"In this section you'll learn about the layout and main features of the Device test repository panel. To enter the panel, select Device test repository and then Server simulator in the navigation menu. Search \u2013 use it to search the test list. Filter - use it to filter tests either per domain or per test type (Automated or Semi-Manual). Add test \u2013 use it to add a test manually or import tests from a .conf file. 'Select all' checkbox \u2013 use it to select or deselect all tests visible in the list. Actions \u2013 drop-down menu \u2013 use it to download or delete selected tests. Actions \u2013 context menu - use it to preview, download, or delete selected tests. Test list \u2013 it features all the tests available for you at the moment, or all the tests meeting the search criteria (if entered). Test type \u2013 it shows the test type: either Automated or Semi-Manual. Domain name \u2013 it shows the names of domains and subdomains to which your test belong. Creation date \u2013 it shows the date when the test was created. Last modified \u2013 it shows the date when the test was last modified. Description \u2013 it shows a test description, if the test has any.","title":"Device test repository panel"},{"location":"Device_tests/Configure_tests/#listing-tests","text":"The tests appearing in the Device test repository panel are presented in the form of a searchable alphabetical list to ensure their convenient viewing and management. Read on this section to learn how to use the search to list your tests.","title":"Listing tests"},{"location":"Device_tests/Configure_tests/#using-the-search","text":"To search the list of configured tests, start typing your entry into the search field. The matching items will appear in the list. Tip Note that if you select a test from the filtered list and then erase your entry from the search field, the selection is carried over to the complete list view. Similarly, if you use the Select all checkbox in the full list view and then filter the list using the search, the selection is carried over to the filtered list view.","title":"Using the search"},{"location":"Device_tests/Configure_tests/#viewing-test-configuration","text":"Read this section to learn how to view the configuration of an individual test: From the navigation menu, select Device test repository . In the list, find the test you want to view and click its name. In the action list, expand the action items by clicking the \u02c5 icon. To expand or collapse the complete action list, use the Expand all and Collapse all buttons. Optionally, you can use the Edit test button to edit your test or click the trash bin icon to delete it.","title":"Viewing test configuration"},{"location":"Device_tests/Configure_tests/#adding-new-tests","text":"Read this section to learn how to add a new test. You can either add a test manually or import tests as a .conf file.","title":"Adding new tests"},{"location":"Device_tests/Configure_tests/#add-a-test-manually","text":"From the navigation menu, select Device test repository . Click Add test and select Add test manually Configure your test: Enter your Test name (this field is mandatory). Enter your Test description (this field is optional). Select your Reference device (this field is optional). You can either: type the exact device ID in the Reference device search field and hit Enter , click Select reference device and select your device from the list. If you can't see your device in the list, start typing its name in the search field to get matching results. In the Action list , specify your actions: To add your first action item, choose its name from the drop-down list, or type its name in the Specify action field. Within the action, fill in the mandatory attributes field. To add another action item, use the Add action button and specify your next action. To change the order of actions within the test, drag and drop the action item you want to move by using the drag icon. To copy an action item, click the copy icon (except for the Loop action). To delete an action item, click the trash bin icon. If your test is ready and all the mandatory fields are filled, click Add a new test . Note To learn more about individual test actions, see the Test action chapter.","title":"Add a test manually"},{"location":"Device_tests/Configure_tests/#import-tests-from-conf-file","text":"From the navigation menu, select Device test repository . Click Add test and select Import tests from .conf file . A dialogue box prompting you to import a .conf file appears. Add the file and click Import . Tip To download tests into a .conf file, check the Downloading tests section.","title":"Import tests from .conf file"},{"location":"Device_tests/Configure_tests/#editing-tests","text":"Read this section to learn how to edit a test. Note If you edit a test that was executed before, the existing historical results for this test will no longer be available. From the navigation menu, select Device test repository . From the list, choose the test you want to edit and click its name. Click Edit test in the top-right corner. Edit your test: Modify your Test name (this field is mandatory). Modify your Test description (this field is optional). Change or add your Reference device (this field is optional). You can either: type the exact device ID in the Reference device search field and hit Enter , click Select reference device and select your device from the list. If you can't see your device in the list, start typing its name in the search field to get matching results. In the Action list , edit your actions: Edit an existing action item by changing its name, modifying its attributes. Add another action item using the Add action button. Change the order of actions within the test by dragging and dropping the action item you want to move using the drag icon. Copy an action item by clicking on the copy icon (except for the Loop action). Delete an action item by clicking on the trash bin icon. If you are done editing your test and all the mandatory fields remain filled, click Save changes .","title":"Editing tests"},{"location":"Device_tests/Configure_tests/#deleting-tests","text":"Read this section to learn how to delete tests. From the navigation menu, select Device test repository . From the list, select the tests you want to delete. There are two ways to delete the selected tests: Click the Actions drop-down menu and select Delete . Click the context menu on the right and select Delete . In the dialog that appears, click Delete . The test will be permanently deleted and you won't be able to recover it.","title":"Deleting tests"},{"location":"Device_tests/Configure_tests/#downloading-tests","text":"Read this section to learn how to export tests. From the navigation menu, select Device test repository . From the list, select the test(s) you want to export. There are two ways to download the selected tests: for batch export, click the Actions drop-down menu and select Download tests . for single test export, click the context menu on the right the test entry and select Download test . The tests are downloaded in the .conf format. Tip Edit the exported tests using Windows Notepad or other standard text editor.","title":"Downloading tests"},{"location":"Device_tests/Configure_tests/#previewing-test","text":"Select the test you want to preview. Click the context menu on the right and select Preview test .","title":"Previewing test"},{"location":"Device_tests/Data_model_and_variables/","text":"Device data model and variables # Displaying device data model and running simple actions # Coiote DM gives you the possibility to view and perform actions on the data model of individual devices defined by the LwM2M protocol. This view is available under the Objects panel of your device. Read this chapter to learn how to use the panel. Search - use it to find a particular object. To find the object, type its name. If checked, the changes you make to device objects will be applied immediately. Otherwise, you will have to wait for the device to trigger action execution or use the Execute tasks button (for devices in non-queue mode). Note The Apply immediately option is only available for devices in non-queue mode. Use this button to add a new LwM2M object definition. Division into objects. The info icon - click it to see the object description. Managing instances: [A] - Use it to select another instance of an object if the object has instances. [B] - Use it to add a new instance if an object allows it. [C] - Use it to select another instance or remove it. Search - use it to find a particular resource. To find the resource, type its name. Use it to refresh data, track values (send an Observe task) and add additional attributes to a selected instance. Use it to refresh data, track values (send an Observe task) and add additional attributes to a selected object. The table with resources of an object instance. Note The icon displaying the status of execution is available after clicking on one of the action buttons located in the Actions column. If you click it, you will see additional information about execution. Use it to refresh the resource. Value tracking - use it to send an Observe task to the device and configure monitoring to collect data. Attributes - use it to edit resource attributes or add new ones. Use it to edit a value of a resource. Execute - use it to send an Execute task to the device. Click the icon next to the button to add additional parameters. Managing device variables # Use the Variables panel to add custom variables onto your device for the purpose of protocol tests and view the existing variables that the device has inherited. To enter the Variables panel, go to Device Management Center by clicking on a selected device name and choose the Variables tab. Important If the Variables tab is not visible in your Device Management Center , click the Configure visible tabs icon, drag and drop the Variables tab into the Selected tabs column, and click Confirm . The Custom device variables list shows the variables that belong to this particular device. To add a variable, click on Add , provide its name and value, and click Save . Note that every custom variable that you add will have the VARIABLE_ prefix. To delete a previously added variable, click the Trash bin icon and click Save . The Inherited variables list shows only the variables that the device inherits from the groups of devices that it belongs to. The list is view-only. To add a variable to this list, go to Device Groups and, in the Profiles panel, add an entry with the name beginning with VARIABLE_ . To search for variables in the table, use the search field above it. To export existing variables, click the Export button. A .variables file will be downloaded onto your local drive. To import variables, click the Import button. From your local drive, select a .variables file with variables. Any new variables contained in the file will be imported into the Custom device variables table Using variables in test actions # To use device variables, enter the expression context by typing ${variable.<variableName>} while defining a test action. Remember that each variable is treated as a string, therefore, to use it as a different data type, you will have to cast it to the appropriate type.\u2003 Using variables - example # Learn how to use device variables in Device tests in a few steps: Use case: Testing the WRITE action on the LwM2M Server.1.Lifetime resource. Add the variable: In Device inventory , click on a selected device name to enter its Device Management Center . Select the Variables tab. Tip If the Variables tab is not visible in the menu, use the settings button under the menu to add it: drag it from Available tabs and drop it in Selected tabs and click Confirm . Click on Add and provide the following: Name: lifetime120 . Value: 120 . Click Save . Create a test and include the new variable in the appropriate format: To add a new test, follow the steps in Creating your first test section, but including the adjustments below: For example purposes, pick only the Write action. In the Parameter name field, type LwM2M Server.1.Lifetime (note that the path may vary slightly depending on your device data model). In the Value field, type ${variable.lifetime120.toInt} . Tip By default, the variable value is rendered as a string data type. To cast it to the integer data type, .toInt suffix is added to the created expression, as seen above. Run the created test and check if the variable works correctly: To run the test, follow the steps in Running the test on device using the test created in the previous step. After the test is finished, check if the Lifetime resource value has changed on the device: Go to the Objects panel of your device and under the LwM2M Server object, look for the Lifetime resource value: If the value has changed accordingly, the variable can be now reused and populated to any other tests.","title":"Device data model and variables"},{"location":"Device_tests/Data_model_and_variables/#device-data-model-and-variables","text":"","title":"Device data model and variables"},{"location":"Device_tests/Data_model_and_variables/#displaying-device-data-model-and-running-simple-actions","text":"Coiote DM gives you the possibility to view and perform actions on the data model of individual devices defined by the LwM2M protocol. This view is available under the Objects panel of your device. Read this chapter to learn how to use the panel. Search - use it to find a particular object. To find the object, type its name. If checked, the changes you make to device objects will be applied immediately. Otherwise, you will have to wait for the device to trigger action execution or use the Execute tasks button (for devices in non-queue mode). Note The Apply immediately option is only available for devices in non-queue mode. Use this button to add a new LwM2M object definition. Division into objects. The info icon - click it to see the object description. Managing instances: [A] - Use it to select another instance of an object if the object has instances. [B] - Use it to add a new instance if an object allows it. [C] - Use it to select another instance or remove it. Search - use it to find a particular resource. To find the resource, type its name. Use it to refresh data, track values (send an Observe task) and add additional attributes to a selected instance. Use it to refresh data, track values (send an Observe task) and add additional attributes to a selected object. The table with resources of an object instance. Note The icon displaying the status of execution is available after clicking on one of the action buttons located in the Actions column. If you click it, you will see additional information about execution. Use it to refresh the resource. Value tracking - use it to send an Observe task to the device and configure monitoring to collect data. Attributes - use it to edit resource attributes or add new ones. Use it to edit a value of a resource. Execute - use it to send an Execute task to the device. Click the icon next to the button to add additional parameters.","title":"Displaying device data model and running simple actions"},{"location":"Device_tests/Data_model_and_variables/#managing-device-variables","text":"Use the Variables panel to add custom variables onto your device for the purpose of protocol tests and view the existing variables that the device has inherited. To enter the Variables panel, go to Device Management Center by clicking on a selected device name and choose the Variables tab. Important If the Variables tab is not visible in your Device Management Center , click the Configure visible tabs icon, drag and drop the Variables tab into the Selected tabs column, and click Confirm . The Custom device variables list shows the variables that belong to this particular device. To add a variable, click on Add , provide its name and value, and click Save . Note that every custom variable that you add will have the VARIABLE_ prefix. To delete a previously added variable, click the Trash bin icon and click Save . The Inherited variables list shows only the variables that the device inherits from the groups of devices that it belongs to. The list is view-only. To add a variable to this list, go to Device Groups and, in the Profiles panel, add an entry with the name beginning with VARIABLE_ . To search for variables in the table, use the search field above it. To export existing variables, click the Export button. A .variables file will be downloaded onto your local drive. To import variables, click the Import button. From your local drive, select a .variables file with variables. Any new variables contained in the file will be imported into the Custom device variables table","title":"Managing device variables"},{"location":"Device_tests/Data_model_and_variables/#using-variables-in-test-actions","text":"To use device variables, enter the expression context by typing ${variable.<variableName>} while defining a test action. Remember that each variable is treated as a string, therefore, to use it as a different data type, you will have to cast it to the appropriate type.","title":"Using variables in test actions"},{"location":"Device_tests/Data_model_and_variables/#using-variables-example","text":"Learn how to use device variables in Device tests in a few steps: Use case: Testing the WRITE action on the LwM2M Server.1.Lifetime resource. Add the variable: In Device inventory , click on a selected device name to enter its Device Management Center . Select the Variables tab. Tip If the Variables tab is not visible in the menu, use the settings button under the menu to add it: drag it from Available tabs and drop it in Selected tabs and click Confirm . Click on Add and provide the following: Name: lifetime120 . Value: 120 . Click Save . Create a test and include the new variable in the appropriate format: To add a new test, follow the steps in Creating your first test section, but including the adjustments below: For example purposes, pick only the Write action. In the Parameter name field, type LwM2M Server.1.Lifetime (note that the path may vary slightly depending on your device data model). In the Value field, type ${variable.lifetime120.toInt} . Tip By default, the variable value is rendered as a string data type. To cast it to the integer data type, .toInt suffix is added to the created expression, as seen above. Run the created test and check if the variable works correctly: To run the test, follow the steps in Running the test on device using the test created in the previous step. After the test is finished, check if the Lifetime resource value has changed on the device: Go to the Objects panel of your device and under the LwM2M Server object, look for the Lifetime resource value: If the value has changed accordingly, the variable can be now reused and populated to any other tests.","title":"Using variables - example"},{"location":"Device_tests/Getting_started/","text":"Getting started # Start using the Device tests feature right away. This short instruction will help you create your first test, run it on a device and see the execution logs. Prerequisites # A device that is added and registered in the platform. Create your first test # From the navigation menu on the left, select Device test repository and then Server simulator . Click Add test and select Add test manually . Configure your test: Provide a name for your test. Under the Action list , click Add action , select Write from the drop down list and provide data for the following fields: Parameter name : Device.0.Manufacturer , Expected value : Example_manufacturer , Expected response code : 4.05 MethodNotAllowed . Under the Action list , select Read from the drop down list and provide data for the following fields: Parameter name : LwM2M Server.1.Binding , Expected value : U , Expected response code : 2.05 Content . Click Add a new test . Run test on your device # In the Device inventory , select a currently registered device and enter its Device Management Center . In Device Management Center , select the Device tests tab. Note If the Device tests tab is not visible in the menu, use the settings button under the menu to add it: drag it from Available tabs and drop it in Selected tabs and click Confirm . Tick the test you have just created and click Run selected (1) . After a few moments, the execution ends and the test status should change from In progress to Success . Tip The Success status of a test measures the correctness of the device response against the expected test parameters. Depending on the device and tester's needs, there may be tests that are successful when the device responds with a Failure message (similarly to the example presented in this section). Check test execution details # To see execution logs for your tests: While in the Device tests panel, find your test and click its name. Expand the Logs section using the ^ arrow icon to see execution details. Use the Check logs button for each action inside the test to see the highlighted results for this action.","title":"Getting started"},{"location":"Device_tests/Getting_started/#getting-started","text":"Start using the Device tests feature right away. This short instruction will help you create your first test, run it on a device and see the execution logs.","title":"Getting started"},{"location":"Device_tests/Getting_started/#prerequisites","text":"A device that is added and registered in the platform.","title":"Prerequisites"},{"location":"Device_tests/Getting_started/#create-your-first-test","text":"From the navigation menu on the left, select Device test repository and then Server simulator . Click Add test and select Add test manually . Configure your test: Provide a name for your test. Under the Action list , click Add action , select Write from the drop down list and provide data for the following fields: Parameter name : Device.0.Manufacturer , Expected value : Example_manufacturer , Expected response code : 4.05 MethodNotAllowed . Under the Action list , select Read from the drop down list and provide data for the following fields: Parameter name : LwM2M Server.1.Binding , Expected value : U , Expected response code : 2.05 Content . Click Add a new test .","title":"Create your first test"},{"location":"Device_tests/Getting_started/#run-test-on-your-device","text":"In the Device inventory , select a currently registered device and enter its Device Management Center . In Device Management Center , select the Device tests tab. Note If the Device tests tab is not visible in the menu, use the settings button under the menu to add it: drag it from Available tabs and drop it in Selected tabs and click Confirm . Tick the test you have just created and click Run selected (1) . After a few moments, the execution ends and the test status should change from In progress to Success . Tip The Success status of a test measures the correctness of the device response against the expected test parameters. Depending on the device and tester's needs, there may be tests that are successful when the device responds with a Failure message (similarly to the example presented in this section).","title":"Run test on your device"},{"location":"Device_tests/Getting_started/#check-test-execution-details","text":"To see execution logs for your tests: While in the Device tests panel, find your test and click its name. Expand the Logs section using the ^ arrow icon to see execution details. Use the Check logs button for each action inside the test to see the highlighted results for this action.","title":"Check test execution details"},{"location":"Device_tests/Overview/","text":"Overview # Device tests are a comprehensive and convenient solution for the customization and performance of LwM2M protocol tests on LwM2M devices. Offered as part of the Coiote IoT Device Management platform, it enables you develop tests from scratch to tailor them to your devices, or use the ready-made test scenarios (including those described in the OMA Enabler Test Specification for Lightweight M2M by OMA SpecWorks and the scenarios created by AVSystem ). The following guide walks you through the basic functionalities of the device tests solution. You will learn how to configure, run and manage your tests and get to know in detail each possible action that can be defined within a test.","title":"Overview"},{"location":"Device_tests/Overview/#overview","text":"Device tests are a comprehensive and convenient solution for the customization and performance of LwM2M protocol tests on LwM2M devices. Offered as part of the Coiote IoT Device Management platform, it enables you develop tests from scratch to tailor them to your devices, or use the ready-made test scenarios (including those described in the OMA Enabler Test Specification for Lightweight M2M by OMA SpecWorks and the scenarios created by AVSystem ). The following guide walks you through the basic functionalities of the device tests solution. You will learn how to configure, run and manage your tests and get to know in detail each possible action that can be defined within a test.","title":"Overview"},{"location":"Device_tests/Run_tests/","text":"Run tests # If you have tests configured in the platform, you can run them on your device using the Device tests panel. Read this chapter to learn how to display test descriptions, start and stop test execution and view test results and logs. Device tests panel description # The Device tests panel is available in the Device Management Center individually for each device. To access it, select a device in Device Inventory to enter its Device Management Center and select Device tests from the menu on the left. Tip If the Device tests tab is not visible in the menu, use the Configure visible tabs button under the menu to add it: drag the tab from Available tabs , drop it in Selected tabs and click Confirm . Read this section to learn about the main components that it comprises. Test list \u2013 views all the tests available for a given device. It is searchable and can be filtered. Info icon \u2013 hover over this icon to see test description. 'Select all' checkbox \u2013 use this checkbox to select all items visible in the list. Note that if you filter or search the list, the previously made selection you will be kept nonetheless. In such a case, the number of selected tests visible in the Run selected button will be their total count, which may not correspond to the number of selections in your filtered list view. Status \u2013 use this field to filter your list view by test execution status. Type - use this field to filter your list view by test type ( Automated or Semi-manual ). Search \u2013 use this field to search among the listed tests by their name. Start typing to get matching results. Show report - use this button to view a summary of tests commissioned for your devices along with test success rate. To get the report in the CSV format, select the Download summary file button. 'Run selected (_)' button \u2013 use it to start the execution of previously selected tests. The number of tests to be run is shown in brackets. Displaying test description # Read this section to learn how to display details of tests. In Device Inventory , find your device in the list and click on its name. In Device Management Center , select the Device tests tab. Select a test and click on its name to enter the detailed view. Starting tests # Read this section to learn how to start the execution of tests on a device. In Device Inventory , find your device in the list and click on its name. In Device Management Center , select the Device tests tab. Select the tests you want to run and click Run selected (_) . Note Even if you leave the Device tests panel, tests once run will continue until all are finished or stopped. Stopping tests # Read this section to learn how to stop the execution of tests on a device. With the tests running, go to Device Inventory . Find your device in the list and click on its name. In Device Management Center , select the Device tests tab. Click the Cancel all tests button located inside the footer bar. Test execution will be stopped. Note Tests completed before you hit the Cancel all tests button will display their execution status. Test statuses and logs # Test statuses # Test statuses are labels attached to tests that help to identify their state in each stage of their execution. There are eight available test statuses: New \u2013 a test that has been recently added and has not been scheduled nor executed. NotScheduled \u2013 a test that has never been picked for execution. NotTested \u2013 a test that has been picked for execution, but its execution has not started due to some error or test execution interruption. Pending \u2013 a test whose execution is pending. In progress \u2013 a test whose execution is under way. Halted \u2013 a test whose execution is temporarily stopped. Warning \u2013 a test that has finished with error(s). Success \u2013 a test that has finished with success. Tip Statuses are available both for tests after execution as well as for individual actions inside a test. To view test results for individual actions, enter the finished test and see the action list. Test logs # Logs store detailed information on the test execution and can be displayed after its completion. To display the logs for an individual test, enter the test and click Check logs or expand the Logs list. If there are many logs from a selected period of time, use Scroll to the bottom and Scroll to the top links to navigate. If a log entry is long, not all lines are displayed at once. To see more lines, click the Show \u2026 lines/characters more link. To display only particular logs and logs of a higher level, use Show from level list . To wrap words of logs, select the Word wrap checkbox. To format messages in a more readable way, select the Format messages checkbox. To see which messages were received (green color) and which were sent (blue color), select the Color messages checkbox. To download logs from a particular period of time matching with used filters, click the Download button.","title":"Run tests"},{"location":"Device_tests/Run_tests/#run-tests","text":"If you have tests configured in the platform, you can run them on your device using the Device tests panel. Read this chapter to learn how to display test descriptions, start and stop test execution and view test results and logs.","title":"Run tests"},{"location":"Device_tests/Run_tests/#device-tests-panel-description","text":"The Device tests panel is available in the Device Management Center individually for each device. To access it, select a device in Device Inventory to enter its Device Management Center and select Device tests from the menu on the left. Tip If the Device tests tab is not visible in the menu, use the Configure visible tabs button under the menu to add it: drag the tab from Available tabs , drop it in Selected tabs and click Confirm . Read this section to learn about the main components that it comprises. Test list \u2013 views all the tests available for a given device. It is searchable and can be filtered. Info icon \u2013 hover over this icon to see test description. 'Select all' checkbox \u2013 use this checkbox to select all items visible in the list. Note that if you filter or search the list, the previously made selection you will be kept nonetheless. In such a case, the number of selected tests visible in the Run selected button will be their total count, which may not correspond to the number of selections in your filtered list view. Status \u2013 use this field to filter your list view by test execution status. Type - use this field to filter your list view by test type ( Automated or Semi-manual ). Search \u2013 use this field to search among the listed tests by their name. Start typing to get matching results. Show report - use this button to view a summary of tests commissioned for your devices along with test success rate. To get the report in the CSV format, select the Download summary file button. 'Run selected (_)' button \u2013 use it to start the execution of previously selected tests. The number of tests to be run is shown in brackets.","title":"Device tests panel description"},{"location":"Device_tests/Run_tests/#displaying-test-description","text":"Read this section to learn how to display details of tests. In Device Inventory , find your device in the list and click on its name. In Device Management Center , select the Device tests tab. Select a test and click on its name to enter the detailed view.","title":"Displaying test description"},{"location":"Device_tests/Run_tests/#starting-tests","text":"Read this section to learn how to start the execution of tests on a device. In Device Inventory , find your device in the list and click on its name. In Device Management Center , select the Device tests tab. Select the tests you want to run and click Run selected (_) . Note Even if you leave the Device tests panel, tests once run will continue until all are finished or stopped.","title":"Starting tests"},{"location":"Device_tests/Run_tests/#stopping-tests","text":"Read this section to learn how to stop the execution of tests on a device. With the tests running, go to Device Inventory . Find your device in the list and click on its name. In Device Management Center , select the Device tests tab. Click the Cancel all tests button located inside the footer bar. Test execution will be stopped. Note Tests completed before you hit the Cancel all tests button will display their execution status.","title":"Stopping tests"},{"location":"Device_tests/Run_tests/#test-statuses-and-logs","text":"","title":"Test statuses and logs"},{"location":"Device_tests/Run_tests/#test-statuses","text":"Test statuses are labels attached to tests that help to identify their state in each stage of their execution. There are eight available test statuses: New \u2013 a test that has been recently added and has not been scheduled nor executed. NotScheduled \u2013 a test that has never been picked for execution. NotTested \u2013 a test that has been picked for execution, but its execution has not started due to some error or test execution interruption. Pending \u2013 a test whose execution is pending. In progress \u2013 a test whose execution is under way. Halted \u2013 a test whose execution is temporarily stopped. Warning \u2013 a test that has finished with error(s). Success \u2013 a test that has finished with success. Tip Statuses are available both for tests after execution as well as for individual actions inside a test. To view test results for individual actions, enter the finished test and see the action list.","title":"Test statuses"},{"location":"Device_tests/Run_tests/#test-logs","text":"Logs store detailed information on the test execution and can be displayed after its completion. To display the logs for an individual test, enter the test and click Check logs or expand the Logs list. If there are many logs from a selected period of time, use Scroll to the bottom and Scroll to the top links to navigate. If a log entry is long, not all lines are displayed at once. To see more lines, click the Show \u2026 lines/characters more link. To display only particular logs and logs of a higher level, use Show from level list . To wrap words of logs, select the Word wrap checkbox. To format messages in a more readable way, select the Format messages checkbox. To see which messages were received (green color) and which were sent (blue color), select the Color messages checkbox. To download logs from a particular period of time matching with used filters, click the Download button.","title":"Test logs"},{"location":"Device_tests/Test_actions/","text":"Test actions # Introduction # Based on the LwM2M 1.0 standard protocol operations, Actions are steps that can be defined within a test. While some are used for the communication between the Server and the LwM2M test device, others help to define the test logic. Read this chapter to learn how to use Actions in the configuration of customizable device tests. Action attributes # All the available Actions are defined using a set of configurable attributes that you can specify while adding or editing a test. The attributes available under each action are determined by the type of given Action. However, to set up a test, not all attributes are mandatory. The general rule is that if you leave an optional attribute\u2019s field blank, the final test result won\u2019t be affected in any way. Tip if you would like to make the test device ignore a particular attribute so that it doesn\u2019t answer to the server request, type None in the optional attribute\u2019s field. Description of Actions # Within the Server simulator tests, the following Actions are available. READ # READ is used to access the value of an object, object instances, a resource and single resource instances. You can define it using four attributes: Parameter name \u2013 the name of the data model parameter you want to read. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Expected value \u2013 if the value you enter here equals the value read from the device, the test will be passed. If left blank, the value will only show up in the test log and it will have no impact on the test result. Note that this READ attribute works only for Resources and Resource Instances. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. LwM2M: Requested content format \u2013 the content format of the device answer that you request for your read operation. If the device doesn\u2019t support the requested format, the test will fail. If left blank, the device can decide what content format to use; any format will be accepted. WRITE # WRITE is used to change the value of a Resource. You can define it using four attributes: Parameter name \u2013 the name of the data model parameter for which you want to set a new value or overwrite the existing one. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Value \u2013 the value you enter here sets a new value or overwrites the existing one. If left blank, the existing value will be kept and the test will be passed. LwM2M: Content format \u2013 the content format in which you send the write request to the device. If the device doesn\u2019t support the specified format, the test will fail. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. EXECUTE # EXECUTE is used to initiate some action and can only be performed on individual Resources. If the device receives an EXECUTE for an Object Instance(s) or Resource Instance(s), it will return an error. You can define it using two attributes: Parameter name \u2013 the name of the data model parameter for which you will issue an execute. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Execute arguments \u2013 the execution arguments passed to the device expressed in Plain Text format. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. DISCOVER # DISCOVER is used to discover LwM2M Attributes attached to an Object, Object Instances, and Resources. You can define it using two attributes: Parameter name \u2013 the name of the data model parameter whose attributes you want to discover. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. DELETE # DELETE is used for the server to delete an Object Instance within the LwM2M Client. Note that an Object Instance to be deleted must be an Object Instance that is announced by the Client to the Server using the Register and Update operations of the Client Registration Interface. Object instance \u2013 the object instance that you want to delete. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0) or the numerical (e.g. 3.0) value of the parameter. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. CREATE # CREATE is used by the Server simulator to create Object Instance(s) within the LwM2M Client. You can define the action using three parameters and a set of Object Instance-dependent values: Object ID or name \u2013 the Object that you want to create an Instance for. Note that it can be specified either using the full name in the string (e.g. \u2018Portfolio\u2019) or the numerical (e.g. \u201816\u2019) value of the parameter. LwM2M: Instance number \u2013 the number assigned to the Object Instance to be created. If left blank, the number will be chosen by the device. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. Resources \u2013 click the Provide initial values button to view and specify the possible Resources and Resource Instances of the Object Instance to be created. Note that if the values marked as required are left blank, the action will fail for devices that correctly implement LwM2M. WRITE ATTRIBUTES # WRITE ATTRIBUTES is used to attach metadata containing parameters for Notifications to an Object, an Object Instance or a Resource. You can define it using seven attributes: Parameter name \u2013 the name of the data model parameter for which you will write attributes. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. Minimum period \u2013 the minimum time in seconds that the device waits between two notifications. Maximum period \u2013 the minimum time in seconds that the device waits between two notifications. Value greater than \u2013 notifications will be sent only when the monitored value crosses the threshold you set here. However, please note that the interpretation of this parameter may differ depending on the specific LwM2M Client implementation. Value less than \u2013 notifications will be sent only when the monitored value crosses the threshold you set here. However, please note that the interpretation of this parameter may differ depending on the specific LwM2M Client implementation. Step \u2013 the minimum change value between two notifications. CLEAR ATTRIBUTES # CLEAR ATTRIBUTES is used to clear the metadata attached to an Object, an Object Instance or a Resource which contain parameters for Notifications. You can define it using seven attributes: Parameter name \u2013 the name of the data model parameter for which you will clear attributes. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. Clear minimum period \u2013 if set to true, it clears the minimum time in seconds between two notifications. If set to false, the value is kept. Clear maximum period \u2013 if set to true, it clears the maximum time set between two notifications. If set to false, the value is kept. Clear value greater than \u2013 if set to true, it clears the threshold set for the monitored value. If set to false, the value is kept. Clear value less than \u2013 if set to true, it clears the threshold set for the monitored value. If set to false, the value is kept. Clear step \u2013 if set to true, it clears the minimum change value between two notifications. If set to false, the value is kept. OBSERVE # OBSERVE is used to initiate an observation request for changes of a specific Resource, Resources within an Object Instance or for all the Object Instances of an Object. You can define it using four attributes: Parameter name \u2013 the name of the data model parameter whose value(s) you will observe. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. Fail if already observed \u2013 if set to true, the test will fail in case there is an existing observation set on this parameter. In case there is no observation set, your observe request should be accepted and the test won\u2019t fail. If set to false, any existing observations will be cancelled and requested again by this one and the test will be passed. LwM2M: Content format \u2013 the content format in which you send the OBSERVE request to the device. If the device doesn\u2019t support the specified format, the test will fail. CANCEL OBSERVE # CANCEL OBSERVE is used to cancel an observation. You can define it using three attributes: Parameter name \u2013 the name of the data model parameter for which you will cancel an existing observation. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Cancel type \u2013 the mode in which the CANCEL OBSERVE will be sent to the device. o ACTIVE - CANCEL OBSERVE is sent to the device immediately. o PASSIVE - CoAP RESET is sent in response to the next notification message received from the device. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. Firmware Update # Firmware Update is used to perform a firmware update operation on the test device. You can define it using five attributes: Firmware \u2013 the ID of the resource used as the firmware source. Update timeout \u2013 the time period in seconds within which the firmware update should be completed. In case the timeout is up and the update process has not finished, the action will fail. Delivery method \u2013 The protocol and transfer method used to deliver the firmware file to the device. Use notifications \u2013 if set to true, an OBSERVE will be issued automatically for the \u2018State\u2019 and \u2018Update result\u2019 parameters while upgrading the device. The notifications returned by the device will be visible in the test logs. Expected update result \u2013 if the update result you enter here equals the result returned by the device, the test will be passed. If left blank, the server will expect the default result defined by the LwM2M standard. You can choose among the ten update results defined as per the LwM2M protocol specification. WAIT # Wait is used to set the waiting time before executing the next action. You can define it using two attributes: Waiting time \u2013 the interval set before the next action is executed. In progress message \u2013 a custom text that will be displayed as the test progress message while waiting for the execution of the next action. Pause response # Pause response is used to delay a response to be sent to the device. If set, the server will wait before sending the response until the Send paused response action is executed. Request type \u2013 the kind of request for which you want to pause the response. Wait for uplink request # Wait for uplink request is used to prevent the server from executing any tasks or actions until an uplink request arrives from the device. You can define the action using three attributes: Request type to wait for \u2013 the kind of request you want to wait for. Timeout \u2013 the time period in seconds within which the uplink request should arrive. In case the timeout is up with no request, the action will fail. Waiting message \u2013 the message displayed during the test execution while waiting for the arrival of the uplink request. Send paused response # Send paused response is used to send the previously paused response to the device. Request type \u2013 the kind of request for which you want to send the previously paused response. Start Notification recording # Start Notification recording is used to make the Server simulator save all notifications received from the device in its memory. The limit of recorded notifications can be configured using the ddscNotificationRecordingLimit setting value. Once the limit is reached, new notifications are not recorded. Execute the Start Notification recording action again in the same test to clear the recording state and to be able to match more notifications than the recording limit. Expect Notification # Expect Notification is used to check if recorded Notifications match the required criteria. You can define it using five attributes: Expected path \u2013 only notifications that were received on this path will be validated. In case of a notification with multiple paths and values, each path and value are treated as separate notifications. Expected value \u2013 use it to check if there is any notification that has a given value and matches all other criteria. Expected arrival order \u2013 use it to limit the validation only to one notification on a given path that arrived in a given order since the last Start Notification recording action. Note that the counting starts from 0 and that the Observe response is also counted if it is executed after the recording action started. Timeout \u2013 if the expected notification does not arrive within this time limit, the action will fail. Waiting message \u2013 a custom text that will be displayed as the test progress message while waiting for the action execution. Start Send recording # Start Send recording is used to make the Server simulator save all Send messages sent from device in its memory. The limit of recorded Send messages can be configured using the ddscSendRecordingLimit setting value. Once the limit is reached, new Send messages are not recorded. Execute the Start Send recording action again in the same test to clear the recording state and to be able to match more Send messages than the recording limit. Expect Send # Expect Send is used to check if recorded Send messages match the required criteria. You can define it using five attributes: Expected path \u2013 only Send messages that were received on this path will be validated. In case of a Send message with multiple paths and values, each path and value are treated as separate messages. Expected value \u2013 use it to check if there is any Send message that has a given value and matches all other criteria. Expected arrival order \u2013 use it to limit the validation only to one Send message on a given path that was sent in a given order since the last Start Send recording action. Timeout \u2013 if the expected Send message does not arrive within this time limit, the action fails. Waiting message \u2013 a custom text that is displayed as the test progress message while waiting for the action execution. Loop start # Loop start is used to repeat an action or a set of actions within a test. Note that when configuring the first action inside the loop, the Loop end action is added automatically. Repetitions \u2013 the number of iterations of action(s) inside the loop.","title":"Test actions"},{"location":"Device_tests/Test_actions/#test-actions","text":"","title":"Test actions"},{"location":"Device_tests/Test_actions/#introduction","text":"Based on the LwM2M 1.0 standard protocol operations, Actions are steps that can be defined within a test. While some are used for the communication between the Server and the LwM2M test device, others help to define the test logic. Read this chapter to learn how to use Actions in the configuration of customizable device tests.","title":"Introduction"},{"location":"Device_tests/Test_actions/#action-attributes","text":"All the available Actions are defined using a set of configurable attributes that you can specify while adding or editing a test. The attributes available under each action are determined by the type of given Action. However, to set up a test, not all attributes are mandatory. The general rule is that if you leave an optional attribute\u2019s field blank, the final test result won\u2019t be affected in any way. Tip if you would like to make the test device ignore a particular attribute so that it doesn\u2019t answer to the server request, type None in the optional attribute\u2019s field.","title":"Action attributes"},{"location":"Device_tests/Test_actions/#description-of-actions","text":"Within the Server simulator tests, the following Actions are available.","title":"Description of Actions"},{"location":"Device_tests/Test_actions/#read","text":"READ is used to access the value of an object, object instances, a resource and single resource instances. You can define it using four attributes: Parameter name \u2013 the name of the data model parameter you want to read. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Expected value \u2013 if the value you enter here equals the value read from the device, the test will be passed. If left blank, the value will only show up in the test log and it will have no impact on the test result. Note that this READ attribute works only for Resources and Resource Instances. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. LwM2M: Requested content format \u2013 the content format of the device answer that you request for your read operation. If the device doesn\u2019t support the requested format, the test will fail. If left blank, the device can decide what content format to use; any format will be accepted.","title":"READ"},{"location":"Device_tests/Test_actions/#write","text":"WRITE is used to change the value of a Resource. You can define it using four attributes: Parameter name \u2013 the name of the data model parameter for which you want to set a new value or overwrite the existing one. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Value \u2013 the value you enter here sets a new value or overwrites the existing one. If left blank, the existing value will be kept and the test will be passed. LwM2M: Content format \u2013 the content format in which you send the write request to the device. If the device doesn\u2019t support the specified format, the test will fail. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard.","title":"WRITE"},{"location":"Device_tests/Test_actions/#execute","text":"EXECUTE is used to initiate some action and can only be performed on individual Resources. If the device receives an EXECUTE for an Object Instance(s) or Resource Instance(s), it will return an error. You can define it using two attributes: Parameter name \u2013 the name of the data model parameter for which you will issue an execute. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Execute arguments \u2013 the execution arguments passed to the device expressed in Plain Text format. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard.","title":"EXECUTE"},{"location":"Device_tests/Test_actions/#discover","text":"DISCOVER is used to discover LwM2M Attributes attached to an Object, Object Instances, and Resources. You can define it using two attributes: Parameter name \u2013 the name of the data model parameter whose attributes you want to discover. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard.","title":"DISCOVER"},{"location":"Device_tests/Test_actions/#delete","text":"DELETE is used for the server to delete an Object Instance within the LwM2M Client. Note that an Object Instance to be deleted must be an Object Instance that is announced by the Client to the Server using the Register and Update operations of the Client Registration Interface. Object instance \u2013 the object instance that you want to delete. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0) or the numerical (e.g. 3.0) value of the parameter. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard.","title":"DELETE"},{"location":"Device_tests/Test_actions/#create","text":"CREATE is used by the Server simulator to create Object Instance(s) within the LwM2M Client. You can define the action using three parameters and a set of Object Instance-dependent values: Object ID or name \u2013 the Object that you want to create an Instance for. Note that it can be specified either using the full name in the string (e.g. \u2018Portfolio\u2019) or the numerical (e.g. \u201816\u2019) value of the parameter. LwM2M: Instance number \u2013 the number assigned to the Object Instance to be created. If left blank, the number will be chosen by the device. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. Resources \u2013 click the Provide initial values button to view and specify the possible Resources and Resource Instances of the Object Instance to be created. Note that if the values marked as required are left blank, the action will fail for devices that correctly implement LwM2M.","title":"CREATE"},{"location":"Device_tests/Test_actions/#write-attributes","text":"WRITE ATTRIBUTES is used to attach metadata containing parameters for Notifications to an Object, an Object Instance or a Resource. You can define it using seven attributes: Parameter name \u2013 the name of the data model parameter for which you will write attributes. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. Minimum period \u2013 the minimum time in seconds that the device waits between two notifications. Maximum period \u2013 the minimum time in seconds that the device waits between two notifications. Value greater than \u2013 notifications will be sent only when the monitored value crosses the threshold you set here. However, please note that the interpretation of this parameter may differ depending on the specific LwM2M Client implementation. Value less than \u2013 notifications will be sent only when the monitored value crosses the threshold you set here. However, please note that the interpretation of this parameter may differ depending on the specific LwM2M Client implementation. Step \u2013 the minimum change value between two notifications.","title":"WRITE ATTRIBUTES"},{"location":"Device_tests/Test_actions/#clear-attributes","text":"CLEAR ATTRIBUTES is used to clear the metadata attached to an Object, an Object Instance or a Resource which contain parameters for Notifications. You can define it using seven attributes: Parameter name \u2013 the name of the data model parameter for which you will clear attributes. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. Clear minimum period \u2013 if set to true, it clears the minimum time in seconds between two notifications. If set to false, the value is kept. Clear maximum period \u2013 if set to true, it clears the maximum time set between two notifications. If set to false, the value is kept. Clear value greater than \u2013 if set to true, it clears the threshold set for the monitored value. If set to false, the value is kept. Clear value less than \u2013 if set to true, it clears the threshold set for the monitored value. If set to false, the value is kept. Clear step \u2013 if set to true, it clears the minimum change value between two notifications. If set to false, the value is kept.","title":"CLEAR ATTRIBUTES"},{"location":"Device_tests/Test_actions/#observe","text":"OBSERVE is used to initiate an observation request for changes of a specific Resource, Resources within an Object Instance or for all the Object Instances of an Object. You can define it using four attributes: Parameter name \u2013 the name of the data model parameter whose value(s) you will observe. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard. Fail if already observed \u2013 if set to true, the test will fail in case there is an existing observation set on this parameter. In case there is no observation set, your observe request should be accepted and the test won\u2019t fail. If set to false, any existing observations will be cancelled and requested again by this one and the test will be passed. LwM2M: Content format \u2013 the content format in which you send the OBSERVE request to the device. If the device doesn\u2019t support the specified format, the test will fail.","title":"OBSERVE"},{"location":"Device_tests/Test_actions/#cancel-observe","text":"CANCEL OBSERVE is used to cancel an observation. You can define it using three attributes: Parameter name \u2013 the name of the data model parameter for which you will cancel an existing observation. Note that it can be specified either using the full name in the string (e.g. \u2018Device.0.Manufacturer) or the numerical (e.g. 3.0.1) value of the parameter. Cancel type \u2013 the mode in which the CANCEL OBSERVE will be sent to the device. o ACTIVE - CANCEL OBSERVE is sent to the device immediately. o PASSIVE - CoAP RESET is sent in response to the next notification message received from the device. Expected response code \u2013 if the response code you enter here equals the response code returned by the device, the test will be passed. If left blank, the server will expect the default response code defined by the LwM2M standard.","title":"CANCEL OBSERVE"},{"location":"Device_tests/Test_actions/#firmware-update","text":"Firmware Update is used to perform a firmware update operation on the test device. You can define it using five attributes: Firmware \u2013 the ID of the resource used as the firmware source. Update timeout \u2013 the time period in seconds within which the firmware update should be completed. In case the timeout is up and the update process has not finished, the action will fail. Delivery method \u2013 The protocol and transfer method used to deliver the firmware file to the device. Use notifications \u2013 if set to true, an OBSERVE will be issued automatically for the \u2018State\u2019 and \u2018Update result\u2019 parameters while upgrading the device. The notifications returned by the device will be visible in the test logs. Expected update result \u2013 if the update result you enter here equals the result returned by the device, the test will be passed. If left blank, the server will expect the default result defined by the LwM2M standard. You can choose among the ten update results defined as per the LwM2M protocol specification.","title":"Firmware Update"},{"location":"Device_tests/Test_actions/#wait","text":"Wait is used to set the waiting time before executing the next action. You can define it using two attributes: Waiting time \u2013 the interval set before the next action is executed. In progress message \u2013 a custom text that will be displayed as the test progress message while waiting for the execution of the next action.","title":"WAIT"},{"location":"Device_tests/Test_actions/#pause-response","text":"Pause response is used to delay a response to be sent to the device. If set, the server will wait before sending the response until the Send paused response action is executed. Request type \u2013 the kind of request for which you want to pause the response.","title":"Pause response"},{"location":"Device_tests/Test_actions/#wait-for-uplink-request","text":"Wait for uplink request is used to prevent the server from executing any tasks or actions until an uplink request arrives from the device. You can define the action using three attributes: Request type to wait for \u2013 the kind of request you want to wait for. Timeout \u2013 the time period in seconds within which the uplink request should arrive. In case the timeout is up with no request, the action will fail. Waiting message \u2013 the message displayed during the test execution while waiting for the arrival of the uplink request.","title":"Wait for uplink request"},{"location":"Device_tests/Test_actions/#send-paused-response","text":"Send paused response is used to send the previously paused response to the device. Request type \u2013 the kind of request for which you want to send the previously paused response.","title":"Send paused response"},{"location":"Device_tests/Test_actions/#start-notification-recording","text":"Start Notification recording is used to make the Server simulator save all notifications received from the device in its memory. The limit of recorded notifications can be configured using the ddscNotificationRecordingLimit setting value. Once the limit is reached, new notifications are not recorded. Execute the Start Notification recording action again in the same test to clear the recording state and to be able to match more notifications than the recording limit.","title":"Start Notification recording"},{"location":"Device_tests/Test_actions/#expect-notification","text":"Expect Notification is used to check if recorded Notifications match the required criteria. You can define it using five attributes: Expected path \u2013 only notifications that were received on this path will be validated. In case of a notification with multiple paths and values, each path and value are treated as separate notifications. Expected value \u2013 use it to check if there is any notification that has a given value and matches all other criteria. Expected arrival order \u2013 use it to limit the validation only to one notification on a given path that arrived in a given order since the last Start Notification recording action. Note that the counting starts from 0 and that the Observe response is also counted if it is executed after the recording action started. Timeout \u2013 if the expected notification does not arrive within this time limit, the action will fail. Waiting message \u2013 a custom text that will be displayed as the test progress message while waiting for the action execution.","title":"Expect Notification"},{"location":"Device_tests/Test_actions/#start-send-recording","text":"Start Send recording is used to make the Server simulator save all Send messages sent from device in its memory. The limit of recorded Send messages can be configured using the ddscSendRecordingLimit setting value. Once the limit is reached, new Send messages are not recorded. Execute the Start Send recording action again in the same test to clear the recording state and to be able to match more Send messages than the recording limit.","title":"Start Send recording"},{"location":"Device_tests/Test_actions/#expect-send","text":"Expect Send is used to check if recorded Send messages match the required criteria. You can define it using five attributes: Expected path \u2013 only Send messages that were received on this path will be validated. In case of a Send message with multiple paths and values, each path and value are treated as separate messages. Expected value \u2013 use it to check if there is any Send message that has a given value and matches all other criteria. Expected arrival order \u2013 use it to limit the validation only to one Send message on a given path that was sent in a given order since the last Start Send recording action. Timeout \u2013 if the expected Send message does not arrive within this time limit, the action fails. Waiting message \u2013 a custom text that is displayed as the test progress message while waiting for the action execution.","title":"Expect Send"},{"location":"Device_tests/Test_actions/#loop-start","text":"Loop start is used to repeat an action or a set of actions within a test. Note that when configuring the first action inside the loop, the Loop end action is added automatically. Repetitions \u2013 the number of iterations of action(s) inside the loop.","title":"Loop start"},{"location":"Device_tests/Use_API_Jenkins_integration/","text":"Jenkins/GitLab integration with device tests API # If you would like to automate your device tests, you can use the Coiote DM API and integrate it with a CI/CD environment like Jenkins or GitLab. Follow the guide below to learn how to configure the integration, run tests and summarize your test execution using these tools. Note The following instruction is based on integration with Jenkins. To integrate with GitLab, you can follow the same steps, but with slight adjustments - for details, please see subsection on GitLab . Prerequisites # An active Jenkins and GitLab account. A Git project repository. A working Coiote DM installation and a port for communication with the installation API. A device registered in the platform (if the tests require the device to be registered). A Coiote DM user with access to the device and the appropriate API permissions. Jenkins - standard pipeline # Set up standard pipeline # Upload a file with python script used to run tests to your project repository: Edit the following python script where required to adjust it to your environment (remember to select the appropriate tab with script depending on whether you want to run your tests on a single device or a device group). Device #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_NAME = \"test-device\" # type the endpoint name of your device. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the device. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/device/\" + DEVICE_NAME REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/device/\" + DEVICE_NAME PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = result . json ()[ \"waitingForExecution\" ] time . sleep ( 15 ) for test in result . json ()[ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Group #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_GROUP = \"root.mt.embedded.devicetypes.test.demo_client.2_9_0\" # type the name of your device group. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the group. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/group/\" + DEVICE_GROUP REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/group/\" + DEVICE_GROUP PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : still_running = 0 result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) exit ( 1 ) for device in result . json (): if not ( result . json ()[ device ][ \"waitingForExecution\" ] == []): still_running += 1 if ( still_running == 0 ): tests_running = False time . sleep ( 15 ) for device in result . json (): for test in result . json ()[ device ][ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ device ][ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ device ][ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Save the script as a .py file and upload it to your project repository. Create a pipeline for your project: Go to your Jenkins account and in the Dashboard view, select New Item from the menu on the left. Enter a name for your pipeline, select Pipeline , and confirm by clicking OK . Configure your pipeline: Go to your newly created pipeline and select Configure from the menu on the left. In the Source Code Management section, select the Git option and provide the following: Repository URL - enter the URL address of your GitLab repository that hosts the python script file from Step 1 . Credentials - add the user name and password of your git repository account. Branch Specifier - choose the GitLab branch you want to use in the pipeline. In the Build section, select the Execute Shell option from the drop-down list and provide the command to run the python script file from Step 1 : python3 example_filename.py Additionally, in the Post-build Actions section, select the Publish Junit test result report to set up test result report generation: Depending on your preferences, check or uncheck the Allow empty results option. Click Save . Run standard pipeline # Enter pipeline and select Build Now . Note Remember to check if the device you run the tests for is connected and registered in Coiote DM. Once the tests are performed, you will see your build status along with a graph reporting the execution status for each test. Jenkins multibranch pipeline # Set up multibranch pipeline # Alternatively to the standard pipeline, you may configure a multibranch pipeline to run your tests. Upload the Jenkinsfile that will define your multibranch pipeline to your project repository: Edit the script where required to adjust it to your environment: Note Remember to change the name example_filename.py to your custom name that you will choose in Step 2 . pipeline { options { disableConcurrentBuilds () } agent any stages { stage ( 'protocol_tests' ) { steps { sh 'python3 example_filename.py' } } } post { always { junit \"report.xml\" archiveArtifacts artifacts : 'report.xml' } cleanup { script { clean () } } } } Save the file as Jenkinsfile and upload it to the chosen branch of your project repository. Upload a file with python script used to run tests to your project repository: Edit the following python script where required to adjust it to your environment (remember to select the appropriate tab with script depending on whether you want to run your tests on a single device or a device group). Device #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_NAME = \"test-device\" # type the endpoint name of your device. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the device. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/device/\" + DEVICE_NAME REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/device/\" + DEVICE_NAME PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = result . json ()[ \"waitingForExecution\" ] time . sleep ( 15 ) for test in result . json ()[ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Group #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_GROUP = \"root.mt.embedded.devicetypes.test.demo_client.2_9_0\" # type the name of your device group. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the group. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/group/\" + DEVICE_GROUP REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/group/\" + DEVICE_GROUP PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : still_running = 0 result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) exit ( 1 ) for device in result . json (): if not ( result . json ()[ device ][ \"waitingForExecution\" ] == []): still_running += 1 if ( still_running == 0 ): tests_running = False time . sleep ( 15 ) for device in result . json (): for test in result . json ()[ device ][ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ device ][ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ device ][ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Save the script as a .py file (using the filename specified in the Jenkinsfile in the previous step) and upload it to your project repository. Create a pipeline for your project: Go to your Jenkins account and in the Dashboard view, select New Item from the menu on the left. Enter a name for your pipeline, select Multibranch Pipeline and confirm by clicking OK . Configure your pipeline: Go to your newly created pipeline and select Configure from the menu on the left. In the Branch Sources section, select the Git option and provide the following: Project Repository - enter the URL address of your project repository that hosts the Jenkinsfile and the python script file from Step 2 . Credentials - add the user name and password of your GitLab account. In the Build Configuration section, select the by Jenkinsfile mode from the drop-down list and provide the GitLab path to the Jenkinsfile from Step 1 (if the file is located in the GitLab root folder, it is enough to type Jenkinsfile ) Click Save . Run multibranch pipeline # Before running the tests for a chosen branch, you have to perform a scan to detect available branches (those with a Jenkinsfile ): Go to your multibranch pipeline and select Scan Multibranch Pipeline Now option from the menu on the left. Once the scan is completed, you will see a list of available branches. Enter a chosen branch by clicking on its name and select Build Now . Note Remember to check if the device you run the tests for is connected and registered in Coiote DM. Once the tests are performed, you will see your build status along with a graph reporting the execution status for each test. GitLab - configure and run pipeline # Coiote DM interop tests API can also be integrated with GitLab using the GitLab's CI/CD toolset. Here is how to do it: Upload the gitlab-ci.yml file that will define your GitLab pipeline to your project repository: Edit the script where required to adjust it to your environment: Note Remember to change the name example_filename.py to your custom name that you will choose in the next step. Also, keep in mind that running a pipeline in GitLab requires a docker image of a Linux distribution (or any operating system that can run python script). image : name : example.repository.com/docker-local/linux_image protocol-tests : stage : test script : - python3 example_filename.py artifacts : when : always paths : - report.xml reports : junit : report.xml Save the file as gitlab-ci.yml and upload it to the chosen branch of your project repository. Follow Step 2 from Creating a Jenkins multibranch pipeline (uploading a file with python script to your GitLab repository). Run a created pipeline for your project: Go to your GitLab project and in the Dashboard view, select CI/CD from the menu on the left and click Pipelines . Attention Note that to be able to run a pipeline, you will need to have the GitLab CI/CD toolset configured. For details, please check https://docs.gitlab.com/ee/ci/introduction/index.html . You should be able to see the branch with the uploaded gitlab-ci.yml file. Select the Run pipeline button, then confirm again by clicking Run pipeline . Once the pipeline execution is finished, you should be able to see the results in the Tests tab of your pipeline. Note Viewing graphs with test results is not supported in GitLab by default as it requires additional plugins.","title":"Jenkins/GitLab integration with device tests API"},{"location":"Device_tests/Use_API_Jenkins_integration/#jenkinsgitlab-integration-with-device-tests-api","text":"If you would like to automate your device tests, you can use the Coiote DM API and integrate it with a CI/CD environment like Jenkins or GitLab. Follow the guide below to learn how to configure the integration, run tests and summarize your test execution using these tools. Note The following instruction is based on integration with Jenkins. To integrate with GitLab, you can follow the same steps, but with slight adjustments - for details, please see subsection on GitLab .","title":"Jenkins/GitLab integration with device tests API"},{"location":"Device_tests/Use_API_Jenkins_integration/#prerequisites","text":"An active Jenkins and GitLab account. A Git project repository. A working Coiote DM installation and a port for communication with the installation API. A device registered in the platform (if the tests require the device to be registered). A Coiote DM user with access to the device and the appropriate API permissions.","title":"Prerequisites"},{"location":"Device_tests/Use_API_Jenkins_integration/#jenkins-standard-pipeline","text":"","title":"Jenkins - standard pipeline"},{"location":"Device_tests/Use_API_Jenkins_integration/#set-up-standard-pipeline","text":"Upload a file with python script used to run tests to your project repository: Edit the following python script where required to adjust it to your environment (remember to select the appropriate tab with script depending on whether you want to run your tests on a single device or a device group). Device #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_NAME = \"test-device\" # type the endpoint name of your device. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the device. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/device/\" + DEVICE_NAME REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/device/\" + DEVICE_NAME PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = result . json ()[ \"waitingForExecution\" ] time . sleep ( 15 ) for test in result . json ()[ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Group #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_GROUP = \"root.mt.embedded.devicetypes.test.demo_client.2_9_0\" # type the name of your device group. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the group. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/group/\" + DEVICE_GROUP REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/group/\" + DEVICE_GROUP PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : still_running = 0 result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) exit ( 1 ) for device in result . json (): if not ( result . json ()[ device ][ \"waitingForExecution\" ] == []): still_running += 1 if ( still_running == 0 ): tests_running = False time . sleep ( 15 ) for device in result . json (): for test in result . json ()[ device ][ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ device ][ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ device ][ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Save the script as a .py file and upload it to your project repository. Create a pipeline for your project: Go to your Jenkins account and in the Dashboard view, select New Item from the menu on the left. Enter a name for your pipeline, select Pipeline , and confirm by clicking OK . Configure your pipeline: Go to your newly created pipeline and select Configure from the menu on the left. In the Source Code Management section, select the Git option and provide the following: Repository URL - enter the URL address of your GitLab repository that hosts the python script file from Step 1 . Credentials - add the user name and password of your git repository account. Branch Specifier - choose the GitLab branch you want to use in the pipeline. In the Build section, select the Execute Shell option from the drop-down list and provide the command to run the python script file from Step 1 : python3 example_filename.py Additionally, in the Post-build Actions section, select the Publish Junit test result report to set up test result report generation: Depending on your preferences, check or uncheck the Allow empty results option. Click Save .","title":"Set up standard pipeline"},{"location":"Device_tests/Use_API_Jenkins_integration/#run-standard-pipeline","text":"Enter pipeline and select Build Now . Note Remember to check if the device you run the tests for is connected and registered in Coiote DM. Once the tests are performed, you will see your build status along with a graph reporting the execution status for each test.","title":"Run standard pipeline"},{"location":"Device_tests/Use_API_Jenkins_integration/#jenkins-multibranch-pipeline","text":"","title":"Jenkins multibranch pipeline"},{"location":"Device_tests/Use_API_Jenkins_integration/#set-up-multibranch-pipeline","text":"Alternatively to the standard pipeline, you may configure a multibranch pipeline to run your tests. Upload the Jenkinsfile that will define your multibranch pipeline to your project repository: Edit the script where required to adjust it to your environment: Note Remember to change the name example_filename.py to your custom name that you will choose in Step 2 . pipeline { options { disableConcurrentBuilds () } agent any stages { stage ( 'protocol_tests' ) { steps { sh 'python3 example_filename.py' } } } post { always { junit \"report.xml\" archiveArtifacts artifacts : 'report.xml' } cleanup { script { clean () } } } } Save the file as Jenkinsfile and upload it to the chosen branch of your project repository. Upload a file with python script used to run tests to your project repository: Edit the following python script where required to adjust it to your environment (remember to select the appropriate tab with script depending on whether you want to run your tests on a single device or a device group). Device #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_NAME = \"test-device\" # type the endpoint name of your device. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the device. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/device/\" + DEVICE_NAME REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/device/\" + DEVICE_NAME PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = result . json ()[ \"waitingForExecution\" ] time . sleep ( 15 ) for test in result . json ()[ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Group #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_GROUP = \"root.mt.embedded.devicetypes.test.demo_client.2_9_0\" # type the name of your device group. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the group. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/group/\" + DEVICE_GROUP REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/group/\" + DEVICE_GROUP PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : still_running = 0 result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) exit ( 1 ) for device in result . json (): if not ( result . json ()[ device ][ \"waitingForExecution\" ] == []): still_running += 1 if ( still_running == 0 ): tests_running = False time . sleep ( 15 ) for device in result . json (): for test in result . json ()[ device ][ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ device ][ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ device ][ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Save the script as a .py file (using the filename specified in the Jenkinsfile in the previous step) and upload it to your project repository. Create a pipeline for your project: Go to your Jenkins account and in the Dashboard view, select New Item from the menu on the left. Enter a name for your pipeline, select Multibranch Pipeline and confirm by clicking OK . Configure your pipeline: Go to your newly created pipeline and select Configure from the menu on the left. In the Branch Sources section, select the Git option and provide the following: Project Repository - enter the URL address of your project repository that hosts the Jenkinsfile and the python script file from Step 2 . Credentials - add the user name and password of your GitLab account. In the Build Configuration section, select the by Jenkinsfile mode from the drop-down list and provide the GitLab path to the Jenkinsfile from Step 1 (if the file is located in the GitLab root folder, it is enough to type Jenkinsfile ) Click Save .","title":"Set up multibranch pipeline"},{"location":"Device_tests/Use_API_Jenkins_integration/#run-multibranch-pipeline","text":"Before running the tests for a chosen branch, you have to perform a scan to detect available branches (those with a Jenkinsfile ): Go to your multibranch pipeline and select Scan Multibranch Pipeline Now option from the menu on the left. Once the scan is completed, you will see a list of available branches. Enter a chosen branch by clicking on its name and select Build Now . Note Remember to check if the device you run the tests for is connected and registered in Coiote DM. Once the tests are performed, you will see your build status along with a graph reporting the execution status for each test.","title":"Run multibranch pipeline"},{"location":"Device_tests/Use_API_Jenkins_integration/#gitlab-configure-and-run-pipeline","text":"Coiote DM interop tests API can also be integrated with GitLab using the GitLab's CI/CD toolset. Here is how to do it: Upload the gitlab-ci.yml file that will define your GitLab pipeline to your project repository: Edit the script where required to adjust it to your environment: Note Remember to change the name example_filename.py to your custom name that you will choose in the next step. Also, keep in mind that running a pipeline in GitLab requires a docker image of a Linux distribution (or any operating system that can run python script). image : name : example.repository.com/docker-local/linux_image protocol-tests : stage : test script : - python3 example_filename.py artifacts : when : always paths : - report.xml reports : junit : report.xml Save the file as gitlab-ci.yml and upload it to the chosen branch of your project repository. Follow Step 2 from Creating a Jenkins multibranch pipeline (uploading a file with python script to your GitLab repository). Run a created pipeline for your project: Go to your GitLab project and in the Dashboard view, select CI/CD from the menu on the left and click Pipelines . Attention Note that to be able to run a pipeline, you will need to have the GitLab CI/CD toolset configured. For details, please check https://docs.gitlab.com/ee/ci/introduction/index.html . You should be able to see the branch with the uploaded gitlab-ci.yml file. Select the Run pipeline button, then confirm again by clicking Run pipeline . Once the pipeline execution is finished, you should be able to see the results in the Tests tab of your pipeline. Note Viewing graphs with test results is not supported in GitLab by default as it requires additional plugins.","title":"GitLab - configure and run pipeline"},{"location":"Release_Notes/v2021.22.1/","text":"v2021.22.1 # Previous version: v2021.19.0 Features # New Device inventory view # The new Device inventory is now the default for viewing devices in the Coiote DM platform. It has an improved design as well as faster and more stable performance. The new Device inventory is available directly from the left navigation bar. If you need to access the old Device inventory view, go to Administration -> Device inventory . Enhancements # EST DER format support # We switched from the PEM to the DER content format of enrolling and re-enrolling requests sent to the EST server. Thanks to this change more EST Server implementations will be supported and compliance with RFC7030 is enhanced. Bug fixes # Larger limits for HTTP request headers # Thanks to a new configuration for Jetty, you can now access REST API and Coiote DM GUI even with large HTTP request headers. Security # Updated Grafana version to fix the CVE-2021-43798 vulnerability. Our security scan confirmed that Coiote DM isn\u2019t affected by the Apache Log4j vulnerability.","title":"v2021.22.1"},{"location":"Release_Notes/v2021.22.1/#v2021221","text":"Previous version: v2021.19.0","title":"v2021.22.1"},{"location":"Release_Notes/v2021.22.1/#features","text":"","title":"Features"},{"location":"Release_Notes/v2021.22.1/#new-device-inventory-view","text":"The new Device inventory is now the default for viewing devices in the Coiote DM platform. It has an improved design as well as faster and more stable performance. The new Device inventory is available directly from the left navigation bar. If you need to access the old Device inventory view, go to Administration -> Device inventory .","title":"New Device inventory view"},{"location":"Release_Notes/v2021.22.1/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2021.22.1/#est-der-format-support","text":"We switched from the PEM to the DER content format of enrolling and re-enrolling requests sent to the EST server. Thanks to this change more EST Server implementations will be supported and compliance with RFC7030 is enhanced.","title":"EST DER format support"},{"location":"Release_Notes/v2021.22.1/#bug-fixes","text":"","title":"Bug fixes"},{"location":"Release_Notes/v2021.22.1/#larger-limits-for-http-request-headers","text":"Thanks to a new configuration for Jetty, you can now access REST API and Coiote DM GUI even with large HTTP request headers.","title":"Larger limits for HTTP request headers"},{"location":"Release_Notes/v2021.22.1/#security","text":"Updated Grafana version to fix the CVE-2021-43798 vulnerability. Our security scan confirmed that Coiote DM isn\u2019t affected by the Apache Log4j vulnerability.","title":"Security"},{"location":"Release_Notes/v2021.23.0/","text":"v2021.23.0 # Previous version: v2021.22.1 Enhancements # Record headers in Kafka messages # You can now add record headers to the kafkaPublish tag when configuring an XML task. It means that the components responsible for the Kafka event processing (e.g., routing) no longer need to read each binary message. Instead, these components read only the record headers and therefore work faster. Support for additional non-standard device type # We continue to improve compatibility with devices that have incomplete or faulty support of the standard LwM2M protocol. To make such a device ready to work with Coiote DM, you can now turn on and configure a non-standard logic in the Device dialects section. New error pages # The 400, 404, and 5XX error pages now have a cleaner and more user-friendly look. Bug fixes # Uninterrupted access to GUI # Fixed a bug where the GUI of Coiote DM would crash after 30 minutes of inactivity on some installations. Thanks to the new configuration, the GUI now works smoothly even after hours of inactivity. JDK downgrade # To improve the speed performance of Coiote DM, we\u2019ve downgraded the JDK version from 17 to 11. No action is required for the virtual machine deployments because the JRE is included in the docker image.","title":"v2021.23.0"},{"location":"Release_Notes/v2021.23.0/#v2021230","text":"Previous version: v2021.22.1","title":"v2021.23.0"},{"location":"Release_Notes/v2021.23.0/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2021.23.0/#record-headers-in-kafka-messages","text":"You can now add record headers to the kafkaPublish tag when configuring an XML task. It means that the components responsible for the Kafka event processing (e.g., routing) no longer need to read each binary message. Instead, these components read only the record headers and therefore work faster.","title":"Record headers in Kafka messages"},{"location":"Release_Notes/v2021.23.0/#support-for-additional-non-standard-device-type","text":"We continue to improve compatibility with devices that have incomplete or faulty support of the standard LwM2M protocol. To make such a device ready to work with Coiote DM, you can now turn on and configure a non-standard logic in the Device dialects section.","title":"Support for additional non-standard device type"},{"location":"Release_Notes/v2021.23.0/#new-error-pages","text":"The 400, 404, and 5XX error pages now have a cleaner and more user-friendly look.","title":"New error pages"},{"location":"Release_Notes/v2021.23.0/#bug-fixes","text":"","title":"Bug fixes"},{"location":"Release_Notes/v2021.23.0/#uninterrupted-access-to-gui","text":"Fixed a bug where the GUI of Coiote DM would crash after 30 minutes of inactivity on some installations. Thanks to the new configuration, the GUI now works smoothly even after hours of inactivity.","title":"Uninterrupted access to GUI"},{"location":"Release_Notes/v2021.23.0/#jdk-downgrade","text":"To improve the speed performance of Coiote DM, we\u2019ve downgraded the JDK version from 17 to 11. No action is required for the virtual machine deployments because the JRE is included in the docker image.","title":"JDK downgrade"},{"location":"Release_Notes/v2021.24.5/","text":"v2021.24.5 # Previous version: v2021.23.0 Features # Read Model Factory on EU Cloud installation # The data for the Dashboard and Device Inventory views is now provided by the Read Model Factory module deployed as a separate application to optimize resource consumption and data processing. What changes in the application: Both the Dashboard and Device Inventory views now display bootstrap and management device entities in a single line, with links to the Device Management Center for each device entity. In the Dashboard view, you can now search for alerts by device data - lifecycle status, domain, group, manufacturer, model name, firmware version. Bypassing light sessions by HealthChecker # We have added a possibility to create a list of device IDs in cdm.conf that will have normal sessions even when the light session threshold is reached. Enhancements # Whitelabelling and custom URLs in Identity and Access Management # When logging to Coiote DM (cloud installations) using a custom tenant hostname, the user can now be redirected to a login page under the same custom tenant hostname. The change applies to the Coiote DM login page , User Management view and the change password view.","title":"v2021.24.5"},{"location":"Release_Notes/v2021.24.5/#v2021245","text":"Previous version: v2021.23.0","title":"v2021.24.5"},{"location":"Release_Notes/v2021.24.5/#features","text":"","title":"Features"},{"location":"Release_Notes/v2021.24.5/#read-model-factory-on-eu-cloud-installation","text":"The data for the Dashboard and Device Inventory views is now provided by the Read Model Factory module deployed as a separate application to optimize resource consumption and data processing. What changes in the application: Both the Dashboard and Device Inventory views now display bootstrap and management device entities in a single line, with links to the Device Management Center for each device entity. In the Dashboard view, you can now search for alerts by device data - lifecycle status, domain, group, manufacturer, model name, firmware version.","title":"Read Model Factory on EU Cloud installation"},{"location":"Release_Notes/v2021.24.5/#bypassing-light-sessions-by-healthchecker","text":"We have added a possibility to create a list of device IDs in cdm.conf that will have normal sessions even when the light session threshold is reached.","title":"Bypassing light sessions by HealthChecker"},{"location":"Release_Notes/v2021.24.5/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2021.24.5/#whitelabelling-and-custom-urls-in-identity-and-access-management","text":"When logging to Coiote DM (cloud installations) using a custom tenant hostname, the user can now be redirected to a login page under the same custom tenant hostname. The change applies to the Coiote DM login page , User Management view and the change password view.","title":"Whitelabelling and custom URLs in Identity and Access Management"},{"location":"Release_Notes/v2022.13.5/","text":"v2022.13.5 # Previous version: v2022.12.4 Features # New Device Center # We have introduced the new Device Center for effective management of single devices. Designed to enable IoT developers build LwM2M applications quickly and intuitively, it features the following actionable views: Summary sidebar Use device actions (reboot, data model refresh, clear DTLS context, delete device) Quickly check connection status and parameters See basic device info Overview tab Display widgets related to device status and connectivity View Device location on the map and check location details Configuration tab Upload device image and change its Friendly name View and copy device connection parameters Data model tab Perform or schedule operations on device objects, object instances, and resources: Read Write Execute Set observations View the details of individual objects and resources Search the data model for device objects, object instances, and resources The Device Center replaces the old Device Management Center view (DMC) which is still supported - use the Go to previous version button and the Go to new Device Center link to switch between them.","title":"v2022.13.5"},{"location":"Release_Notes/v2022.13.5/#v2022135","text":"Previous version: v2022.12.4","title":"v2022.13.5"},{"location":"Release_Notes/v2022.13.5/#features","text":"","title":"Features"},{"location":"Release_Notes/v2022.13.5/#new-device-center","text":"We have introduced the new Device Center for effective management of single devices. Designed to enable IoT developers build LwM2M applications quickly and intuitively, it features the following actionable views: Summary sidebar Use device actions (reboot, data model refresh, clear DTLS context, delete device) Quickly check connection status and parameters See basic device info Overview tab Display widgets related to device status and connectivity View Device location on the map and check location details Configuration tab Upload device image and change its Friendly name View and copy device connection parameters Data model tab Perform or schedule operations on device objects, object instances, and resources: Read Write Execute Set observations View the details of individual objects and resources Search the data model for device objects, object instances, and resources The Device Center replaces the old Device Management Center view (DMC) which is still supported - use the Go to previous version button and the Go to new Device Center link to switch between them.","title":"New Device Center"},{"location":"Release_Notes/v2022.16.0/","text":"v2022.16.0 # Previous version: v2022.14.15 Enhancements # Minor GUI enhancements # We have fixed the behaviour of dialog windows for some platform views. We have improved the looks of empty states in some places of the GUI. The \u2018Additional costs\u2019 calculator in the Payment service panel has been modified so that it now includes base and additional costs. Validations have been added in the Set observation side navigation dialog of the Device Center . We have changed the date format presented in the GUI so that it conforms to the ISO standard. Float values presented in the data model are now rounded to at most two significant digits. Domain hierarchy support for DTLS/TLS certificates # The DTLS/TLS Certificates panel now displays only certificates from the current domain that the user is logged into. Bug Fixes # Fixed the Certificate Request message when connecting over TLS/TCP # We have fixed the Certificate Request message when the Server and Client try to connect over TLS/TCP. Connection errors for clients that use MBed TLS (including Anjay ) are now solved. Fixed the license invalidation # We have corrected the License invalidation action so that it is done only after a configurable retry backoff time limit. Added validation the Azure IoT Hub integration # We have added a validation for the Device ID in the Hyperscaler Integration Center . Now the Device ID should be a string up to 128 characters long consisting of alphanumeric characters plus the special characters: '-', '.', '_', ':'. The last character must be alphanumeric or dash. Fixed scheduling firmware upgrades when resource value is an empty string # We have fixed an error that prevented scheduling firmware upgrades on devices whose Firmware Update Protocol Support resource value was an empty string.","title":"v2022.16.0"},{"location":"Release_Notes/v2022.16.0/#v2022160","text":"Previous version: v2022.14.15","title":"v2022.16.0"},{"location":"Release_Notes/v2022.16.0/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.16.0/#minor-gui-enhancements","text":"We have fixed the behaviour of dialog windows for some platform views. We have improved the looks of empty states in some places of the GUI. The \u2018Additional costs\u2019 calculator in the Payment service panel has been modified so that it now includes base and additional costs. Validations have been added in the Set observation side navigation dialog of the Device Center . We have changed the date format presented in the GUI so that it conforms to the ISO standard. Float values presented in the data model are now rounded to at most two significant digits.","title":"Minor GUI enhancements"},{"location":"Release_Notes/v2022.16.0/#domain-hierarchy-support-for-dtlstls-certificates","text":"The DTLS/TLS Certificates panel now displays only certificates from the current domain that the user is logged into.","title":"Domain hierarchy support for DTLS/TLS certificates"},{"location":"Release_Notes/v2022.16.0/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"Release_Notes/v2022.16.0/#fixed-the-certificate-request-message-when-connecting-over-tlstcp","text":"We have fixed the Certificate Request message when the Server and Client try to connect over TLS/TCP. Connection errors for clients that use MBed TLS (including Anjay ) are now solved.","title":"Fixed the Certificate Request message when connecting over TLS/TCP"},{"location":"Release_Notes/v2022.16.0/#fixed-the-license-invalidation","text":"We have corrected the License invalidation action so that it is done only after a configurable retry backoff time limit.","title":"Fixed the license invalidation"},{"location":"Release_Notes/v2022.16.0/#added-validation-the-azure-iot-hub-integration","text":"We have added a validation for the Device ID in the Hyperscaler Integration Center . Now the Device ID should be a string up to 128 characters long consisting of alphanumeric characters plus the special characters: '-', '.', '_', ':'. The last character must be alphanumeric or dash.","title":"Added validation the Azure IoT Hub integration"},{"location":"Release_Notes/v2022.16.0/#fixed-scheduling-firmware-upgrades-when-resource-value-is-an-empty-string","text":"We have fixed an error that prevented scheduling firmware upgrades on devices whose Firmware Update Protocol Support resource value was an empty string.","title":"Fixed scheduling firmware upgrades when resource value is an empty string"},{"location":"Release_Notes/v2022.17.0/","text":"v2022.17.0 # Previous version: v2022.16.0 Features # Configuring EST integration via Domain properties # We have introduced dynamic EST integration configuration via the domain properties. It is now possible for each client to set up its own EST server in the Domain management view. The configuration is inherited (analogously to the Kafka settings e.g.). To use the EST configuration property, the domainProperties.est permission is required. If there is no EST configuration on a given domain, then the system uses the value from Coiote DM cdm.conf config file as a fallback, which ensures backward compatibility. Changes have also been made to the DTLS/TLS Certificates view. Now only certificates added in the given domain are presented to avoid cross-domain certificate visibility. Architectural Changes # There were no architectural changes in this release. Enhancements # Minor GUI improvements # In Device Inventory, the filter counter is now hidden when there is no filter applied. \u2018Impersonated by\u2019 column in User activity table of Historical analysis # We have added a new column to the User activity table that shows the UserID of the actual user (impersonator) who executed the recorded action from the account of the user being impersonated. Bug Fixes # Fixed Cancel all tests action in the Device tests tab of DMC # We have fixed the faulty behaviour of the Cancel all tests button used to stop the execution of tests inside the Device tests tab of the Device Management Center. Fixed loading data for multiresources with no instances in the data model # We have fixed an error occurring while loading a multiresource that has no instances in the data model. Now the multi-resource value is displayed in the same manner as a single resource without value. Fixed task execution status (report) not displayed after device domain change # When moving devices between domains, their task execution statuses (reports) are now updated accordingly.","title":"v2022.17.0"},{"location":"Release_Notes/v2022.17.0/#v2022170","text":"Previous version: v2022.16.0","title":"v2022.17.0"},{"location":"Release_Notes/v2022.17.0/#features","text":"","title":"Features"},{"location":"Release_Notes/v2022.17.0/#configuring-est-integration-via-domain-properties","text":"We have introduced dynamic EST integration configuration via the domain properties. It is now possible for each client to set up its own EST server in the Domain management view. The configuration is inherited (analogously to the Kafka settings e.g.). To use the EST configuration property, the domainProperties.est permission is required. If there is no EST configuration on a given domain, then the system uses the value from Coiote DM cdm.conf config file as a fallback, which ensures backward compatibility. Changes have also been made to the DTLS/TLS Certificates view. Now only certificates added in the given domain are presented to avoid cross-domain certificate visibility.","title":"Configuring EST integration via Domain properties"},{"location":"Release_Notes/v2022.17.0/#architectural-changes","text":"There were no architectural changes in this release.","title":"Architectural Changes"},{"location":"Release_Notes/v2022.17.0/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.17.0/#minor-gui-improvements","text":"In Device Inventory, the filter counter is now hidden when there is no filter applied.","title":"Minor GUI improvements"},{"location":"Release_Notes/v2022.17.0/#impersonated-by-column-in-user-activity-table-of-historical-analysis","text":"We have added a new column to the User activity table that shows the UserID of the actual user (impersonator) who executed the recorded action from the account of the user being impersonated.","title":"\u2018Impersonated by\u2019 column in User activity table of Historical analysis"},{"location":"Release_Notes/v2022.17.0/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"Release_Notes/v2022.17.0/#fixed-cancel-all-tests-action-in-the-device-tests-tab-of-dmc","text":"We have fixed the faulty behaviour of the Cancel all tests button used to stop the execution of tests inside the Device tests tab of the Device Management Center.","title":"Fixed Cancel all tests action in the Device tests tab of DMC"},{"location":"Release_Notes/v2022.17.0/#fixed-loading-data-for-multiresources-with-no-instances-in-the-data-model","text":"We have fixed an error occurring while loading a multiresource that has no instances in the data model. Now the multi-resource value is displayed in the same manner as a single resource without value.","title":"Fixed loading data for multiresources with no instances in the data model"},{"location":"Release_Notes/v2022.17.0/#fixed-task-execution-status-report-not-displayed-after-device-domain-change","text":"When moving devices between domains, their task execution statuses (reports) are now updated accordingly.","title":"Fixed task execution status (report) not displayed after device domain change"},{"location":"Release_Notes/v2022.18.3/","text":"v2022.18.3 # Previous version: v2022.17.0 Enhancements # FOTA panel redirection page in Device Center # We have added a new FOTA tab in the Device Center. It redirects users to the previous version of the Device Management Center to perform a device Firmware upgrade. The new FOTA view is currently under development. Improvements in Device inventory and Operations center # We have introduced some enhancements to the Device inventory and Operations center . Now it is the Device inventory that is the default page displayed upon logging in to the platform. The order in the navigation menu has also been changed. In the Operations center , the Alerts tab is now the default view that is displayed. The tables that list devices and alerts have new columns: Device inventory : Status , Bootstrap Operations center Alerts tab: Status , Alert status Operations center Device list tab: Status , Device alert status Sorting has been enabled in the newly added columns. Bug Fixes # Fixed Select template button behaviour in Task templates # In the Task template panel, the Select template button now appears correctly even for long template names. section for description of bug fixes. Fixed Device registration status action # We have fixed the behaviour of the Devices registration status action feature so that now the configured action is performed only for the domain it was set up in - no conflict of domains occurs. Fixed the Leave tag in XML tasks # We have fixed the behaviour of the leave tag in the XML tasks, so that the device now leaves all the defined subgroups and the task finishes successfully. Fixed loading page when migrating large numbers of devices between domains # We have fixed the GUI action of changing the domain for large numbers of devices via the Device inventory . Now the loading page doesn\u2019t freeze while handling bulk migrations. Fixed no response for 2nd Register Update in some devices # As a result of failure to persist updated device lifetime, the Server responded with the 4.04 error for the second Register Update in some devices. We have fixed it so that concurrent update handling in the Coiote DM database is avoided.","title":"v2022.18.3"},{"location":"Release_Notes/v2022.18.3/#v2022183","text":"Previous version: v2022.17.0","title":"v2022.18.3"},{"location":"Release_Notes/v2022.18.3/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.18.3/#fota-panel-redirection-page-in-device-center","text":"We have added a new FOTA tab in the Device Center. It redirects users to the previous version of the Device Management Center to perform a device Firmware upgrade. The new FOTA view is currently under development.","title":"FOTA panel redirection page in Device Center"},{"location":"Release_Notes/v2022.18.3/#improvements-in-device-inventory-and-operations-center","text":"We have introduced some enhancements to the Device inventory and Operations center . Now it is the Device inventory that is the default page displayed upon logging in to the platform. The order in the navigation menu has also been changed. In the Operations center , the Alerts tab is now the default view that is displayed. The tables that list devices and alerts have new columns: Device inventory : Status , Bootstrap Operations center Alerts tab: Status , Alert status Operations center Device list tab: Status , Device alert status Sorting has been enabled in the newly added columns.","title":"Improvements in Device inventory and Operations center"},{"location":"Release_Notes/v2022.18.3/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"Release_Notes/v2022.18.3/#fixed-select-template-button-behaviour-in-task-templates","text":"In the Task template panel, the Select template button now appears correctly even for long template names. section for description of bug fixes.","title":"Fixed Select template button behaviour in Task templates"},{"location":"Release_Notes/v2022.18.3/#fixed-device-registration-status-action","text":"We have fixed the behaviour of the Devices registration status action feature so that now the configured action is performed only for the domain it was set up in - no conflict of domains occurs.","title":"Fixed Device registration status action"},{"location":"Release_Notes/v2022.18.3/#fixed-the-leave-tag-in-xml-tasks","text":"We have fixed the behaviour of the leave tag in the XML tasks, so that the device now leaves all the defined subgroups and the task finishes successfully.","title":"Fixed the Leave tag in XML tasks"},{"location":"Release_Notes/v2022.18.3/#fixed-loading-page-when-migrating-large-numbers-of-devices-between-domains","text":"We have fixed the GUI action of changing the domain for large numbers of devices via the Device inventory . Now the loading page doesn\u2019t freeze while handling bulk migrations.","title":"Fixed loading page when migrating large numbers of devices between domains"},{"location":"Release_Notes/v2022.18.3/#fixed-no-response-for-2nd-register-update-in-some-devices","text":"As a result of failure to persist updated device lifetime, the Server responded with the 4.04 error for the second Register Update in some devices. We have fixed it so that concurrent update handling in the Coiote DM database is avoided.","title":"Fixed no response for 2nd Register Update in some devices"},{"location":"Release_Notes/v2022.19.2/","text":"v2022.19.2 # Previous version: v2022.18.3 Enhancements # Connection status indicator in Device creator summary # We have introduced the connection status indicator to the summary step of the Device creator . It is now consistent with the Device Center summary \u2018Impersonated by\u2019 column in task edition history of Historical analysis # We have added the \u2018Impersonated by\u2019 column to theTask edition history table that shows the UserID of the actual user (impersonator) who executed the recorded action from the account of the user being impersonated. Architectural Changes # Device ID changes to Endpoint name # We have changed the Device ID label to Endpoint name in Device inventory, Device Center and other relevant views. This has been triggered by major changes in how the device endpoint name is now encrypted in the database. Bug Fixes # Fixed Devices registration status action causing domain change # Deleting Devices registration status action no longer causes devices to change domains. Fixed behavior of snackbars persisting between steps of the Device creator # Snackbars appearing In the \"Connect your device\u201d step of Device creator will now disappear when navigating to the next step. Fixed searching for task templates # We have fixed the search option available when selecting a task template. It now works correctly, also for old Expressions and for characters such as square brackets.","title":"v2022.19.2"},{"location":"Release_Notes/v2022.19.2/#v2022192","text":"Previous version: v2022.18.3","title":"v2022.19.2"},{"location":"Release_Notes/v2022.19.2/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.19.2/#connection-status-indicator-in-device-creator-summary","text":"We have introduced the connection status indicator to the summary step of the Device creator . It is now consistent with the Device Center summary","title":"Connection status indicator in Device creator summary"},{"location":"Release_Notes/v2022.19.2/#impersonated-by-column-in-task-edition-history-of-historical-analysis","text":"We have added the \u2018Impersonated by\u2019 column to theTask edition history table that shows the UserID of the actual user (impersonator) who executed the recorded action from the account of the user being impersonated.","title":"\u2018Impersonated by\u2019 column in task edition history of Historical analysis"},{"location":"Release_Notes/v2022.19.2/#architectural-changes","text":"","title":"Architectural Changes"},{"location":"Release_Notes/v2022.19.2/#device-id-changes-to-endpoint-name","text":"We have changed the Device ID label to Endpoint name in Device inventory, Device Center and other relevant views. This has been triggered by major changes in how the device endpoint name is now encrypted in the database.","title":"Device ID changes to Endpoint name"},{"location":"Release_Notes/v2022.19.2/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"Release_Notes/v2022.19.2/#fixed-devices-registration-status-action-causing-domain-change","text":"Deleting Devices registration status action no longer causes devices to change domains.","title":"Fixed Devices registration status action causing domain change"},{"location":"Release_Notes/v2022.19.2/#fixed-behavior-of-snackbars-persisting-between-steps-of-the-device-creator","text":"Snackbars appearing In the \"Connect your device\u201d step of Device creator will now disappear when navigating to the next step.","title":"Fixed behavior of snackbars persisting between steps of the Device creator"},{"location":"Release_Notes/v2022.19.2/#fixed-searching-for-task-templates","text":"We have fixed the search option available when selecting a task template. It now works correctly, also for old Expressions and for characters such as square brackets.","title":"Fixed searching for task templates"},{"location":"Release_Notes/v2022.20.4/","text":"v2022.20.4 # Previous version: v2022.19.2 Features # Connect single device to Azure # We have added an option to connect single devices in Device inventory to the currently integrated Azure service. It is available in the context menu for each created device displayed in the Device inventory table. The operation can only be performed for a device with a configured LwM2M Management server and in the domain that the device belongs to. Saving filter state of the Device inventory in URL fragment # In Device inventory , we have introduced saving filter data as state in a URL fragment. This allows saving any filter data e.g. groups, domain, lifecycle status, and search text. When the user saves a filter or types in the search field, the URL fragment is updated. When copying and pasting the URL, the relevant data context will be applied in the filter. Architectural Changes # New monitoring endpoints in restAPI # We have implemented two device monitoring restAPI endpoints: /deviceMonitoring/data/{deviceId}/resourceUrl/{lwm2mUrl} - returns a series of monitoring data from the device's resource identified by its LwM2M URL that were reported between the timeRangeStart and timeRangeEnd . /deviceMonitoring/data/{deviceId}/alias/{alias} - returns a series of monitoring data from the device's resource identified by its alias that were reported between the timeRangeStart and timeRangeEnd . Enhancements # New methods added to lwM2M context in XML tasks # Added two methods to lwm2m context in XML tasks: dmPathToLwM2MPath - transforms a dmPath to a lwm2mPath (eg. Device.0.Manufacturer -> /3/0/0 ) getDataType gets the data type for a given path (eg. Device.0.Manufacturer -> string) If the specified dmPath is not known, because either: the model is invalid or the path itself is invalid, then the method will return null . Bug Fixes # Fixed adding devices to inaccessible group using <join> tag # We have changed the behavior of the XML task <join> tag so that it is no longer possible to create a group in the wrong domain using the tag. Fixed values of Connectivity widgets in Device Center Overview tab # We have fixed the Cell ID , APN , Radio signal strength and Network bearer Connectivity widgets in Device Center so that each displays the relevant values.","title":"v2022.20.4"},{"location":"Release_Notes/v2022.20.4/#v2022204","text":"Previous version: v2022.19.2","title":"v2022.20.4"},{"location":"Release_Notes/v2022.20.4/#features","text":"","title":"Features"},{"location":"Release_Notes/v2022.20.4/#connect-single-device-to-azure","text":"We have added an option to connect single devices in Device inventory to the currently integrated Azure service. It is available in the context menu for each created device displayed in the Device inventory table. The operation can only be performed for a device with a configured LwM2M Management server and in the domain that the device belongs to.","title":"Connect single device to Azure"},{"location":"Release_Notes/v2022.20.4/#saving-filter-state-of-the-device-inventory-in-url-fragment","text":"In Device inventory , we have introduced saving filter data as state in a URL fragment. This allows saving any filter data e.g. groups, domain, lifecycle status, and search text. When the user saves a filter or types in the search field, the URL fragment is updated. When copying and pasting the URL, the relevant data context will be applied in the filter.","title":"Saving filter state of the Device inventory in URL fragment"},{"location":"Release_Notes/v2022.20.4/#architectural-changes","text":"","title":"Architectural Changes"},{"location":"Release_Notes/v2022.20.4/#new-monitoring-endpoints-in-restapi","text":"We have implemented two device monitoring restAPI endpoints: /deviceMonitoring/data/{deviceId}/resourceUrl/{lwm2mUrl} - returns a series of monitoring data from the device's resource identified by its LwM2M URL that were reported between the timeRangeStart and timeRangeEnd . /deviceMonitoring/data/{deviceId}/alias/{alias} - returns a series of monitoring data from the device's resource identified by its alias that were reported between the timeRangeStart and timeRangeEnd .","title":"New monitoring endpoints in restAPI"},{"location":"Release_Notes/v2022.20.4/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.20.4/#new-methods-added-to-lwm2m-context-in-xml-tasks","text":"Added two methods to lwm2m context in XML tasks: dmPathToLwM2MPath - transforms a dmPath to a lwm2mPath (eg. Device.0.Manufacturer -> /3/0/0 ) getDataType gets the data type for a given path (eg. Device.0.Manufacturer -> string) If the specified dmPath is not known, because either: the model is invalid or the path itself is invalid, then the method will return null .","title":"New methods added to lwM2M context in XML tasks"},{"location":"Release_Notes/v2022.20.4/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"Release_Notes/v2022.20.4/#fixed-adding-devices-to-inaccessible-group-using-join-tag","text":"We have changed the behavior of the XML task <join> tag so that it is no longer possible to create a group in the wrong domain using the tag.","title":"Fixed adding devices to inaccessible group using &lt;join&gt; tag"},{"location":"Release_Notes/v2022.20.4/#fixed-values-of-connectivity-widgets-in-device-center-overview-tab","text":"We have fixed the Cell ID , APN , Radio signal strength and Network bearer Connectivity widgets in Device Center so that each displays the relevant values.","title":"Fixed values of Connectivity widgets in Device Center Overview tab"},{"location":"Release_Notes/v2022.21.6/","text":"v2022.21.6 # Previous version: v2022.20.4 Features # New domain property group for configuring historical data storage period # In Domain management , we have introduced the possibility to define how long the device historical data should be stored. It can be configured using a property for a specific domain. The default maximum storage limit is 30 days. Bug Fixes # Fixed no EST logs generated for device when EST request is made # EST logs are now generated correctly for the device bootstrap entity. Fixed no possibility to delete \u201cbillable\u201d domain # We have restored the possibility to delete billing admin domains by superusers (under the standard condition that they don\u2019t contain any subdomains, users, and devices). Fixed failing Azure IoT Hub device export # We have fixed the issue with exporting devices to Azure IoT Hub via GUI and API by upgrading the Azure SDK libraries to the newest versions. We have also added possibility to re-initialize client connection to Azure on demand via the REST API using the new extensions/hyperscaler/restartClient method. Fixed Clear all button that disabled searching the same phrase in Device inventory # We have fixed the behaviour of the Device inventory search field. Now clicking the Clear all button after having searched a phrase, then trying to search the same phrase works as intended. Fixed API user not able retrieve test results if the test definition comes from parent domain # We have fixed the inability to retrieve test results by REST API users for tests defined in parent domains by aligning the API with the correct behaviour of the feature in GUI. Fixed inactive scroll for domain list in XML task creation view # We have fixed scrolling for the drop-down domain list used when creating an XML task.","title":"v2022.21.6"},{"location":"Release_Notes/v2022.21.6/#v2022216","text":"Previous version: v2022.20.4","title":"v2022.21.6"},{"location":"Release_Notes/v2022.21.6/#features","text":"","title":"Features"},{"location":"Release_Notes/v2022.21.6/#new-domain-property-group-for-configuring-historical-data-storage-period","text":"In Domain management , we have introduced the possibility to define how long the device historical data should be stored. It can be configured using a property for a specific domain. The default maximum storage limit is 30 days.","title":"New domain property group for configuring historical data storage period"},{"location":"Release_Notes/v2022.21.6/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"Release_Notes/v2022.21.6/#fixed-no-est-logs-generated-for-device-when-est-request-is-made","text":"EST logs are now generated correctly for the device bootstrap entity.","title":"Fixed no EST logs generated for device when EST request is made"},{"location":"Release_Notes/v2022.21.6/#fixed-no-possibility-to-delete-billable-domain","text":"We have restored the possibility to delete billing admin domains by superusers (under the standard condition that they don\u2019t contain any subdomains, users, and devices).","title":"Fixed no possibility to delete \u201cbillable\u201d domain"},{"location":"Release_Notes/v2022.21.6/#fixed-failing-azure-iot-hub-device-export","text":"We have fixed the issue with exporting devices to Azure IoT Hub via GUI and API by upgrading the Azure SDK libraries to the newest versions. We have also added possibility to re-initialize client connection to Azure on demand via the REST API using the new extensions/hyperscaler/restartClient method.","title":"Fixed failing Azure IoT Hub device export"},{"location":"Release_Notes/v2022.21.6/#fixed-clear-all-button-that-disabled-searching-the-same-phrase-in-device-inventory","text":"We have fixed the behaviour of the Device inventory search field. Now clicking the Clear all button after having searched a phrase, then trying to search the same phrase works as intended.","title":"Fixed Clear all button that disabled searching the same phrase in Device inventory"},{"location":"Release_Notes/v2022.21.6/#fixed-api-user-not-able-retrieve-test-results-if-the-test-definition-comes-from-parent-domain","text":"We have fixed the inability to retrieve test results by REST API users for tests defined in parent domains by aligning the API with the correct behaviour of the feature in GUI.","title":"Fixed API user not able retrieve test results if the test definition comes from parent domain"},{"location":"Release_Notes/v2022.21.6/#fixed-inactive-scroll-for-domain-list-in-xml-task-creation-view","text":"We have fixed scrolling for the drop-down domain list used when creating an XML task.","title":"Fixed inactive scroll for domain list in XML task creation view"},{"location":"Release_Notes/v2022.22.0/","text":"v2022.22.0 # Previous version: v2022.21.6 Features # Added bulk device removal in Device inventory for non-superusers. # We have added bulk device removal (as a group action) in the Device inventory with a limit of 100 devices for non-superusers who have the ui.deviceInventory.deleteDevice role. New REST API endpoints for setting observations on device groups # We have created two new endpoints for setting observations on device groups. /observations/group/resourcePath/{groupId}/{path} creates or updates group observations for a given path. /observations/group/resourceUrl/{groupId}/{url} creates or updates group observations for a given LwM2M URL. Both endpoints have the createEnsureObserveIfNotExists attribute which determines if the ensureObserve task should be created in case it doesn\u2019t exist. Enhancements # Removed outdated Azure IoT integration extension # We have removed the outdated method of connecting the Azure IoT integration which was available as an extension in the Administration -> Extensions view. Removed Device settings XML panels from default configuration # We have removed the default XML panels in the Device settings tab of the old DMC: Access Control Connectivity Device Location Servers Also, the Device settings tab is no longer a default DMC menu tab. Added possibility to configure Execution logs storage for tasks and task templates # We have added a new option for tasks and task templates that allows selecting which type of execution logs should be stored, with three options: Store all - default behavior, all logs are generated and stored. Store failed - logs will be generated only if task execution fails. Store none - logs are not generated. Bug Fixes # Fixed inability to create an Azure template with custom LwM2M objects in non-root domain # LwM2M objects created by means of custom object definitions can be now included in Azure integration templates by users in non-root domains. Fixed static documentation not respecting multitenancy # We have fixed the behavior of static documentation (i.e. generated via files uploaded in the Resources panel ) so that it is only visible for users in relevant domains. Fixed different results of reading and writing executable resources # Writing to an executable resource caused the platform to report communication failure. We have aligned this behavior with the results of reading an executable resource, in which case a response with the correct 4.05 MethodNotAllowed error code is returned.","title":"v2022.22.0"},{"location":"Release_Notes/v2022.22.0/#v2022220","text":"Previous version: v2022.21.6","title":"v2022.22.0"},{"location":"Release_Notes/v2022.22.0/#features","text":"","title":"Features"},{"location":"Release_Notes/v2022.22.0/#added-bulk-device-removal-in-device-inventory-for-non-superusers","text":"We have added bulk device removal (as a group action) in the Device inventory with a limit of 100 devices for non-superusers who have the ui.deviceInventory.deleteDevice role.","title":"Added bulk device removal in Device inventory for non-superusers."},{"location":"Release_Notes/v2022.22.0/#new-rest-api-endpoints-for-setting-observations-on-device-groups","text":"We have created two new endpoints for setting observations on device groups. /observations/group/resourcePath/{groupId}/{path} creates or updates group observations for a given path. /observations/group/resourceUrl/{groupId}/{url} creates or updates group observations for a given LwM2M URL. Both endpoints have the createEnsureObserveIfNotExists attribute which determines if the ensureObserve task should be created in case it doesn\u2019t exist.","title":"New REST API endpoints for setting observations on device groups"},{"location":"Release_Notes/v2022.22.0/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.22.0/#removed-outdated-azure-iot-integration-extension","text":"We have removed the outdated method of connecting the Azure IoT integration which was available as an extension in the Administration -> Extensions view.","title":"Removed outdated Azure IoT integration extension"},{"location":"Release_Notes/v2022.22.0/#removed-device-settings-xml-panels-from-default-configuration","text":"We have removed the default XML panels in the Device settings tab of the old DMC: Access Control Connectivity Device Location Servers Also, the Device settings tab is no longer a default DMC menu tab.","title":"Removed Device settings XML panels from default configuration"},{"location":"Release_Notes/v2022.22.0/#added-possibility-to-configure-execution-logs-storage-for-tasks-and-task-templates","text":"We have added a new option for tasks and task templates that allows selecting which type of execution logs should be stored, with three options: Store all - default behavior, all logs are generated and stored. Store failed - logs will be generated only if task execution fails. Store none - logs are not generated.","title":"Added possibility to configure Execution logs storage for tasks and task templates"},{"location":"Release_Notes/v2022.22.0/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"Release_Notes/v2022.22.0/#fixed-inability-to-create-an-azure-template-with-custom-lwm2m-objects-in-non-root-domain","text":"LwM2M objects created by means of custom object definitions can be now included in Azure integration templates by users in non-root domains.","title":"Fixed inability to create an Azure template with custom LwM2M objects in non-root domain"},{"location":"Release_Notes/v2022.22.0/#fixed-static-documentation-not-respecting-multitenancy","text":"We have fixed the behavior of static documentation (i.e. generated via files uploaded in the Resources panel ) so that it is only visible for users in relevant domains.","title":"Fixed static documentation not respecting multitenancy"},{"location":"Release_Notes/v2022.22.0/#fixed-different-results-of-reading-and-writing-executable-resources","text":"Writing to an executable resource caused the platform to report communication failure. We have aligned this behavior with the results of reading an executable resource, in which case a response with the correct 4.05 MethodNotAllowed error code is returned.","title":"Fixed different results of reading and writing executable resources"},{"location":"Release_Notes/v2022.3.2/","text":"v2022.3.2 # Previous version: v2021.24.5 Enhancements # New design and search engine for User Guide # We have introduced a new design that changes the look and feel of the Coiote DM User Guide by switching from the Sphinx tool to the MkDocs documentation generator. Thanks to this, the search engine is improved to bring more accuracy to your search results. Also, navigating document sections is now easier with the new clickable table of contents on the right-hand side. Improved logic and added search in device variables management # We have improved the logic of the device variables management in DMC - a view that is used as part of the Protocol tests functionality. Also, we have added a possibility to search by name and value for both single and group variables. Bug Fixes # Fixes in Hyperscaler Integration Center view # We have introduced a few changes to improve the UX and performance of HIC: - The state of the devices list tab is now reloading when changing the domain. - Adding/editing/deleting integration configurations is now performed while still inside the dialog window for each action. - A 1000-character validator has been added to all fields in the integration configuration - It's now possible to copy and preview inherited templates when the user is in a domain lower than that in which a given template was created. Fixed stepper component # We have adapted the stepper component so that its appearance is in line with the design system guidelines for Coiote DM.","title":"v2022.3.2"},{"location":"Release_Notes/v2022.3.2/#v202232","text":"Previous version: v2021.24.5","title":"v2022.3.2"},{"location":"Release_Notes/v2022.3.2/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.3.2/#new-design-and-search-engine-for-user-guide","text":"We have introduced a new design that changes the look and feel of the Coiote DM User Guide by switching from the Sphinx tool to the MkDocs documentation generator. Thanks to this, the search engine is improved to bring more accuracy to your search results. Also, navigating document sections is now easier with the new clickable table of contents on the right-hand side.","title":"New design and search engine for User Guide"},{"location":"Release_Notes/v2022.3.2/#improved-logic-and-added-search-in-device-variables-management","text":"We have improved the logic of the device variables management in DMC - a view that is used as part of the Protocol tests functionality. Also, we have added a possibility to search by name and value for both single and group variables.","title":"Improved logic and added search in device variables management"},{"location":"Release_Notes/v2022.3.2/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"Release_Notes/v2022.3.2/#fixes-in-hyperscaler-integration-center-view","text":"We have introduced a few changes to improve the UX and performance of HIC: - The state of the devices list tab is now reloading when changing the domain. - Adding/editing/deleting integration configurations is now performed while still inside the dialog window for each action. - A 1000-character validator has been added to all fields in the integration configuration - It's now possible to copy and preview inherited templates when the user is in a domain lower than that in which a given template was created.","title":"Fixes in Hyperscaler Integration Center view"},{"location":"Release_Notes/v2022.3.2/#fixed-stepper-component","text":"We have adapted the stepper component so that its appearance is in line with the design system guidelines for Coiote DM.","title":"Fixed stepper component"},{"location":"Release_Notes/v2022.5.3/","text":"v2022.5.3 # Previous version: v2022.3.2 Features # LwM2M CBOR support # Coiote DM now supports LwM2M CBOR, a new encoding format that was introduced in the Lightweight M2M 1.2 specification . It allows to significantly reduce the payload size of the Composite operations (Composite Read, Composite Write, Composite Observe). Kafka producer # Kafka is a new property category in the Domain properties view. By setting the properties, you create a Kafka producer that enables you to forward data from devices to your Kafka broker. Enhancements # New design of the Device test repository # We\u2019ve introduced a new look and a few changes to improve the UX of the Device tests repository: The Add test button now has two options. You can add a test manually or import tests from a .conf file. Better UI of the search, filter, delete, and mass delete actions. The Preview test option is now available from the context menu. Bug Fixes # HTTP status code 400 # Fixed a bug where REST API returned the HTTP status code 500 instead of 400. Now the correct 400 status code is returned in cases when, for example, a DTLS identity is already taken, when PSK contains an odd number of characters, or for the PUT/devices request.","title":"v2022.5.3"},{"location":"Release_Notes/v2022.5.3/#v202253","text":"Previous version: v2022.3.2","title":"v2022.5.3"},{"location":"Release_Notes/v2022.5.3/#features","text":"","title":"Features"},{"location":"Release_Notes/v2022.5.3/#lwm2m-cbor-support","text":"Coiote DM now supports LwM2M CBOR, a new encoding format that was introduced in the Lightweight M2M 1.2 specification . It allows to significantly reduce the payload size of the Composite operations (Composite Read, Composite Write, Composite Observe).","title":"LwM2M CBOR support"},{"location":"Release_Notes/v2022.5.3/#kafka-producer","text":"Kafka is a new property category in the Domain properties view. By setting the properties, you create a Kafka producer that enables you to forward data from devices to your Kafka broker.","title":"Kafka producer"},{"location":"Release_Notes/v2022.5.3/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.5.3/#new-design-of-the-device-test-repository","text":"We\u2019ve introduced a new look and a few changes to improve the UX of the Device tests repository: The Add test button now has two options. You can add a test manually or import tests from a .conf file. Better UI of the search, filter, delete, and mass delete actions. The Preview test option is now available from the context menu.","title":"New design of the Device test repository"},{"location":"Release_Notes/v2022.5.3/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"Release_Notes/v2022.5.3/#http-status-code-400","text":"Fixed a bug where REST API returned the HTTP status code 500 instead of 400. Now the correct 400 status code is returned in cases when, for example, a DTLS identity is already taken, when PSK contains an odd number of characters, or for the PUT/devices request.","title":"HTTP status code 400"},{"location":"Release_Notes/v2022.7.3/","text":"v2022.7.3 # Previous version: v2022.5.3 Enhancements # More formats in the XML Tasks # We\u2019ve added a new option in the readResource XML Task. You can now specify the format in which the file content should be read. The available formats are UTF-8 (default) and binary (reads data into a hex string). Furthermore, the REST tag now has the outBinary subtag. This means the payload of HTTP responses can be not only in JSON but also binary. New features in the Device test repository # SEND messages # You can now record and expect SEND messages when running your device tests. Previously, the record and expectation functionalities were only available for the Notify operations. To run the Start Send recording and Expect Send tasks, go to Device test repository > Server simulator . Click Add test > Add test manually and then select the relevant task from the Action list drop-down menu. In addition, the Send option was added to the Wait for uplink request task. Creation and modification dates # The Created and Last modified columns have been added to the Device test repository view . If no creation and modification dates are found, then the time of the migration to the new version of Coiote DM is set. Download device tests # You can download a single test or multiple tests as a .conf file. To do so, select the necessary tests from the list and click Download test from the context menu. Bug fixes # Fixed a bug where uploading large CSV files failed if it took longer than one minute. Fixed a bug where Coiote DM sometimes didn\u2019t reply to Register Update.","title":"v2022.7.3"},{"location":"Release_Notes/v2022.7.3/#v202273","text":"Previous version: v2022.5.3","title":"v2022.7.3"},{"location":"Release_Notes/v2022.7.3/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.7.3/#more-formats-in-the-xml-tasks","text":"We\u2019ve added a new option in the readResource XML Task. You can now specify the format in which the file content should be read. The available formats are UTF-8 (default) and binary (reads data into a hex string). Furthermore, the REST tag now has the outBinary subtag. This means the payload of HTTP responses can be not only in JSON but also binary.","title":"More formats in the XML Tasks"},{"location":"Release_Notes/v2022.7.3/#new-features-in-the-device-test-repository","text":"","title":"New features in the Device test repository"},{"location":"Release_Notes/v2022.7.3/#send-messages","text":"You can now record and expect SEND messages when running your device tests. Previously, the record and expectation functionalities were only available for the Notify operations. To run the Start Send recording and Expect Send tasks, go to Device test repository > Server simulator . Click Add test > Add test manually and then select the relevant task from the Action list drop-down menu. In addition, the Send option was added to the Wait for uplink request task.","title":"SEND messages"},{"location":"Release_Notes/v2022.7.3/#creation-and-modification-dates","text":"The Created and Last modified columns have been added to the Device test repository view . If no creation and modification dates are found, then the time of the migration to the new version of Coiote DM is set.","title":"Creation and modification dates"},{"location":"Release_Notes/v2022.7.3/#download-device-tests","text":"You can download a single test or multiple tests as a .conf file. To do so, select the necessary tests from the list and click Download test from the context menu.","title":"Download device tests"},{"location":"Release_Notes/v2022.7.3/#bug-fixes","text":"Fixed a bug where uploading large CSV files failed if it took longer than one minute. Fixed a bug where Coiote DM sometimes didn\u2019t reply to Register Update.","title":"Bug fixes"},{"location":"Release_Notes/v2022.8.2/","text":"v2022.8.2 # Previous version: v2022.7.3 Enhancements # UDP connector in standalone mode or disabled # We have removed the option of embedding the UDP connector within the Coiote DM main system process. The UDP connector can be now either disabled or work in standalone mode. When disabling, there is no need for building a new package - setting a single config property in cdm.conf is enough: udpConnector.mode = Disabled # Disabled or Enabled Simplified setup of AWS integration # We have simplified the setup of the AWS integration. Now building and updating new lambdas is automated using one configuration template with all the required lambdas and dependencies. The updated integration guide can be found here . Modification and creation dates in Device test repository # We have added modification and creation dates as new columns in the Device test repository. Updating user properties via API PATCH method # We have added a new PATCH method to the Users API. This allows for updating the following user properties via API: emailVerified , userEnabled , domain , password , roles , permissions , tosAccepted .","title":"v2022.8.2"},{"location":"Release_Notes/v2022.8.2/#v202282","text":"Previous version: v2022.7.3","title":"v2022.8.2"},{"location":"Release_Notes/v2022.8.2/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.8.2/#udp-connector-in-standalone-mode-or-disabled","text":"We have removed the option of embedding the UDP connector within the Coiote DM main system process. The UDP connector can be now either disabled or work in standalone mode. When disabling, there is no need for building a new package - setting a single config property in cdm.conf is enough: udpConnector.mode = Disabled # Disabled or Enabled","title":"UDP connector in standalone mode or disabled"},{"location":"Release_Notes/v2022.8.2/#simplified-setup-of-aws-integration","text":"We have simplified the setup of the AWS integration. Now building and updating new lambdas is automated using one configuration template with all the required lambdas and dependencies. The updated integration guide can be found here .","title":"Simplified setup of AWS integration"},{"location":"Release_Notes/v2022.8.2/#modification-and-creation-dates-in-device-test-repository","text":"We have added modification and creation dates as new columns in the Device test repository.","title":"Modification and creation dates in Device test repository"},{"location":"Release_Notes/v2022.8.2/#updating-user-properties-via-api-patch-method","text":"We have added a new PATCH method to the Users API. This allows for updating the following user properties via API: emailVerified , userEnabled , domain , password , roles , permissions , tosAccepted .","title":"Updating user properties via API PATCH method"},{"location":"Release_Notes/v2022.9.2/","text":"v2022.9.2 # Previous version: v2022.8.2 Enhancements # Edit device tests # You can now go to edit a test directly from the Device test repository . Select the necessary test from the list and click Edit test from the context menu. Please note that not all device tests are editable.","title":"v2022.9.2"},{"location":"Release_Notes/v2022.9.2/#v202292","text":"Previous version: v2022.8.2","title":"v2022.9.2"},{"location":"Release_Notes/v2022.9.2/#enhancements","text":"","title":"Enhancements"},{"location":"Release_Notes/v2022.9.2/#edit-device-tests","text":"You can now go to edit a test directly from the Device test repository . Select the necessary test from the list and click Edit test from the context menu. Please note that not all device tests are editable.","title":"Edit device tests"},{"location":"nRF_Cloud_Location_services/Configure_nRF_Cloud_integration/","text":"Connect nRF Cloud integration # Connect your nRF Cloud devices to Coiote DM to track their location and save battery life. Read more about Nordic Semiconductor Location services . Prerequisites # An nRF Cloud account. If you don't have it, create one here . A Coiote DM user account. If you don't have one, register here . To enable communication and data flow between the Nordic Semiconductor nRF Cloud and Coiote DM platforms, you first need to integrate them using the nRF Cloud integration in Coiote DM. Follow the instructions below to learn how to do it. Get the Service Evaluation Token from nRF Cloud # In your nRF Cloud user account, from the expandable top-right menu, select Team . In the Service Evaluation Token field, click Generate Token and click on the icon to copy it. Integrate nRF Cloud with Coiote DM # In your Coiote DM user account, go to Administration --> Integrations --> Location services . In the nRF Cloud tile, click Connect . In the dialog window, paste the previously copied nRFC Service Evaluation Token. click Save to keep the setting. Now the integration between Coiote DM and nRF Cloud is established. Read the next section on how to display device location in Coiote DM. View device location in Coiote DM # Caution To display your device location, you first need to set up the Google Maps property for your domain. Go to Coiote DM User Guide to learn how to do it. In your Coiote DM user account, go to Device Inventory . Click the Management link next to your device to enter the Device Center . If not selected, click the Overview tab and scroll down to the Device location section.","title":"Connect nRF Cloud integration"},{"location":"nRF_Cloud_Location_services/Configure_nRF_Cloud_integration/#connect-nrf-cloud-integration","text":"Connect your nRF Cloud devices to Coiote DM to track their location and save battery life. Read more about Nordic Semiconductor Location services .","title":"Connect nRF Cloud integration"},{"location":"nRF_Cloud_Location_services/Configure_nRF_Cloud_integration/#prerequisites","text":"An nRF Cloud account. If you don't have it, create one here . A Coiote DM user account. If you don't have one, register here . To enable communication and data flow between the Nordic Semiconductor nRF Cloud and Coiote DM platforms, you first need to integrate them using the nRF Cloud integration in Coiote DM. Follow the instructions below to learn how to do it.","title":"Prerequisites"},{"location":"nRF_Cloud_Location_services/Configure_nRF_Cloud_integration/#get-the-service-evaluation-token-from-nrf-cloud","text":"In your nRF Cloud user account, from the expandable top-right menu, select Team . In the Service Evaluation Token field, click Generate Token and click on the icon to copy it.","title":"Get the Service Evaluation Token from nRF Cloud"},{"location":"nRF_Cloud_Location_services/Configure_nRF_Cloud_integration/#integrate-nrf-cloud-with-coiote-dm","text":"In your Coiote DM user account, go to Administration --> Integrations --> Location services . In the nRF Cloud tile, click Connect . In the dialog window, paste the previously copied nRFC Service Evaluation Token. click Save to keep the setting. Now the integration between Coiote DM and nRF Cloud is established. Read the next section on how to display device location in Coiote DM.","title":"Integrate nRF Cloud with Coiote DM"},{"location":"nRF_Cloud_Location_services/Configure_nRF_Cloud_integration/#view-device-location-in-coiote-dm","text":"Caution To display your device location, you first need to set up the Google Maps property for your domain. Go to Coiote DM User Guide to learn how to do it. In your Coiote DM user account, go to Device Inventory . Click the Management link next to your device to enter the Device Center . If not selected, click the Overview tab and scroll down to the Device location section.","title":"View device location in Coiote DM"}]}