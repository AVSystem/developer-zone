{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome # Welcome to the AVSystem DevZone! In the DevZone you will find documentation related to our scalable LwM2M Server Coiote IoT Device Management platform , as well as our LwM2M Client Anjay . Quick Start Guide # Follow the Quick Start to build your first LwM2M application using a simulated device within 20 minutes. The guide walks you through the process of building your first LwM2M application using AVSystem\u2019s LwM2M Client Anjay and AVSystem\u2019s LwM2M Server Coiote IoT Device Management platform . Quick Start Get started with popular hardware platforms # Follow the Getting Started Guides to kickstart your LwM2M application using one of the popular hardware platforms: Nordic , STMicroelectronics , ESPRESSIF or Raspberry Pi . Learn more about Coiote IoT DM # Dive into Coiote IoT Device Management platform, the scalable LwM2M server and explore its numerous features. From device onboarding to Data Visualization and running automated Device Tests . Coiote IoT DM docs Explore cloud integrations # With the Coiote IoT Device Management platform, you can easily integrate your LwM2M data with platforms such as Azure IoT Hub , AWS IoT Core , nRF Cloud Location Services , InfluxDB or any public endpoint or Kafka cluster using the Data Integration Center. The guides will take you on a step-by-step journey to seamlessly activate the integrations. Webhooks Kafka Azure IoT LwM2M Academy # Take a deep-dive into the LwM2M standard by following the LwM2M Academy . A comprehensive online course designed to provide you with both the theoretical understanding and hands-on skills necessary to utilize the powerful LwM2M standard. Join course Join our community on Discord # Join us on Discord to get in touch with AVSystem experts and to meet fellow LwM2M developers.","title":"Welcome"},{"location":"#welcome","text":"Welcome to the AVSystem DevZone! In the DevZone you will find documentation related to our scalable LwM2M Server Coiote IoT Device Management platform , as well as our LwM2M Client Anjay .","title":"Welcome"},{"location":"#quick-start-guide","text":"Follow the Quick Start to build your first LwM2M application using a simulated device within 20 minutes. The guide walks you through the process of building your first LwM2M application using AVSystem\u2019s LwM2M Client Anjay and AVSystem\u2019s LwM2M Server Coiote IoT Device Management platform . Quick Start","title":"Quick Start Guide"},{"location":"#get-started-with-popular-hardware-platforms","text":"Follow the Getting Started Guides to kickstart your LwM2M application using one of the popular hardware platforms: Nordic , STMicroelectronics , ESPRESSIF or Raspberry Pi .","title":"Get started with popular hardware platforms"},{"location":"#learn-more-about-coiote-iot-dm","text":"Dive into Coiote IoT Device Management platform, the scalable LwM2M server and explore its numerous features. From device onboarding to Data Visualization and running automated Device Tests . Coiote IoT DM docs","title":"Learn more about Coiote IoT DM"},{"location":"#explore-cloud-integrations","text":"With the Coiote IoT Device Management platform, you can easily integrate your LwM2M data with platforms such as Azure IoT Hub , AWS IoT Core , nRF Cloud Location Services , InfluxDB or any public endpoint or Kafka cluster using the Data Integration Center. The guides will take you on a step-by-step journey to seamlessly activate the integrations. Webhooks Kafka Azure IoT","title":"Explore cloud integrations"},{"location":"#lwm2m-academy","text":"Take a deep-dive into the LwM2M standard by following the LwM2M Academy . A comprehensive online course designed to provide you with both the theoretical understanding and hands-on skills necessary to utilize the powerful LwM2M standard. Join course","title":"LwM2M Academy"},{"location":"#join-our-community-on-discord","text":"Join us on Discord to get in touch with AVSystem experts and to meet fellow LwM2M developers.","title":"Join our community on Discord"},{"location":"cloud-integrations/","text":"IoT Cloud Integrations # With the Coiote IoT Device Management platform, you can integrate your LwM2M devices with Microsoft Azure, AWS and nRF Cloud. These guides will take you on a step-by-step journey to seamlessly activate the integrations. Microsoft Azure integrations # Here\u2019s how you can get started with the Coiote IoT DM \u2013 Azure IoT integration: Azure IoT Hub Azure IoT Central Azure DPS AWS integration # Integrate Coiote IoT DM with the Amazon Web Services and gain new opportunities to leverage your IoT data. Integrate with AWS nRF Cloud Location services # Integrate Coiote IoT DM with the nRF Cloud Location Services to track your devices' location and save battery life. Integrate with nRF Cloud","title":"IoT Cloud Integrations"},{"location":"cloud-integrations/#iot-cloud-integrations","text":"With the Coiote IoT Device Management platform, you can integrate your LwM2M devices with Microsoft Azure, AWS and nRF Cloud. These guides will take you on a step-by-step journey to seamlessly activate the integrations.","title":"IoT Cloud Integrations"},{"location":"cloud-integrations/#microsoft-azure-integrations","text":"Here\u2019s how you can get started with the Coiote IoT DM \u2013 Azure IoT integration: Azure IoT Hub Azure IoT Central Azure DPS","title":"Microsoft Azure integrations"},{"location":"cloud-integrations/#aws-integration","text":"Integrate Coiote IoT DM with the Amazon Web Services and gain new opportunities to leverage your IoT data. Integrate with AWS","title":"AWS integration"},{"location":"cloud-integrations/#nrf-cloud-location-services","text":"Integrate Coiote IoT DM with the nRF Cloud Location Services to track your devices' location and save battery life. Integrate with nRF Cloud","title":"nRF Cloud Location services"},{"location":"quickstart/","text":"Quick Start # Welcome to the DevZone of AVSystem! # This Quick Start walks you through the process of building your first LwM2M application using AVSystem\u2019s LwM2M Client Anjay and AVSystem\u2019s LwM2M Server Coiote IoT Device Management platform . Follow this guide to build your first LwM2M application using a simulated device within 20 minutes. Access the Coiote IoT DM portal # Get started by signing up to Coiote IoT Device Management platform. You can sign up for a developer account, which allows you to connect up to 10 devices free of charge. Coiote IoT DM Run Anjay LwM2M Client Demo # Anjay LwM2M SDK is a set of tools that enables device vendors and IoT developers to easily implement a LwM2M client on their hardware. It is available both in an advanced commercial version and in the open-source model, you can find it on GitHub . Start by running the Anjay client on your Linux , Mac or Windows machine and simulate LwM2M telemetry data. Try Anjay demo client to onboard your first simulated device. Note If preferred, you can directly jump to the Getting Started guides of the popular hardware platforms: Nordic STMicroelectronics ESP32 Raspberry Pi Pico W Info For more information about the Anjay LwM2M Client, visit the Anjay Library Documentation . Add a new device in Coiote IoT DM # After compiling the demo project, go back to the Coiote IoT DM portal . Click + Add device in the top-right corner. Add a new device using the option: Anjay LwM2M Client Demo Copy the command you find in Coiote IoT DM. Go back to your terminal, open your Anjay directory and run the command to configure and activate the demo application. Monitor your demo device in the Coiote IoT DM # If the demo application started successfully, a device is shown in theCoiote IoT DMplatform. Review the Data model # Go to the Data model tab in the top-menu. Under Data model you will find all the configured LwM2M Objects , Object instances and Resources containing property values or telemetry data. This includes: Object /1 LwM2M Resource /0 Short Server ID Resource /1 Lifetime Etc. Object /3 Device Resource /0 Manufacturer Resource /1 Modem Number Resource /2 Serial Number Etc. Object /6 Location Resource /0 Latitude Resource /1 Longitude Resource /2 Altitude Etc. Object /3303 Temperature Resource /5601 Min Measured Value Resource /5602 Max Measured Value Resource /5700 Sensor Value Etc. Next steps # Did you manage to run the Anjay LwM2M Client Demo? Well done! \ud83d\udc4f Now the fun begins. Below you can find useful links to continue your LwM2M journey. Get started with popular hardware platforms # Follow the Getting started guides to kickstart your LwM2M application using one of the popular hardware platforms: Nordic , STMicroelectronics , ESPRESSIF or Raspberry Pi . Learn more about Coiote IoT DM # Dive into Coiote IoT Device Management platform and explore its numerous functionalities. From device onboarding using the Bootstrap Server to Data Visualization and running automated Device Tests . Coiote IoT DM docs Join our community on Discord # Join us on Discord to get in touch with AVSystem experts and to meet fellow LwM2M developers.","title":"Quick Start"},{"location":"quickstart/#quick-start","text":"","title":"Quick Start"},{"location":"quickstart/#welcome-to-the-devzone-of-avsystem","text":"This Quick Start walks you through the process of building your first LwM2M application using AVSystem\u2019s LwM2M Client Anjay and AVSystem\u2019s LwM2M Server Coiote IoT Device Management platform . Follow this guide to build your first LwM2M application using a simulated device within 20 minutes.","title":"Welcome to the DevZone of AVSystem!"},{"location":"quickstart/#access-the-coiote-iot-dm-portal","text":"Get started by signing up to Coiote IoT Device Management platform. You can sign up for a developer account, which allows you to connect up to 10 devices free of charge. Coiote IoT DM","title":"Access the Coiote IoT DM portal"},{"location":"quickstart/#run-anjay-lwm2m-client-demo","text":"Anjay LwM2M SDK is a set of tools that enables device vendors and IoT developers to easily implement a LwM2M client on their hardware. It is available both in an advanced commercial version and in the open-source model, you can find it on GitHub . Start by running the Anjay client on your Linux , Mac or Windows machine and simulate LwM2M telemetry data. Try Anjay demo client to onboard your first simulated device. Note If preferred, you can directly jump to the Getting Started guides of the popular hardware platforms: Nordic STMicroelectronics ESP32 Raspberry Pi Pico W Info For more information about the Anjay LwM2M Client, visit the Anjay Library Documentation .","title":"Run Anjay LwM2M Client Demo"},{"location":"quickstart/#add-a-new-device-in-coiote-iot-dm","text":"After compiling the demo project, go back to the Coiote IoT DM portal . Click + Add device in the top-right corner. Add a new device using the option: Anjay LwM2M Client Demo Copy the command you find in Coiote IoT DM. Go back to your terminal, open your Anjay directory and run the command to configure and activate the demo application.","title":"Add a new device in Coiote IoT DM"},{"location":"quickstart/#monitor-your-demo-device-in-the-coiote-iot-dm","text":"If the demo application started successfully, a device is shown in theCoiote IoT DMplatform.","title":"Monitor your demo device in the Coiote IoT DM"},{"location":"quickstart/#review-the-data-model","text":"Go to the Data model tab in the top-menu. Under Data model you will find all the configured LwM2M Objects , Object instances and Resources containing property values or telemetry data. This includes: Object /1 LwM2M Resource /0 Short Server ID Resource /1 Lifetime Etc. Object /3 Device Resource /0 Manufacturer Resource /1 Modem Number Resource /2 Serial Number Etc. Object /6 Location Resource /0 Latitude Resource /1 Longitude Resource /2 Altitude Etc. Object /3303 Temperature Resource /5601 Min Measured Value Resource /5602 Max Measured Value Resource /5700 Sensor Value Etc.","title":"Review the Data model"},{"location":"quickstart/#next-steps","text":"Did you manage to run the Anjay LwM2M Client Demo? Well done! \ud83d\udc4f Now the fun begins. Below you can find useful links to continue your LwM2M journey.","title":"Next steps"},{"location":"quickstart/#get-started-with-popular-hardware-platforms","text":"Follow the Getting started guides to kickstart your LwM2M application using one of the popular hardware platforms: Nordic , STMicroelectronics , ESPRESSIF or Raspberry Pi .","title":"Get started with popular hardware platforms"},{"location":"quickstart/#learn-more-about-coiote-iot-dm","text":"Dive into Coiote IoT Device Management platform and explore its numerous functionalities. From device onboarding using the Bootstrap Server to Data Visualization and running automated Device Tests . Coiote IoT DM docs","title":"Learn more about Coiote IoT DM"},{"location":"quickstart/#join-our-community-on-discord","text":"Join us on Discord to get in touch with AVSystem experts and to meet fellow LwM2M developers.","title":"Join our community on Discord"},{"location":"Coiote_IoT_DM/introduction/","text":"Coiote IoT Device Management platform # Coiote IoT Device Management platform allows you to manage your LwM2M devices throughout their entire lifecycle. Coiote IoT DM supports device onboarding, data management, data visualization, automated tests, firmware updates, and cloud integrations. Visit Coiote IoT DM website Sign up free of charge Get started by signing up to Coiote IoT Device Management platform. You can sign up for a developer account which allows you to connect up to 10 devices free of charge. Features # Note Features marked with an \"*\" are only included in the premium version of Coiote IoT DM. Device inventory # The Device inventory provides a comprehensive overview of all registered LwM2M devices. After selecting one of your devices, you enter the Device center which allows you to monitor and manage single devices. In the Device center , you can: Adjust device configurations Perform operations on device data model Schedule firmware updates Visualize device data Access detailed device logs The key features of Device center include: Device analytics : The Device analytics board provides tools for monitoring and visualizing device data through customizable widgets. It supports real-time and historical data analysis with options to adjust time ranges, zoom into charts, and enable live data display with five-second refresh intervals. Widgets can be reordered, or removed to suit specific monitoring needs, and device monitoring can be toggled to control data collection and storage. Device logs : The Device logs tab offers detailed visibility into log data for troubleshooting and performance monitoring. It includes a histogram for log volume analysis, a searchable and filterable log entries list, and tools for defining relative or absolute time ranges for log retrieval. Real-time monitoring is supported with live log updates, and filters allow targeted viewing for protocols such as CoAP and LwM2M. Device groups* # Devices can be added to Groups allowing for easy management of your device fleet. Instead of managing devices one by one, configurations can be updated for a group of devices with a single click. Integrations # Coiote IoT DM supports integrations with popular cloud platforms such as Azure IoT Hub , AWS IoT Core or nRF Cloud . The Device Integration Center enables the configuration of Webhook and Kafka event handlers, supporting real-time event streaming and tailored device interactions. Device test repository* # You can test performance of your device firmware by mimicking real-world scenarios. Device tests allow you to validate new application firmware, to test the implementation of the LwM2M standard, and to run regression tests to ensure new firmware doesn\u2019t break existing functionality. Fleet FOTA # This feature allows efficient firmware updates across your entire device fleet. You can create FOTA configurations to define update parameters, such as target firmware versions and use it later for an update on a single device or to create a FOTA campaign . FOTA campaigns enable you to plan, schedule, and monitor large-scale updates for specific groups of devices. Administration # The administration section provides tools for configuring platform settings, including Billing , User management , and Domain management . LwM2M Gateway # Coiote DM includes a LwM2M Gateway implementation enabling IoT devices without native LwM2M support to communicate with an LwM2M Server. It facilitates message routing, device representation, and security management while ensuring seamless integration with the server. When a device operates as an LwM2M Gateway, the End IoT Devices tab appears in the Device Center, allowing users to: Search for end devices by Device ID or End IoT Device Objects. View device details, including instance, prefix, and last operation time. Navigate to the End IoT Device\u2019s management view or its instance in the gateway Data model tab. Info A comprehensive and detailed description of all platform features, can be found in the user documentation available after logging into the platform.","title":"Introduction"},{"location":"Coiote_IoT_DM/introduction/#coiote-iot-device-management-platform","text":"Coiote IoT Device Management platform allows you to manage your LwM2M devices throughout their entire lifecycle. Coiote IoT DM supports device onboarding, data management, data visualization, automated tests, firmware updates, and cloud integrations. Visit Coiote IoT DM website Sign up free of charge Get started by signing up to Coiote IoT Device Management platform. You can sign up for a developer account which allows you to connect up to 10 devices free of charge.","title":"Coiote IoT Device Management platform"},{"location":"Coiote_IoT_DM/introduction/#features","text":"Note Features marked with an \"*\" are only included in the premium version of Coiote IoT DM.","title":"Features"},{"location":"Coiote_IoT_DM/introduction/#device-inventory","text":"The Device inventory provides a comprehensive overview of all registered LwM2M devices. After selecting one of your devices, you enter the Device center which allows you to monitor and manage single devices. In the Device center , you can: Adjust device configurations Perform operations on device data model Schedule firmware updates Visualize device data Access detailed device logs The key features of Device center include: Device analytics : The Device analytics board provides tools for monitoring and visualizing device data through customizable widgets. It supports real-time and historical data analysis with options to adjust time ranges, zoom into charts, and enable live data display with five-second refresh intervals. Widgets can be reordered, or removed to suit specific monitoring needs, and device monitoring can be toggled to control data collection and storage. Device logs : The Device logs tab offers detailed visibility into log data for troubleshooting and performance monitoring. It includes a histogram for log volume analysis, a searchable and filterable log entries list, and tools for defining relative or absolute time ranges for log retrieval. Real-time monitoring is supported with live log updates, and filters allow targeted viewing for protocols such as CoAP and LwM2M.","title":"Device inventory"},{"location":"Coiote_IoT_DM/introduction/#device-groups","text":"Devices can be added to Groups allowing for easy management of your device fleet. Instead of managing devices one by one, configurations can be updated for a group of devices with a single click.","title":"Device groups*"},{"location":"Coiote_IoT_DM/introduction/#integrations","text":"Coiote IoT DM supports integrations with popular cloud platforms such as Azure IoT Hub , AWS IoT Core or nRF Cloud . The Device Integration Center enables the configuration of Webhook and Kafka event handlers, supporting real-time event streaming and tailored device interactions.","title":"Integrations"},{"location":"Coiote_IoT_DM/introduction/#device-test-repository","text":"You can test performance of your device firmware by mimicking real-world scenarios. Device tests allow you to validate new application firmware, to test the implementation of the LwM2M standard, and to run regression tests to ensure new firmware doesn\u2019t break existing functionality.","title":"Device test repository*"},{"location":"Coiote_IoT_DM/introduction/#fleet-fota","text":"This feature allows efficient firmware updates across your entire device fleet. You can create FOTA configurations to define update parameters, such as target firmware versions and use it later for an update on a single device or to create a FOTA campaign . FOTA campaigns enable you to plan, schedule, and monitor large-scale updates for specific groups of devices.","title":"Fleet FOTA"},{"location":"Coiote_IoT_DM/introduction/#administration","text":"The administration section provides tools for configuring platform settings, including Billing , User management , and Domain management .","title":"Administration"},{"location":"Coiote_IoT_DM/introduction/#lwm2m-gateway","text":"Coiote DM includes a LwM2M Gateway implementation enabling IoT devices without native LwM2M support to communicate with an LwM2M Server. It facilitates message routing, device representation, and security management while ensuring seamless integration with the server. When a device operates as an LwM2M Gateway, the End IoT Devices tab appears in the Device Center, allowing users to: Search for end devices by Device ID or End IoT Device Objects. View device details, including instance, prefix, and last operation time. Navigate to the End IoT Device\u2019s management view or its instance in the gateway Data model tab. Info A comprehensive and detailed description of all platform features, can be found in the user documentation available after logging into the platform.","title":"LwM2M Gateway"},{"location":"Coiote_IoT_DM/API_documentation/api_reference/","text":"API reference # To access the API reference, see Coiote API reference .","title":"API reference"},{"location":"Coiote_IoT_DM/API_documentation/api_reference/#api-reference","text":"To access the API reference, see Coiote API reference .","title":"API reference"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Basic_onboarding/","text":"How to make basic onboarding # Prerequisites: An active Coiote IoT DM user account Endpoints used: POST /devices POST /devices/batch POST /observations/device/{deviceId}/{path} POST /devices/{id} Overview # Basic onboarding includes adding single device or device batch, setting observations and getting data about devices. Step 1: Add a single device or multiple devices # Add a single device # Send a POST request to the endpoint /devices . In the request body provide the device object. The information that you have to provide is domain, security, and connector type. If you don\u2019t provide device identity, you have to set properties.endpointName instead. Note It is recommended to use properties.endpointName instead of id in POST requests. You can include the following data in the device object: Name Description id The form and scope of a device ID may differ depending on an installation. It is recommended to use properties.endpointName instead of ID. connectorType Possible values: bootstrap: the device supports bootstrap and has extended management options management: the device doesn\u2019t support bootstrap and has basic management options directGroups Array of groups to which the created device will belong properties Additional properties, for example, endpointName blacklisted Determines whether the device is blacklisted after creation. managementEnabled Determines whether the device has the management enabled lastSessionTime Execution time of the last session on a device. The provisioning session can be started not only by an uplink request but also by a quick fix, session trigger, or API request. lastContactTime The time of the last successful network communication with the device lastRegisterTime The time of the last successful register request from a device. firstRegisterTime The time of the first successful register request from a device. creationTime The time of adding the device to the system. ipAddress Device IP address serialNumber Device serial number oui Device OUI modelName Device model name hardwareVersion The version of the device hardware softwareVersion The version of the device software productClass Identifier of the class of product for which the serial number applies. The value must be the same as the value of the Devicelnfo.ProductClass parameter. It must remain fixed over the lifetime of the device, including across firmware updates. Any change would indicate that it is a new device and would therefore require a BOOTSTRAP Inform. manufacturer IP address of the device description Device description friendlyName Device friendly name domain Domain to which you want your device to belong. A domain must start and end with / sign. You need to have access to the domain. securityMode If connectorType is bootstrap, the bootstrap security method will be used. If connectorType is management, in this field you determine how the device will be authenticated during connection. Used for both DTLS and TLS settings. Possible values: psk: pre-shared key cert: certificate rpk: raw public key (for more info read the specification) nosec: device can use unencrypted connection unknown notset: no value. The device will not be able to connect. The value can be set later manually or during a specific process. dtlsIdentity Identity used for the DTLS authentication dtlsPsk The parameter allows setting PSK in Plain text, Hexadecimal, and Raw binary format. For psk stored externally use the format: {\"ExternalPsk\": {}}. For psk stored globally use the format: {\"GlobalPsk\": {}}. The following is an example of the request: cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"connectorType\":\"management\",\"directGroups\":[\"root.mt.exampleGroup\"],\"properties\":{\"endpointName\":\"exampleUniqueEndpointName\",\"exampleAdditionalProperty\":\"exampleAdditionalValue\"},\"domain\":\"/exampleDomain/\",\"securityMode\":\"psk\",\"dtlsIdentity\":\"exampleUniqueEndpointName\", \"dtlsPsk\":{\"HexadecimalPsk\":\"4444\"}}' \\ https://#HOSTNAME/api/coiotedm/v3/devices Coiote Python from coiote.client import Coiote from coiote.v3.model.devices import ConnectorType , Device , HexStringPsk coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) device = Device ( connectorType = ConnectorType . management , directGroups = [ \"root.mt.exampleGroup\" ], properties = { \"endpointName\" : \"exampleUniqueEndpointName\" , \"exampleAdditionalProperty\" : \"exampleAdditionalValue\" }, domain = \"/exampleDomain/\" , securityMode = \"psk\" , dtlsIdentity = \"exampleUniqueEndpointName\" , dtlsPsk = HexStringPsk ( \"4444\" ) ) print ( client . devices . create_one ( device ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Add multiple devices in a batch # Send a POST request to the endpoint /devices/batch with an array of device objects in the request body. You can add up to 100 devices. The following is an example of the request creating two devices: cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '[{\"connectorType\": \"management\",\"directGroups\": [\"root.mt.exampleGroup\"],\"properties\": {\"endpointName\": \"exampleUniqueEndpointName1\", \"exampleAdditionalProperty\": \"exampleAdditionalValue\"},\"domain\": \"/exampleDomain/\",\"securityMode\": \"psk\",\"dtlsIdentity\":\"exampleUniqueEndpointName1\", \"dtlsPsk\": {\"HexadecimalPsk\": \"4444\"}},{\"connectorType\": \"management\",\"directGroups\": [\"root.mt.exampleGroup\"],\"properties\":{\"endpointName\":\"exampleUniqueEndpointName2\",\"exampleAdditionalProperty\": \"exampleAdditionalValue\"},\"domain\": \"/exampleDomain/\", \"securityMode\": \"psk\",\"dtlsIdentity\": \"exampleUniqueEndpointName2\",\"dtlsPsk\": {\"HexadecimalPsk\": \"4444\"}}]' \\ https://#HOSTNAME/api/coiotedm/v3/devices/batch Coiote Python from coiote.client import Coiote from coiote.v3.model.devices import ConnectorType , Device , HexStringPsk coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) devices = [ Device ( connectorType = ConnectorType . management , directGroups = [ \"root.mt.exampleGroup\" ], properties = { \"endpointName\" : \"exampleUniqueEndpointName1\" , \"exampleAdditionalProperty\" : \"exampleAdditionalValue\" }, domain = \"/exampleDomain/\" , securityMode = \"psk\" , dtlsIdentity = \"exampleUniqueEndpointName1\" , dtlsPsk = HexStringPsk ( \"4444\" ) ), Device ( connectorType = ConnectorType . management , directGroups = [ \"root.mt.exampleGroup\" ], properties = { \"endpointName\" : \"exampleUniqueEndpointName2\" , \"exampleAdditionalProperty\" : \"exampleAdditionalValue\" }, domain = \"/exampleDomain/\" , securityMode = \"psk\" , dtlsIdentity = \"exampleUniqueEndpointName2\" , dtlsPsk = HexStringPsk ( \"4444\" ) ), ] print ( client . devices . create_batch ( devices ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Step 2: Create observations # To create observations for a device, send a POST request to the endpoint /observations/device/{deviceId}/{path} . Provide the ID of the device to which you want to add the observation and the path to the device resource you want to use. Use the Human readable path format (for example, \u201cDevice.0.Battery Level\u201d). The path can point to Object, Object Instance, or Resource. Note To learn more about standard LwM2M Object and Resource Registry, see the OMA LwM2M specification . In the request body provide observation attributes (name and value pair) and specify if you want to create ensureObservationTask. Use one of the valid observation attributes: 'pmin', 'pmax', 'gt', 'lt', and 'st'. Note To learn more about observation attributes, see Attributes . If you create ensureObservationTask, the system automatically checks if the observations are enabled on the device, during every provisioning session. The following is an example of the request, where you want to get a notification about the level of battery power every two minutes: cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"attributes\": [{\"name\": \"pmax\",\"value\": \"120\"}],\"createEnsureObserveIfNotExists\": false}' \\ https://#HOSTNAME/api/coiotedm/v3/observations/device/api-test-device/Device.0.Battery%20Level Coiote Python from coiote.client import Coiote from coiote.v3.model.observations import ObservationAttribute , SetObservationRequest coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) observation = SetObservationRequest ( attributes = [ ObservationAttribute ( \"pmax\" , \"120\" )] ) print ( client . observations . set_observation_on_device ( device_id = \"api-test-device\" , path = \"Device.0.Battery Level\" , data = observation ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Step 3: Get data about devices # Retrieve all data about a specific device # Send a GET request to the endpoint /devices/{id} using the device ID as the path parameter. The following is an example of the request: cURL curl -X GET \\ -H \"Authorization: Bearer #TOKEN\" \\ https://#HOSTNAME/api/coiotedm/v3/devices/api-test-device Coiote Python from coiote.client import Coiote coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . devices . get_one ( device_id = \"api-test-device\" ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Retrieve specific data about all devices # Send a GET request to the endpoint /devices/find/details . Use query parameters to adjust your request: searchCriteria - conditions for retrieving the data. Use the form 'fieldName operator value', where the fieldName refers to the field in the device object. For example, id startswith '123', or managementEnabled eq true. You can find the list of possible fieldNames with allowed operators in the API reference for this endpoint. fieldSelection - fields from the device object that you want to retrieve. For example domain , serialNumber . limit - how many records are to be retrieved. The minimum value is 0, the maximum is 1000. If you leave it empty, 100 is set as default. pageBookmark - if you leave this parameter empty, you will get the first page. To get the next page, use the bookmark value returned in the previous request. The following is an example of the request, where you want to get domains of devices that have enabled management and limit the result to 10: cURL curl -X GET \\ -H \"accept: application/json\" \\ -H \"Authorization: Bearer #TOKEN\" \\ \"https://#HOSTNAME/api/coiotedm/v3/devices/find/details?searchCriteria=managementEnabled%20eq%20true&fieldSelection=domain&limit=10\" Coiote Python from coiote.client import Coiote coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . devices . get_device_details ( search_criteria = \"managementEnabled eq true\" , fields = [ \"domain\" ], limit = 10 ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"How to make basic onboarding"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Basic_onboarding/#how-to-make-basic-onboarding","text":"Prerequisites: An active Coiote IoT DM user account Endpoints used: POST /devices POST /devices/batch POST /observations/device/{deviceId}/{path} POST /devices/{id}","title":"How to make basic onboarding"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Basic_onboarding/#overview","text":"Basic onboarding includes adding single device or device batch, setting observations and getting data about devices.","title":"Overview"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Basic_onboarding/#step-1-add-a-single-device-or-multiple-devices","text":"","title":"Step 1: Add a single device or multiple devices"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Basic_onboarding/#add-a-single-device","text":"Send a POST request to the endpoint /devices . In the request body provide the device object. The information that you have to provide is domain, security, and connector type. If you don\u2019t provide device identity, you have to set properties.endpointName instead. Note It is recommended to use properties.endpointName instead of id in POST requests. You can include the following data in the device object: Name Description id The form and scope of a device ID may differ depending on an installation. It is recommended to use properties.endpointName instead of ID. connectorType Possible values: bootstrap: the device supports bootstrap and has extended management options management: the device doesn\u2019t support bootstrap and has basic management options directGroups Array of groups to which the created device will belong properties Additional properties, for example, endpointName blacklisted Determines whether the device is blacklisted after creation. managementEnabled Determines whether the device has the management enabled lastSessionTime Execution time of the last session on a device. The provisioning session can be started not only by an uplink request but also by a quick fix, session trigger, or API request. lastContactTime The time of the last successful network communication with the device lastRegisterTime The time of the last successful register request from a device. firstRegisterTime The time of the first successful register request from a device. creationTime The time of adding the device to the system. ipAddress Device IP address serialNumber Device serial number oui Device OUI modelName Device model name hardwareVersion The version of the device hardware softwareVersion The version of the device software productClass Identifier of the class of product for which the serial number applies. The value must be the same as the value of the Devicelnfo.ProductClass parameter. It must remain fixed over the lifetime of the device, including across firmware updates. Any change would indicate that it is a new device and would therefore require a BOOTSTRAP Inform. manufacturer IP address of the device description Device description friendlyName Device friendly name domain Domain to which you want your device to belong. A domain must start and end with / sign. You need to have access to the domain. securityMode If connectorType is bootstrap, the bootstrap security method will be used. If connectorType is management, in this field you determine how the device will be authenticated during connection. Used for both DTLS and TLS settings. Possible values: psk: pre-shared key cert: certificate rpk: raw public key (for more info read the specification) nosec: device can use unencrypted connection unknown notset: no value. The device will not be able to connect. The value can be set later manually or during a specific process. dtlsIdentity Identity used for the DTLS authentication dtlsPsk The parameter allows setting PSK in Plain text, Hexadecimal, and Raw binary format. For psk stored externally use the format: {\"ExternalPsk\": {}}. For psk stored globally use the format: {\"GlobalPsk\": {}}. The following is an example of the request: cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"connectorType\":\"management\",\"directGroups\":[\"root.mt.exampleGroup\"],\"properties\":{\"endpointName\":\"exampleUniqueEndpointName\",\"exampleAdditionalProperty\":\"exampleAdditionalValue\"},\"domain\":\"/exampleDomain/\",\"securityMode\":\"psk\",\"dtlsIdentity\":\"exampleUniqueEndpointName\", \"dtlsPsk\":{\"HexadecimalPsk\":\"4444\"}}' \\ https://#HOSTNAME/api/coiotedm/v3/devices Coiote Python from coiote.client import Coiote from coiote.v3.model.devices import ConnectorType , Device , HexStringPsk coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) device = Device ( connectorType = ConnectorType . management , directGroups = [ \"root.mt.exampleGroup\" ], properties = { \"endpointName\" : \"exampleUniqueEndpointName\" , \"exampleAdditionalProperty\" : \"exampleAdditionalValue\" }, domain = \"/exampleDomain/\" , securityMode = \"psk\" , dtlsIdentity = \"exampleUniqueEndpointName\" , dtlsPsk = HexStringPsk ( \"4444\" ) ) print ( client . devices . create_one ( device ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Add a single device"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Basic_onboarding/#add-multiple-devices-in-a-batch","text":"Send a POST request to the endpoint /devices/batch with an array of device objects in the request body. You can add up to 100 devices. The following is an example of the request creating two devices: cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '[{\"connectorType\": \"management\",\"directGroups\": [\"root.mt.exampleGroup\"],\"properties\": {\"endpointName\": \"exampleUniqueEndpointName1\", \"exampleAdditionalProperty\": \"exampleAdditionalValue\"},\"domain\": \"/exampleDomain/\",\"securityMode\": \"psk\",\"dtlsIdentity\":\"exampleUniqueEndpointName1\", \"dtlsPsk\": {\"HexadecimalPsk\": \"4444\"}},{\"connectorType\": \"management\",\"directGroups\": [\"root.mt.exampleGroup\"],\"properties\":{\"endpointName\":\"exampleUniqueEndpointName2\",\"exampleAdditionalProperty\": \"exampleAdditionalValue\"},\"domain\": \"/exampleDomain/\", \"securityMode\": \"psk\",\"dtlsIdentity\": \"exampleUniqueEndpointName2\",\"dtlsPsk\": {\"HexadecimalPsk\": \"4444\"}}]' \\ https://#HOSTNAME/api/coiotedm/v3/devices/batch Coiote Python from coiote.client import Coiote from coiote.v3.model.devices import ConnectorType , Device , HexStringPsk coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) devices = [ Device ( connectorType = ConnectorType . management , directGroups = [ \"root.mt.exampleGroup\" ], properties = { \"endpointName\" : \"exampleUniqueEndpointName1\" , \"exampleAdditionalProperty\" : \"exampleAdditionalValue\" }, domain = \"/exampleDomain/\" , securityMode = \"psk\" , dtlsIdentity = \"exampleUniqueEndpointName1\" , dtlsPsk = HexStringPsk ( \"4444\" ) ), Device ( connectorType = ConnectorType . management , directGroups = [ \"root.mt.exampleGroup\" ], properties = { \"endpointName\" : \"exampleUniqueEndpointName2\" , \"exampleAdditionalProperty\" : \"exampleAdditionalValue\" }, domain = \"/exampleDomain/\" , securityMode = \"psk\" , dtlsIdentity = \"exampleUniqueEndpointName2\" , dtlsPsk = HexStringPsk ( \"4444\" ) ), ] print ( client . devices . create_batch ( devices ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Add multiple devices in a batch"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Basic_onboarding/#step-2-create-observations","text":"To create observations for a device, send a POST request to the endpoint /observations/device/{deviceId}/{path} . Provide the ID of the device to which you want to add the observation and the path to the device resource you want to use. Use the Human readable path format (for example, \u201cDevice.0.Battery Level\u201d). The path can point to Object, Object Instance, or Resource. Note To learn more about standard LwM2M Object and Resource Registry, see the OMA LwM2M specification . In the request body provide observation attributes (name and value pair) and specify if you want to create ensureObservationTask. Use one of the valid observation attributes: 'pmin', 'pmax', 'gt', 'lt', and 'st'. Note To learn more about observation attributes, see Attributes . If you create ensureObservationTask, the system automatically checks if the observations are enabled on the device, during every provisioning session. The following is an example of the request, where you want to get a notification about the level of battery power every two minutes: cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"attributes\": [{\"name\": \"pmax\",\"value\": \"120\"}],\"createEnsureObserveIfNotExists\": false}' \\ https://#HOSTNAME/api/coiotedm/v3/observations/device/api-test-device/Device.0.Battery%20Level Coiote Python from coiote.client import Coiote from coiote.v3.model.observations import ObservationAttribute , SetObservationRequest coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) observation = SetObservationRequest ( attributes = [ ObservationAttribute ( \"pmax\" , \"120\" )] ) print ( client . observations . set_observation_on_device ( device_id = \"api-test-device\" , path = \"Device.0.Battery Level\" , data = observation ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Step 2: Create observations"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Basic_onboarding/#step-3-get-data-about-devices","text":"","title":"Step 3: Get data about devices"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Basic_onboarding/#retrieve-all-data-about-a-specific-device","text":"Send a GET request to the endpoint /devices/{id} using the device ID as the path parameter. The following is an example of the request: cURL curl -X GET \\ -H \"Authorization: Bearer #TOKEN\" \\ https://#HOSTNAME/api/coiotedm/v3/devices/api-test-device Coiote Python from coiote.client import Coiote coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . devices . get_one ( device_id = \"api-test-device\" ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Retrieve all data about a specific device"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Basic_onboarding/#retrieve-specific-data-about-all-devices","text":"Send a GET request to the endpoint /devices/find/details . Use query parameters to adjust your request: searchCriteria - conditions for retrieving the data. Use the form 'fieldName operator value', where the fieldName refers to the field in the device object. For example, id startswith '123', or managementEnabled eq true. You can find the list of possible fieldNames with allowed operators in the API reference for this endpoint. fieldSelection - fields from the device object that you want to retrieve. For example domain , serialNumber . limit - how many records are to be retrieved. The minimum value is 0, the maximum is 1000. If you leave it empty, 100 is set as default. pageBookmark - if you leave this parameter empty, you will get the first page. To get the next page, use the bookmark value returned in the previous request. The following is an example of the request, where you want to get domains of devices that have enabled management and limit the result to 10: cURL curl -X GET \\ -H \"accept: application/json\" \\ -H \"Authorization: Bearer #TOKEN\" \\ \"https://#HOSTNAME/api/coiotedm/v3/devices/find/details?searchCriteria=managementEnabled%20eq%20true&fieldSelection=domain&limit=10\" Coiote Python from coiote.client import Coiote coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . devices . get_device_details ( search_criteria = \"managementEnabled eq true\" , fields = [ \"domain\" ], limit = 10 ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Retrieve specific data about all devices"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Create_a_domain_and_add_users/","text":"How to create a domain and add users # Prerequisites: Enterprise account with permission to create domains Endpoints used: POST /domains POST /users Step 1: Create a domain # To create a domain, send a POST request to the endpoint /domains . Customize the data in the request body with the necessary parameters for creating a domain: the domain identity and description. Domain identity consists of the root domain name followed by any number of sub-domain names, and must start and end with \u201d/\u201d, for example: \u201c/sub_domain1/sub_domain2/\u201d. The following is an example of the request: cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"id\":\"/sub_domain1/sub_domain2/\",\"description\":\"Example domain\"}' \\ https://#HOSTNAME/api/coiotedm/v3/domains Coiote Python from coiote.client import Coiote from coiote.v3.model.domains import Domain coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) domain = Domain ( id = \"/sub_domain1/sub_domain2/\" , description = \"Example domain\" ) print ( client . domains . add_domain ( domain ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Step 2: Add users to your domain # To add users, send a POST request to the endpoint /users . Specify your domain in the path parameter. In the request body provide a user object. You have to include the following information: login - user's login email - user's email emailVerified - set true to create a user with already verified email domain - user's domain password - user's password roles - user's roles, leave empty if not willing to add any permissions - user's permissions, leave empty if not willing to add any tosAccepted - set true to create a user with already accepted Terms of Service The following is an example of the request: cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"login\":\"example_user\",\"email\":\"exampleUser@email.com\",\"emailVerified\":true,\"domain\":\"/sub_domain1/sub_domain2/\",\"password\":\"example_password\",\"roles\":[\"string\"],\"permissions\":[\"string\"],\"tosAccepted\":true\"}' \\ https://#HOSTNAME/api/coiotedm/v3/users Coiote Python from coiote.client import Coiote from coiote.v3.model.users import UserCreateRequest coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) user = UserCreateRequest ( login = \"example_user\" , email = \"exampleUser@email.com\" , emailVerified = True , password = \"example_password\" , roles = [ \"string\" ], permissions = [ \"string\" ], tosAccepted = True , domain = \"/sub_domain1/sub_domain2/\" ) print ( client . users . create_one ( user ) . json () ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"How to create a domain and add users"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Create_a_domain_and_add_users/#how-to-create-a-domain-and-add-users","text":"Prerequisites: Enterprise account with permission to create domains Endpoints used: POST /domains POST /users","title":"How to create a domain and add users"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Create_a_domain_and_add_users/#step-1-create-a-domain","text":"To create a domain, send a POST request to the endpoint /domains . Customize the data in the request body with the necessary parameters for creating a domain: the domain identity and description. Domain identity consists of the root domain name followed by any number of sub-domain names, and must start and end with \u201d/\u201d, for example: \u201c/sub_domain1/sub_domain2/\u201d. The following is an example of the request: cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"id\":\"/sub_domain1/sub_domain2/\",\"description\":\"Example domain\"}' \\ https://#HOSTNAME/api/coiotedm/v3/domains Coiote Python from coiote.client import Coiote from coiote.v3.model.domains import Domain coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) domain = Domain ( id = \"/sub_domain1/sub_domain2/\" , description = \"Example domain\" ) print ( client . domains . add_domain ( domain ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Step 1: Create a domain"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Create_a_domain_and_add_users/#step-2-add-users-to-your-domain","text":"To add users, send a POST request to the endpoint /users . Specify your domain in the path parameter. In the request body provide a user object. You have to include the following information: login - user's login email - user's email emailVerified - set true to create a user with already verified email domain - user's domain password - user's password roles - user's roles, leave empty if not willing to add any permissions - user's permissions, leave empty if not willing to add any tosAccepted - set true to create a user with already accepted Terms of Service The following is an example of the request: cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"login\":\"example_user\",\"email\":\"exampleUser@email.com\",\"emailVerified\":true,\"domain\":\"/sub_domain1/sub_domain2/\",\"password\":\"example_password\",\"roles\":[\"string\"],\"permissions\":[\"string\"],\"tosAccepted\":true\"}' \\ https://#HOSTNAME/api/coiotedm/v3/users Coiote Python from coiote.client import Coiote from coiote.v3.model.users import UserCreateRequest coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) user = UserCreateRequest ( login = \"example_user\" , email = \"exampleUser@email.com\" , emailVerified = True , password = \"example_password\" , roles = [ \"string\" ], permissions = [ \"string\" ], tosAccepted = True , domain = \"/sub_domain1/sub_domain2/\" ) print ( client . users . create_one ( user ) . json () ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Step 2: Add users to your domain"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/","text":"How to make firmware upgrade (FOTA) # Prerequisites: An active Coiote IoT DM user account with proper permissions A device which supports Firmware Update Object /5 Endpoints used: GET /devices/{id} POST /tasks/configure/{deviceId} GET /taskReports/{taskId}/{deviceId} POST /resources PUT /resources/{id}/data POST /tasksFromTemplates/group/{groupId} POST /tasks/upgrade/{deviceId}/{fileResourceId} GET /taskReports/summary Step 1: Check if the device firmware needs to be upgraded # Option 1: Check the device firmware version in the device entity, using GET /devices/{id} # Note GET /devices/{id} sends a request to the Coiote IoT DM database, which could be out of date if the device has not been connected to the platform for a long time. In that case, use an alternative - POST /tasks/configure/{deviceId} - described in Option 2. This way you will schedule a new LwM2M READ message to a device and get a specified value when the device connects to the system. Send a GET request to the endpoint /devices/{id} with your device ID as the path parameter to get the device entity from the database. The whole device entity will be returned in the Response body: { \"id\" : \"api-test-device\" , \"connectorType\" : \"management\" , \"bootstrap\" : false , \"directGroups\" : [ \"root.monitoring\" , \"root.incoming\" , \"root.mt.demo\" , \"root.mt.demo.lwm2m.management\" , \"root.mt.demo.lwm2m\" , \"root.lwm2m.management\" , \"root.mt.demo.devicetypes.avsystem.svetovid.0_2\" , \"root.mt.demo.api-test\" , \"root.lwm2m\" , \"root.devicetypes.avsystem.svetovid.0_2\" ], \"properties\" : { \"registeredObjects\" : \"/1/0,/3,/3/0,/5/0,/16\" , \"lwm2mLastDownOpTime\" : \"1663253893715\" , \"registeredMode\" : \"U\" , \"detectedTransport\" : \"U\" , \"lastKnownIp\" : \"81.18.220.16\" , \"lwm2mUri\" : \"coaps://81.18.220.16:36645\" , \"lwm2mVersion\" : \"1.1.0\" , \"lwm2mServerObjectInstance\" : \"0\" , \"endpointName\" : \"api-test-device\" , \"lwm2mLastUpOp\" : \"Deregister\" , \"lwm2mLastUpOpTime\" : \"1663253896587\" , \"rootPath\" : \"\" , \"lwm2mUdpMode\" : \"DIRECT\" , \"registeredQueueMode\" : \"false\" , \"lwm2mAdditionalOptions\" : \"\" , \"lwm2mTransportPreference\" : \"udp\" , \"sendViaNode\" : \"0\" , \"lwm2mLastDownOp\" : \"Read\" , \"objectVersions\" : \"1:1.1,3:1.0,5:1.0,16:1.0\" , \"lastRegisterUpdate\" : \"2022-09-15 14:58:10.811\" }, \"blacklisted\" : false , \"managementEnabled\" : true , \"lastSessionTime\" : \"2022-09-15T14:58:16.571Z\" , \"lastContactTime\" : \"2022-09-15T14:58:16.569Z\" , \"lastRegisterTime\" : \"2022-09-15T14:58:10.808Z\" , \"firstRegisterTime\" : \"2022-09-14T09:49:25.213Z\" , \"creationTime\" : \"2022-09-13T11:26:43.444Z\" , \"ipAddress\" : \"81.18.220.16\" , \"serialNumber\" : \"322da45aa528\\n\" , \"oui\" : null , \"modelName\" : \"Svetovid\" , \"hardwareVersion\" : null , \"softwareVersion\" : \"0.2\" , \"productClass\" : null , \"manufacturer\" : \"AVSystem\" , \"description\" : null , \"friendlyName\" : \"api-test-device\" , \"domain\" : \"/demo/\" , \"securityMode\" : \"psk\" , \"dtlsIdentity\" : \"api-test-device\" , \"dtlsPsk\" : { \"HexadecimalPsk\" : \"0123456789ABCDEF\" } } You need to look for the property softwareVersion that stores the firmware version: \"softwareVersion\": \"0.2\" Option 2: Get updated firmware version when the device connects to the system # Send a POST request to the endpoint /tasks/configure/{deviceId} with your device ID as the path parameter to configure a new device task. In the request body provide the task definition, where you specify the value to be \u201cDevice.0.Firmware Version\u201d. The following is an example of the request body and the complete request: { \"taskDefinition\" : { \"operations\" : [ { \"read\" : { \"key\" : \"Device.0.Firmware Version\" } } ], \"name\" : \"api-demo-task\" , \"batchRequests\" : false , \"executeImmediately\" : false } } cURL curl -X POST \\ -H 'Authorization: Bearer YOUR_TOKEN' \\ -H 'Content-Type: application/json' \\ -d '{\"taskDefinition\":{\"operations\":[{\"read\":{\"key\":\"Device.0.Firmware Version\"}}],\"name\":\"api-demo-task\",\"batchRequests\":false,\"executeImmediately\":false}}' \\ 'https://YOUR_HOSTNAME/api/coiotedm/v3/tasks/configure/api-test-device' Coiote Python from coiote.client import Coiote from coiote.v3.model.tasks import ConfigurationTaskDefinition , DeviceOperation , ReadOperation coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) task_id = client . tasks . run_device_config_task ( device_id = \"api-test-device\" , task_definition = ConfigurationTaskDefinition ( name = \"api-demo-task\" , batchRequests = False , executeImmediately = False , operations = [ ReadOperation . create ( \"Device.0.Firmware Version\" ) ] ) ) print ( task_id ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. In the response body you will get the task ID, for example: d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:1 Next, send a GET request to the endpoint /taskReports/{taskId}/{deviceId} to get the task report. Include the ID of the task you\u2019ve created in the previous step and the ID of your device as the path parameters. Note The task performing FOTA might not have started or might still be in progress when you send this request, so the report for this task might not have been generated yet. In that case, the request will respond with a custom version of 404: Not found, and the message in the response body, for example: { \"message\": \"Task has not been executed yet.\", \"code\": 4041 } The following is an example of the request: cURL curl -X GET \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"accept: application/json\" \\ 'https://#HOSTNAME/api/coiotedm/v3/taskReports/d%3AyV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g%3A1/api-test-device' Coiote Python from coiote.client import Coiote from coiote.v3.model.tasks import ConfigurationTaskDefinition , DeviceOperation , ReadOperation coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . task_reports . get_task_summary ( task_id = \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:1\" ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. You will get the firmware version in the response body in the properties array, for example: { \"taskId\" : \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:1\" , \"deviceId\" : \"api-test-device\" , \"startTime\" : \"2022-09-14T13:55:53.292Z\" , \"finishTime\" : \"2022-09-14T13:55:53.480Z\" , \"lastUpdateTime\" : \"2022-09-14T13:55:53.480Z\" , \"status\" : \"Success\" , \"summary\" : null , \"blocking\" : false , \"properties\" : [ { \"name\" : \"Device.0.Firmware Version\" , \"value\" : \"0.2\" }, { \"name\" : \"lastSuccessfulOperation\" , \"value\" : \"{\\\"read\\\":{\\\"key\\\":\\\"Device.0.Firmware Version\\\"}}\" } ] } Step 2: Perform a firmware upgrade # Create a resource # To upload a firmware file image to the Coiote IoT DM DM you must first create a resource that will store this file. Send a POST request to the endpoint /resources to create such a resource. The following is an example of the request body and the complete request with the required parameters only: { \"name\" : \"demo-file-resource\" , \"location\" : { \"InternalLocation\" : { \"fileName\" : \"file-name\" }}, \"category\" : \"FIRMWARE\" , \"domain\" : \"/demo/\" , \"expirationTime\" : \"ONE_DAY\" } cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"demo-file-resource\",\"location\":{\"InternalLocation\":{\"fileName\":\"file-name\"}},\"category\":\"FIRMWARE\",\"domain\":\"/demo/\",\"expirationTime\":\"ONE_DAY\"}' \\ \"https://#HOSTNAME/api/coiotedm/v3/resources\" Coiote Python from coiote.client import Coiote from coiote.v3.model.resources import InternalLocation , Resource , ResourceCategory , ResourceExpirationTime coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) resource = Resource ( id = \"demo-file-resource-id\" , name = \"demo-file-resource\" , location = InternalLocation . create ( \"file-name\" ), category = ResourceCategory . FIRMWARE , domain = \"/demo/\" , expirationTime = ResourceExpirationTime . ONE_DAY ) print ( client . resources . create_resource ( resource ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. In the response body you will get the resource ID necessary for the next steps, for example demo-file-resource-id . The example above creates the required resource, but it is recommended to assign it to a group. It makes upgrading a device through Coiote GUI easier because this file resource will appear in the \u201cAvailable files\u201d group. The following is an example of the request body and the request with the optional settings added: { \"id\" : \"demo-file-resource-id\" , \"name\" : \"demo-file-resource\" , \"description\" : \"resource description\" , \"location\" : { \"InternalLocation\" : { \"fileName\" : \"file-name\" }}, \"category\" : \"FIRMWARE\" , \"device\" : \"api-test-device\" , \"domain\" : \"/demo/\" , \"directGroups\" : [ { \"DeviceDirectGroup\" : { \"manufacturer\" : \"AVSystem\" , \"model\" : \"modelName\" , \"version\" : \"0.2\" } } ], \"expirationTime\" : \"ONE_DAY\" , \"visibleForSubtenants\" : false } cURL curl -X POST \\ -H \"accept: application/json\" \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d `{\"id\":\"demo-file-resource-id\",\"name\":\"demo-file-resource\",\"description\":\"resource description\",\"location\":{\"InternalLocation\":{\"fileName\":\"file-name\"}},\"category\":\"FIRMWARE\",\"device\":\"api-test-device\",\"domain\":\"/demo/\",\"directGroups\":[{\"DeviceDirectGroup\":{\"manufacturer\":\"AVSystem\",\"model\":\"modelName\",\"version\":\"0.2\"}}],\"expirationTime\":\"ONE_DAY\",\"visibleForSubtenants\":false}` \\ \"https://#HOSTNAME/api/coiotedm/v3/resources\" Coiote Python from coiote.client import Coiote from coiote.v3.model.resources import DeviceDirectGroup , InternalLocation , Resource , ResourceCategory , ResourceExpirationTime coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) resource = Resource ( id = \"demo-file-resource-id\" , name = \"demo-file-resource\" , description = \"resource description\" , location = InternalLocation . create ( \"file-name\" ), category = ResourceCategory . FIRMWARE , device = \"api-test-device\" , domain = \"/demo/\" , directGroups = [ DeviceDirectGroup . create ( manufacturer = \"AVSystem\" , model = \"modelName\" , version = \"0.2\" )], expirationTime = ResourceExpirationTime . ONE_DAY , visibleForSubtenants = False ) print ( client . resources . create_resource ( resource ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. You can find all the request body parameters with possible values in the API reference for this endpoint. Upload the upgrade file to the resource # To upload the upgrade file, send a PUT request to the endpoint /resources/{id}/data with the id of the resource you created as the path parameter. In the request body include the file with the upgrade image. Note When using cURL from the example below, make sure you are in the same directory as the firmware file that you want to upload. Specify the content type header \"Content-Type: application/octet-stream\". The following is an example of the request: cURL curl -X PUT \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"accept: application/json\" \\ -H \"Content-Type: application/octet-stream\" \\ --data-binary @{filename}` \\ \"https://#HOSTNAME/api/coiotedm/v3/resources/demo-file-resource-id/data\" Coiote Python import base64 from coiote.client import Coiote from coiote.v3.model.resources import Base64FileData coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) with open ( \"firmware.bin\" , \"rb\" ) as firmware_file : encoded_string = base64 . b64encode ( firmware_file . read ()) print ( client . resources . upload_resource_data ( resource_id = \"demo-file-resource-id\" , file = Base64FileData ( encoded_string ) ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Create the FOTA task # FOTA task for a single device To create an upgrade task for a single device send a POST request to the endpoint /tasks/upgrade/{deviceId}/{fileResourceId} with your device ID and the ID of the created resource as the path parameters. Use default values for the query parameters or adjust them if needed. You can find the description of additional parameters in the API reference for this endpoint. The following is an example of the request with default parameters: cURL curl -X POST \\ -H \"accept: application/json\" \\ -H \"Authorization: Bearer TOKEN\u201d \\ \"https://#HOSTNAME/api/coiotedm/v3/tasks/upgrade/api-test-device/demo-file-resource-id?transferMethod=Pull&transferProtocol=HTTP&timeout=20m&useQuota=true&upgradeStrategy=WithoutObservations&blocking=true&useCacheForInitialStateRead=false&checkDeliveryAndProtocol=true&resumeAfterDownlinkFailure=false&useObservation=false&extendLifetime=true&executeImmediately=false\" Coiote Python from coiote.client import Coiote from coiote.v3.model.tasks import TransferMethod , TransferProtocol , UpgradeStrategy coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . tasks . run_device_fota_task ( device_id = \"api-test-device\" , firmware_resource_id = \"demo-file-resource-id\" , transfer_method = TransferMethod . Pull , transferProtocol = TransferProtocol . HTTP , timeout = \"20m\" , use_quota = True , upgrade_strategy = UpgradeStrategy . WithoutObservations , blocking = True , use_cache_for_initial_state_read = False , check_delivery_and_protocol = True , resume_after_downlink_failure = False , extend_lifetime = True , use_observation = False , execute_immediately = False ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. The Response body will contain the ID of the created task necessary for the next steps, for example d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:2 . FOTA task for a group of devices To create a firmware upgrade task for all devices from a particular group, you need to use a task template. You can use a default \u201cLwm2mFirmwareUpdate\u201d template. Send a POST request to the endpoint /tasksFromTemplates/group/{groupId} with your group ID as the path parameter. In the request body provide the name of the task template and parameters needed to perform the task. The following is an example of the request body and the complete request: { \"templateName\" : \"Lwm2mFirmwareUpdate\" , \"config\" : { \"taskName\" : \"FOTA\" , \"parameters\" : [ { \"name\" : \"resourceId\" , \"value\" : \"demo-file-resource-id\" }, { \"name\" : \"transferProtocol\" , \"value\" : \"HTTP\" }, { \"name\" : \"transferMethod\" , \"value\" : \"Pull\" }, { \"name\" : \"transferProtocol\" , \"value\" : \"HTTP\" }, { \"name\" : \"timeout\" , \"value\" : \"20m\" }, { \"name\" : \"useQuota\" , \"value\" : \"true\" }, { \"name\" : \"upgradeStrategy\" , \"value\" : \"WithoutObservations\" }, { \"name\" : \"blocking\" , \"value\" : \"true\" }, { \"name\" : \"useCacheForInitialStateRead\" , \"value\" : \"false\" }, { \"name\" : \"checkDeliveryAndProtocol\" , \"value\" : \"true\" }, { \"name\" : \"resumeAfterDownlinkFailure\" , \"value\" : \"false\" }, { \"name\" : \"executeImmediately\" , \"value\" : \"false\" } ], \"isActive\" : true } } cURL curl -X POST \\ -H \"Authorization: Bearer TOKEN\u201d \\ -H \"accept: application/json\" \\ -H \"Content-Type: application/json\" \\ -d \"{\"templateName\":\"Lwm2mFirmwareUpdate\",\"config\":{\"taskName\":\"FOTA\",\"parameters\":[{\"name\":\"resourceID\",\"value\":\"demo-file-resource-id\"},{\"name\":\"transferProtocol\",\"value\":\"HTTP\"},{\"name\":\"transferMethod\",\"value\":\"Pull\"},{\"name\":\"transferProtocol\",\"value\":\"HTTP\"},{\"name\":\"timeout\",\"value\":\"20m\"},{\"name\":\"useQuota\",\"value\":\"true\"},{\"name\":\"upgradeStrategy\",\"value\":\"WithoutObservations\"},{\"name\":\"blocking\",\"value\":\"true\"},{\"name\":\"useCacheForInitialStateRead\",\"value\":\"false\"},{\"name\":\"checkDeliveryAndProtocol\",\"value\":\"true\"},{\"name\":\"resumeAfterDownlinkFailure\",\"value\":\"false\"},{\"name\":\"executeImmediately\",\"value\":\"false\"}],\"isActive\":true}}\" \\ \"https://#HOSTNAME/api/coiotedm/v3/tasksFromTemplates/group/root.mt.demo.api-test\" Coiote Python from coiote.client import Coiote from coiote.v3.model.task_templates import TaskTemplateConfig , TaskTemplateInvocation coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) task_configuration = TaskTemplateInvocation ( templateName = \"Lwm2mFirmwareUpdate\" , config = TaskTemplateConfig ( taskName = \"FOTA\" , parameters = [ { \"name\" : \"resourceId\" , \"value\" : \"demo-file-resource-id\" }, { \"name\" : \"transferProtocol\" , \"value\" : \"HTTP\" }, { \"name\" : \"transferMethod\" , \"value\" : \"Pull\" }, { \"name\" : \"transferProtocol\" , \"value\" : \"HTTP\" }, { \"name\" : \"timeout\" , \"value\" : \"20m\" }, { \"name\" : \"useQuota\" , \"value\" : \"true\" }, { \"name\" : \"upgradeStrategy\" , \"value\" : \"WithoutObservations\" }, { \"name\" : \"blocking\" , \"value\" : \"true\" }, { \"name\" : \"useCacheForInitialStateRead\" , \"value\" : \"false\" }, { \"name\" : \"checkDeliveryAndProtocol\" , \"value\" : \"true\" }, { \"name\" : \"resumeAfterDownlinkFailure\" , \"value\" : \"false\" }, { \"name\" : \"executeImmediately\" , \"value\" : \"false\" } ], isActive = True ) ) print ( client . task_templates . run_on_group ( group_id = \"root.mt.demo.api-test\" , config = task_configuration ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. In the response body, you will get the task ID that will be used in the next steps, for example g:root.mt.demo.api-test:1 . Step 3: Check if the firmware upgrade was successful # Firmware upgrade status for a single device # To check the firmware upgrade status for a single device send a GET request to the endpoint /taskReports/{taskId}/{deviceId} to get the task report. Provide the task and device IDs as the path parameters. The following is an example of the request: cURL curl -X GET \\ -H \"Authorization: Bearer TOKEN\u201d \\ -H \"accept: application/json\" \\ \"https://#HOSTNAME/api/coiotedm/v3/taskReports/d%3AyV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g%3A2/api-test-device\" Coiote Python from coiote.client import Coiote coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . task_reports . get_report_for_device_task ( task_id = \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:2\" , device_id = \"api-test-device\" ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Note The task performing FOTA might not have started or might still be in progress when you send this request, so the report for this task might not have been generated yet. In that case, the request will respond with a custom version of 404: Not found, and the message in the response body, for example: { \"message\": \"Task has not been executed yet.\", \"code\": 4041 } The Response body will contain the report. If FOTA is successful, the report will look similar to this example: { \"taskId\" : \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:2\" , \"deviceId\" : \"api-test-device\" , \"startTime\" : \"2022-09-14T09:49:28.280Z\" , \"finishTime\" : \"2022-09-14T09:49:35.300Z\" , \"lastUpdateTime\" : \"2022-09-14T09:49:35.300Z\" , \"status\" : \"Success\" , \"summary\" : \"Firmware update successful\" , \"blocking\" : false , \"properties\" : [ { // Uploaded firmware version \"name\" : \"newFirmwareVersion\" , \"value\" : \"0.2\" }, { // Previous firmware version \"name\" : \"oldFirmwareVersion\" , \"value\" : \"0.2\" }, { // Task execution result \"name\" : \"result\" , \"value\" : \"SUCCESS\" }, { //Task detailed result \"name\" : \"resultDetails\" , \"value\" : \"Firmware update successful\" } ] } If the FOTA task raises an error, the report will look similar to this example: { \"taskId\" : \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:2\" , \"deviceId\" : \"api-test-device\" , \"startTime\" : \"2022-09-15T08:19:38.805Z\" , \"finishTime\" : \"2022-09-15T08:19:38.807Z\" , \"lastUpdateTime\" : \"2022-09-15T08:19:38.807Z\" , \"status\" : \"Error\" , \"summary\" : \"Unknown protocol: ${sv.transferProtocol}\" , \"blocking\" : false , \"properties\" : [] } Task report statistics for a group # To get the overall task report statistics for a group send a GET request to the endpoint /taskReports/summary . Provide the ID of the task you created in the previous steps as the query parameter taskId . The following is an example of the request: cURL curl -X GET \\ -H \"Authorization: Bearer TOKEN\u201d \\ -H \"accept: application/json\" \\ \"https://#HOSTNAME/api/coiotedm/v3/taskReports/summary?taskId=g%3Aroot.mt.demo.api-test%3A1\" Coiote Python from coiote.client import Coiote coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . task_reports . get_task_summary ( task_id = \"g:root.mt.demo.api-test:1\" ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. In the response body, you will get: totalScheduled - the number of devices on which the task was scheduled inProgress - the number of devices on which the task is still in progress completed - the number of devices on which the task was completed successes - the number of devices on which the task completed successfully failures - the number of devices on which the task failed notCompleted - the number of devices on which the task has not been completed (includes in progress and not started) completionRate - total completion rate number (ratio of completed/total number of devices, where completed includes both success and failure) successRate - success rate failureRate - failure rate The following is an example of the response body: { \"totalScheduled\" : 3 , \"inProgress\" : 0 , \"completed\" : 3 , \"successes\" : 3 , \"failures\" : 0 , \"notCompleted\" : 0 , \"completionRate\" : 1 , \"successRate\" : 1 , \"failureRate\" : 0 }","title":"How to make firmware upgrade (FOTA)"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#how-to-make-firmware-upgrade-fota","text":"Prerequisites: An active Coiote IoT DM user account with proper permissions A device which supports Firmware Update Object /5 Endpoints used: GET /devices/{id} POST /tasks/configure/{deviceId} GET /taskReports/{taskId}/{deviceId} POST /resources PUT /resources/{id}/data POST /tasksFromTemplates/group/{groupId} POST /tasks/upgrade/{deviceId}/{fileResourceId} GET /taskReports/summary","title":"How to make firmware upgrade (FOTA)"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#step-1-check-if-the-device-firmware-needs-to-be-upgraded","text":"","title":"Step 1: Check if the device firmware needs to be upgraded"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#option-1-check-the-device-firmware-version-in-the-device-entity-using-get-devicesid","text":"Note GET /devices/{id} sends a request to the Coiote IoT DM database, which could be out of date if the device has not been connected to the platform for a long time. In that case, use an alternative - POST /tasks/configure/{deviceId} - described in Option 2. This way you will schedule a new LwM2M READ message to a device and get a specified value when the device connects to the system. Send a GET request to the endpoint /devices/{id} with your device ID as the path parameter to get the device entity from the database. The whole device entity will be returned in the Response body: { \"id\" : \"api-test-device\" , \"connectorType\" : \"management\" , \"bootstrap\" : false , \"directGroups\" : [ \"root.monitoring\" , \"root.incoming\" , \"root.mt.demo\" , \"root.mt.demo.lwm2m.management\" , \"root.mt.demo.lwm2m\" , \"root.lwm2m.management\" , \"root.mt.demo.devicetypes.avsystem.svetovid.0_2\" , \"root.mt.demo.api-test\" , \"root.lwm2m\" , \"root.devicetypes.avsystem.svetovid.0_2\" ], \"properties\" : { \"registeredObjects\" : \"/1/0,/3,/3/0,/5/0,/16\" , \"lwm2mLastDownOpTime\" : \"1663253893715\" , \"registeredMode\" : \"U\" , \"detectedTransport\" : \"U\" , \"lastKnownIp\" : \"81.18.220.16\" , \"lwm2mUri\" : \"coaps://81.18.220.16:36645\" , \"lwm2mVersion\" : \"1.1.0\" , \"lwm2mServerObjectInstance\" : \"0\" , \"endpointName\" : \"api-test-device\" , \"lwm2mLastUpOp\" : \"Deregister\" , \"lwm2mLastUpOpTime\" : \"1663253896587\" , \"rootPath\" : \"\" , \"lwm2mUdpMode\" : \"DIRECT\" , \"registeredQueueMode\" : \"false\" , \"lwm2mAdditionalOptions\" : \"\" , \"lwm2mTransportPreference\" : \"udp\" , \"sendViaNode\" : \"0\" , \"lwm2mLastDownOp\" : \"Read\" , \"objectVersions\" : \"1:1.1,3:1.0,5:1.0,16:1.0\" , \"lastRegisterUpdate\" : \"2022-09-15 14:58:10.811\" }, \"blacklisted\" : false , \"managementEnabled\" : true , \"lastSessionTime\" : \"2022-09-15T14:58:16.571Z\" , \"lastContactTime\" : \"2022-09-15T14:58:16.569Z\" , \"lastRegisterTime\" : \"2022-09-15T14:58:10.808Z\" , \"firstRegisterTime\" : \"2022-09-14T09:49:25.213Z\" , \"creationTime\" : \"2022-09-13T11:26:43.444Z\" , \"ipAddress\" : \"81.18.220.16\" , \"serialNumber\" : \"322da45aa528\\n\" , \"oui\" : null , \"modelName\" : \"Svetovid\" , \"hardwareVersion\" : null , \"softwareVersion\" : \"0.2\" , \"productClass\" : null , \"manufacturer\" : \"AVSystem\" , \"description\" : null , \"friendlyName\" : \"api-test-device\" , \"domain\" : \"/demo/\" , \"securityMode\" : \"psk\" , \"dtlsIdentity\" : \"api-test-device\" , \"dtlsPsk\" : { \"HexadecimalPsk\" : \"0123456789ABCDEF\" } } You need to look for the property softwareVersion that stores the firmware version: \"softwareVersion\": \"0.2\"","title":"Option 1: Check the device firmware version in the device entity, using GET /devices/{id}"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#option-2-get-updated-firmware-version-when-the-device-connects-to-the-system","text":"Send a POST request to the endpoint /tasks/configure/{deviceId} with your device ID as the path parameter to configure a new device task. In the request body provide the task definition, where you specify the value to be \u201cDevice.0.Firmware Version\u201d. The following is an example of the request body and the complete request: { \"taskDefinition\" : { \"operations\" : [ { \"read\" : { \"key\" : \"Device.0.Firmware Version\" } } ], \"name\" : \"api-demo-task\" , \"batchRequests\" : false , \"executeImmediately\" : false } } cURL curl -X POST \\ -H 'Authorization: Bearer YOUR_TOKEN' \\ -H 'Content-Type: application/json' \\ -d '{\"taskDefinition\":{\"operations\":[{\"read\":{\"key\":\"Device.0.Firmware Version\"}}],\"name\":\"api-demo-task\",\"batchRequests\":false,\"executeImmediately\":false}}' \\ 'https://YOUR_HOSTNAME/api/coiotedm/v3/tasks/configure/api-test-device' Coiote Python from coiote.client import Coiote from coiote.v3.model.tasks import ConfigurationTaskDefinition , DeviceOperation , ReadOperation coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) task_id = client . tasks . run_device_config_task ( device_id = \"api-test-device\" , task_definition = ConfigurationTaskDefinition ( name = \"api-demo-task\" , batchRequests = False , executeImmediately = False , operations = [ ReadOperation . create ( \"Device.0.Firmware Version\" ) ] ) ) print ( task_id ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. In the response body you will get the task ID, for example: d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:1 Next, send a GET request to the endpoint /taskReports/{taskId}/{deviceId} to get the task report. Include the ID of the task you\u2019ve created in the previous step and the ID of your device as the path parameters. Note The task performing FOTA might not have started or might still be in progress when you send this request, so the report for this task might not have been generated yet. In that case, the request will respond with a custom version of 404: Not found, and the message in the response body, for example: { \"message\": \"Task has not been executed yet.\", \"code\": 4041 } The following is an example of the request: cURL curl -X GET \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"accept: application/json\" \\ 'https://#HOSTNAME/api/coiotedm/v3/taskReports/d%3AyV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g%3A1/api-test-device' Coiote Python from coiote.client import Coiote from coiote.v3.model.tasks import ConfigurationTaskDefinition , DeviceOperation , ReadOperation coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . task_reports . get_task_summary ( task_id = \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:1\" ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. You will get the firmware version in the response body in the properties array, for example: { \"taskId\" : \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:1\" , \"deviceId\" : \"api-test-device\" , \"startTime\" : \"2022-09-14T13:55:53.292Z\" , \"finishTime\" : \"2022-09-14T13:55:53.480Z\" , \"lastUpdateTime\" : \"2022-09-14T13:55:53.480Z\" , \"status\" : \"Success\" , \"summary\" : null , \"blocking\" : false , \"properties\" : [ { \"name\" : \"Device.0.Firmware Version\" , \"value\" : \"0.2\" }, { \"name\" : \"lastSuccessfulOperation\" , \"value\" : \"{\\\"read\\\":{\\\"key\\\":\\\"Device.0.Firmware Version\\\"}}\" } ] }","title":"Option 2: Get updated firmware version when the device connects to the system"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#step-2-perform-a-firmware-upgrade","text":"","title":"Step 2: Perform a firmware upgrade"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#create-a-resource","text":"To upload a firmware file image to the Coiote IoT DM DM you must first create a resource that will store this file. Send a POST request to the endpoint /resources to create such a resource. The following is an example of the request body and the complete request with the required parameters only: { \"name\" : \"demo-file-resource\" , \"location\" : { \"InternalLocation\" : { \"fileName\" : \"file-name\" }}, \"category\" : \"FIRMWARE\" , \"domain\" : \"/demo/\" , \"expirationTime\" : \"ONE_DAY\" } cURL curl -X POST \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"name\":\"demo-file-resource\",\"location\":{\"InternalLocation\":{\"fileName\":\"file-name\"}},\"category\":\"FIRMWARE\",\"domain\":\"/demo/\",\"expirationTime\":\"ONE_DAY\"}' \\ \"https://#HOSTNAME/api/coiotedm/v3/resources\" Coiote Python from coiote.client import Coiote from coiote.v3.model.resources import InternalLocation , Resource , ResourceCategory , ResourceExpirationTime coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) resource = Resource ( id = \"demo-file-resource-id\" , name = \"demo-file-resource\" , location = InternalLocation . create ( \"file-name\" ), category = ResourceCategory . FIRMWARE , domain = \"/demo/\" , expirationTime = ResourceExpirationTime . ONE_DAY ) print ( client . resources . create_resource ( resource ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. In the response body you will get the resource ID necessary for the next steps, for example demo-file-resource-id . The example above creates the required resource, but it is recommended to assign it to a group. It makes upgrading a device through Coiote GUI easier because this file resource will appear in the \u201cAvailable files\u201d group. The following is an example of the request body and the request with the optional settings added: { \"id\" : \"demo-file-resource-id\" , \"name\" : \"demo-file-resource\" , \"description\" : \"resource description\" , \"location\" : { \"InternalLocation\" : { \"fileName\" : \"file-name\" }}, \"category\" : \"FIRMWARE\" , \"device\" : \"api-test-device\" , \"domain\" : \"/demo/\" , \"directGroups\" : [ { \"DeviceDirectGroup\" : { \"manufacturer\" : \"AVSystem\" , \"model\" : \"modelName\" , \"version\" : \"0.2\" } } ], \"expirationTime\" : \"ONE_DAY\" , \"visibleForSubtenants\" : false } cURL curl -X POST \\ -H \"accept: application/json\" \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d `{\"id\":\"demo-file-resource-id\",\"name\":\"demo-file-resource\",\"description\":\"resource description\",\"location\":{\"InternalLocation\":{\"fileName\":\"file-name\"}},\"category\":\"FIRMWARE\",\"device\":\"api-test-device\",\"domain\":\"/demo/\",\"directGroups\":[{\"DeviceDirectGroup\":{\"manufacturer\":\"AVSystem\",\"model\":\"modelName\",\"version\":\"0.2\"}}],\"expirationTime\":\"ONE_DAY\",\"visibleForSubtenants\":false}` \\ \"https://#HOSTNAME/api/coiotedm/v3/resources\" Coiote Python from coiote.client import Coiote from coiote.v3.model.resources import DeviceDirectGroup , InternalLocation , Resource , ResourceCategory , ResourceExpirationTime coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) resource = Resource ( id = \"demo-file-resource-id\" , name = \"demo-file-resource\" , description = \"resource description\" , location = InternalLocation . create ( \"file-name\" ), category = ResourceCategory . FIRMWARE , device = \"api-test-device\" , domain = \"/demo/\" , directGroups = [ DeviceDirectGroup . create ( manufacturer = \"AVSystem\" , model = \"modelName\" , version = \"0.2\" )], expirationTime = ResourceExpirationTime . ONE_DAY , visibleForSubtenants = False ) print ( client . resources . create_resource ( resource ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. You can find all the request body parameters with possible values in the API reference for this endpoint.","title":"Create a resource"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#upload-the-upgrade-file-to-the-resource","text":"To upload the upgrade file, send a PUT request to the endpoint /resources/{id}/data with the id of the resource you created as the path parameter. In the request body include the file with the upgrade image. Note When using cURL from the example below, make sure you are in the same directory as the firmware file that you want to upload. Specify the content type header \"Content-Type: application/octet-stream\". The following is an example of the request: cURL curl -X PUT \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"accept: application/json\" \\ -H \"Content-Type: application/octet-stream\" \\ --data-binary @{filename}` \\ \"https://#HOSTNAME/api/coiotedm/v3/resources/demo-file-resource-id/data\" Coiote Python import base64 from coiote.client import Coiote from coiote.v3.model.resources import Base64FileData coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) with open ( \"firmware.bin\" , \"rb\" ) as firmware_file : encoded_string = base64 . b64encode ( firmware_file . read ()) print ( client . resources . upload_resource_data ( resource_id = \"demo-file-resource-id\" , file = Base64FileData ( encoded_string ) ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Upload the upgrade file to the resource"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#create-the-fota-task","text":"FOTA task for a single device To create an upgrade task for a single device send a POST request to the endpoint /tasks/upgrade/{deviceId}/{fileResourceId} with your device ID and the ID of the created resource as the path parameters. Use default values for the query parameters or adjust them if needed. You can find the description of additional parameters in the API reference for this endpoint. The following is an example of the request with default parameters: cURL curl -X POST \\ -H \"accept: application/json\" \\ -H \"Authorization: Bearer TOKEN\u201d \\ \"https://#HOSTNAME/api/coiotedm/v3/tasks/upgrade/api-test-device/demo-file-resource-id?transferMethod=Pull&transferProtocol=HTTP&timeout=20m&useQuota=true&upgradeStrategy=WithoutObservations&blocking=true&useCacheForInitialStateRead=false&checkDeliveryAndProtocol=true&resumeAfterDownlinkFailure=false&useObservation=false&extendLifetime=true&executeImmediately=false\" Coiote Python from coiote.client import Coiote from coiote.v3.model.tasks import TransferMethod , TransferProtocol , UpgradeStrategy coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . tasks . run_device_fota_task ( device_id = \"api-test-device\" , firmware_resource_id = \"demo-file-resource-id\" , transfer_method = TransferMethod . Pull , transferProtocol = TransferProtocol . HTTP , timeout = \"20m\" , use_quota = True , upgrade_strategy = UpgradeStrategy . WithoutObservations , blocking = True , use_cache_for_initial_state_read = False , check_delivery_and_protocol = True , resume_after_downlink_failure = False , extend_lifetime = True , use_observation = False , execute_immediately = False ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. The Response body will contain the ID of the created task necessary for the next steps, for example d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:2 . FOTA task for a group of devices To create a firmware upgrade task for all devices from a particular group, you need to use a task template. You can use a default \u201cLwm2mFirmwareUpdate\u201d template. Send a POST request to the endpoint /tasksFromTemplates/group/{groupId} with your group ID as the path parameter. In the request body provide the name of the task template and parameters needed to perform the task. The following is an example of the request body and the complete request: { \"templateName\" : \"Lwm2mFirmwareUpdate\" , \"config\" : { \"taskName\" : \"FOTA\" , \"parameters\" : [ { \"name\" : \"resourceId\" , \"value\" : \"demo-file-resource-id\" }, { \"name\" : \"transferProtocol\" , \"value\" : \"HTTP\" }, { \"name\" : \"transferMethod\" , \"value\" : \"Pull\" }, { \"name\" : \"transferProtocol\" , \"value\" : \"HTTP\" }, { \"name\" : \"timeout\" , \"value\" : \"20m\" }, { \"name\" : \"useQuota\" , \"value\" : \"true\" }, { \"name\" : \"upgradeStrategy\" , \"value\" : \"WithoutObservations\" }, { \"name\" : \"blocking\" , \"value\" : \"true\" }, { \"name\" : \"useCacheForInitialStateRead\" , \"value\" : \"false\" }, { \"name\" : \"checkDeliveryAndProtocol\" , \"value\" : \"true\" }, { \"name\" : \"resumeAfterDownlinkFailure\" , \"value\" : \"false\" }, { \"name\" : \"executeImmediately\" , \"value\" : \"false\" } ], \"isActive\" : true } } cURL curl -X POST \\ -H \"Authorization: Bearer TOKEN\u201d \\ -H \"accept: application/json\" \\ -H \"Content-Type: application/json\" \\ -d \"{\"templateName\":\"Lwm2mFirmwareUpdate\",\"config\":{\"taskName\":\"FOTA\",\"parameters\":[{\"name\":\"resourceID\",\"value\":\"demo-file-resource-id\"},{\"name\":\"transferProtocol\",\"value\":\"HTTP\"},{\"name\":\"transferMethod\",\"value\":\"Pull\"},{\"name\":\"transferProtocol\",\"value\":\"HTTP\"},{\"name\":\"timeout\",\"value\":\"20m\"},{\"name\":\"useQuota\",\"value\":\"true\"},{\"name\":\"upgradeStrategy\",\"value\":\"WithoutObservations\"},{\"name\":\"blocking\",\"value\":\"true\"},{\"name\":\"useCacheForInitialStateRead\",\"value\":\"false\"},{\"name\":\"checkDeliveryAndProtocol\",\"value\":\"true\"},{\"name\":\"resumeAfterDownlinkFailure\",\"value\":\"false\"},{\"name\":\"executeImmediately\",\"value\":\"false\"}],\"isActive\":true}}\" \\ \"https://#HOSTNAME/api/coiotedm/v3/tasksFromTemplates/group/root.mt.demo.api-test\" Coiote Python from coiote.client import Coiote from coiote.v3.model.task_templates import TaskTemplateConfig , TaskTemplateInvocation coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) task_configuration = TaskTemplateInvocation ( templateName = \"Lwm2mFirmwareUpdate\" , config = TaskTemplateConfig ( taskName = \"FOTA\" , parameters = [ { \"name\" : \"resourceId\" , \"value\" : \"demo-file-resource-id\" }, { \"name\" : \"transferProtocol\" , \"value\" : \"HTTP\" }, { \"name\" : \"transferMethod\" , \"value\" : \"Pull\" }, { \"name\" : \"transferProtocol\" , \"value\" : \"HTTP\" }, { \"name\" : \"timeout\" , \"value\" : \"20m\" }, { \"name\" : \"useQuota\" , \"value\" : \"true\" }, { \"name\" : \"upgradeStrategy\" , \"value\" : \"WithoutObservations\" }, { \"name\" : \"blocking\" , \"value\" : \"true\" }, { \"name\" : \"useCacheForInitialStateRead\" , \"value\" : \"false\" }, { \"name\" : \"checkDeliveryAndProtocol\" , \"value\" : \"true\" }, { \"name\" : \"resumeAfterDownlinkFailure\" , \"value\" : \"false\" }, { \"name\" : \"executeImmediately\" , \"value\" : \"false\" } ], isActive = True ) ) print ( client . task_templates . run_on_group ( group_id = \"root.mt.demo.api-test\" , config = task_configuration ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. In the response body, you will get the task ID that will be used in the next steps, for example g:root.mt.demo.api-test:1 .","title":"Create the FOTA task"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#step-3-check-if-the-firmware-upgrade-was-successful","text":"","title":"Step 3: Check if the firmware upgrade was successful"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#firmware-upgrade-status-for-a-single-device","text":"To check the firmware upgrade status for a single device send a GET request to the endpoint /taskReports/{taskId}/{deviceId} to get the task report. Provide the task and device IDs as the path parameters. The following is an example of the request: cURL curl -X GET \\ -H \"Authorization: Bearer TOKEN\u201d \\ -H \"accept: application/json\" \\ \"https://#HOSTNAME/api/coiotedm/v3/taskReports/d%3AyV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g%3A2/api-test-device\" Coiote Python from coiote.client import Coiote coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . task_reports . get_report_for_device_task ( task_id = \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:2\" , device_id = \"api-test-device\" ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Note The task performing FOTA might not have started or might still be in progress when you send this request, so the report for this task might not have been generated yet. In that case, the request will respond with a custom version of 404: Not found, and the message in the response body, for example: { \"message\": \"Task has not been executed yet.\", \"code\": 4041 } The Response body will contain the report. If FOTA is successful, the report will look similar to this example: { \"taskId\" : \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:2\" , \"deviceId\" : \"api-test-device\" , \"startTime\" : \"2022-09-14T09:49:28.280Z\" , \"finishTime\" : \"2022-09-14T09:49:35.300Z\" , \"lastUpdateTime\" : \"2022-09-14T09:49:35.300Z\" , \"status\" : \"Success\" , \"summary\" : \"Firmware update successful\" , \"blocking\" : false , \"properties\" : [ { // Uploaded firmware version \"name\" : \"newFirmwareVersion\" , \"value\" : \"0.2\" }, { // Previous firmware version \"name\" : \"oldFirmwareVersion\" , \"value\" : \"0.2\" }, { // Task execution result \"name\" : \"result\" , \"value\" : \"SUCCESS\" }, { //Task detailed result \"name\" : \"resultDetails\" , \"value\" : \"Firmware update successful\" } ] } If the FOTA task raises an error, the report will look similar to this example: { \"taskId\" : \"d:yV3cYCNpbGpNuVWpFo9eHlQHJZIghQ8emN5z9g:2\" , \"deviceId\" : \"api-test-device\" , \"startTime\" : \"2022-09-15T08:19:38.805Z\" , \"finishTime\" : \"2022-09-15T08:19:38.807Z\" , \"lastUpdateTime\" : \"2022-09-15T08:19:38.807Z\" , \"status\" : \"Error\" , \"summary\" : \"Unknown protocol: ${sv.transferProtocol}\" , \"blocking\" : false , \"properties\" : [] }","title":"Firmware upgrade status for a single device"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Make_firmware_upgrade/#task-report-statistics-for-a-group","text":"To get the overall task report statistics for a group send a GET request to the endpoint /taskReports/summary . Provide the ID of the task you created in the previous steps as the query parameter taskId . The following is an example of the request: cURL curl -X GET \\ -H \"Authorization: Bearer TOKEN\u201d \\ -H \"accept: application/json\" \\ \"https://#HOSTNAME/api/coiotedm/v3/taskReports/summary?taskId=g%3Aroot.mt.demo.api-test%3A1\" Coiote Python from coiote.client import Coiote coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . task_reports . get_task_summary ( task_id = \"g:root.mt.demo.api-test:1\" ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. In the response body, you will get: totalScheduled - the number of devices on which the task was scheduled inProgress - the number of devices on which the task is still in progress completed - the number of devices on which the task was completed successes - the number of devices on which the task completed successfully failures - the number of devices on which the task failed notCompleted - the number of devices on which the task has not been completed (includes in progress and not started) completionRate - total completion rate number (ratio of completed/total number of devices, where completed includes both success and failure) successRate - success rate failureRate - failure rate The following is an example of the response body: { \"totalScheduled\" : 3 , \"inProgress\" : 0 , \"completed\" : 3 , \"successes\" : 3 , \"failures\" : 0 , \"notCompleted\" : 0 , \"completionRate\" : 1 , \"successRate\" : 1 , \"failureRate\" : 0 }","title":"Task report statistics for a group"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/","text":"How to send data outside the application using event handlers # Prerequisites: An active Coiote IoT DM user account with a domain Endpoints used: POST /deviceEvents/handler/kafka POST /deviceEvents/handler/webhook POST /deviceEvents/handler/test/existing/{id} Overview # You can send data outside the application using one of two methods - Kafka or Webhook . Webhook sends events to an external HTTP server. You can choose this method, if you have an external server, lambda prepared in AWS, or your own application that is able to receive HTTP traffic from Coiote IoT DM. Kafka sends events to an external Kafka server. It\u2019s an option for advanced users. You should choose it if you want to forward a great number of events and you have a good understanding of how Kafka works. Step 1: Prepare a \u201creceiver\u201d for the data from Coiote IoT DM # Configure a destination to which you want to forward the data. It can be a Kafka cluster , a bucket for data in Influx Cloud , or your own HTTP server. Step 2: Configure the authentication # Get the authentication data (password/token) from your data receiver to use it for Coiote IoT DM authentication. Step 3: Prepare the information you want to forward # Decide which events you want to send. Event handlers can forward events of two types: Telemetry events - emitted each time a change in the device data is spotted by the system Device events - emitted each time the device state changes Telemetry events are usually emitted when: the device sends an LwM2M Notify message to the server, the device sends an LwM2M Send message to the server, the server carries out Read on the device resource. Device events are emitted when one of the following takes place: deviceCreated - a device is added to the system deviceFirstRegistration - a device connects for the first time deviceUpdatedViaWrite - the server carries out a Write to a device's resource deviceUpdatedViaFota - the server finishes execution of Firmware Upgrade (FOTA) on a device deviceDeleted - a device is deleted from the system Step 4: Create the event handler # The device event handler determines whether an event, telemetry or lifecycle, should be forwarded, decides how it should be forwarded, and then forwards the data. Each domain can have up to 10 event handlers. One event can trigger one or more event handlers. If the event handler fails 5 times in a row, then it is deactivated. Create a Kafka event handler # Send a POST request to the endpoint /deviceEvents/handler/kafka. Use the domain query parameter to specify the domain, otherwise, the domain of the user authorizing the request will be used as default. In the request body, provide the event handler configuration. It consists of two parts: Configure the connection to the Kafka instance # You can specify the configuration of the connection to the target Kafka instance: Using Kafka domain properties If your domain has Kafka properties configured, you can reuse them in the handler. Whenever the configuration changes, it will be reflected in your event handler. This can be achieved by setting the connectionConfig.type field to \"domainProperties\" in the request body. The following example of a request body creates a handler from Kafka config stored in domain properties: { \"type\" : \"kafka\" , \"name\" : \"Domain Kafka event handler\" , \"enabled\" : true , \"connectionConfig\" : { \"type\" : \"domainProperties\" , \"topic\" : \"coiote.deviceEvents\" , \"headers\" : { \"Origin\" : \"Coiote-DM\" } }, \"filter\" : { \"type\" : \"lifecycle\" , \"eventTypes\" : [ \"deviceCreated\" ] }, \"description\" : \"This handler forwards data to kafka-cloud.com\" } Using custom Kafka producer configuration You can specify the Kafka configuration directly in the request body. This configuration must follow the .properties file format syntax and contain at least the addresses for bootstrap servers of your Kafka cluster. If your config contains \"sasl.jaas.config\" property, it is advised to skip the \u201c character in the \"username\" and \"password\" fields using . The following example of a request body creates a handler from custom Kafka properties: { \"type\" : \"kafka\" , \"name\" : \"Custom Kafka event handler\" , \"enabled\" : true , \"connectionConfig\" : { \"type\" : \"custom\" , \"value\" : \"bootstrap.servers=kafka-cloud.com:9093\\nsecurity.protocol=SASL_PLAINTEXT\\nsasl.mechanism=SCRAM-SHA-256\\nsasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username=\\\"kafka-user\\\" password=\\\"pass\\\";\" , \"topic\" : \"iot.deviceEvents\" , \"headers\" : { \"Origin\" : \"IoT DM\" } }, \"filter\" : { \"type\" : \"lifecycle\" , \"eventTypes\" : [ \"deviceCreated\" ] }, \"description\" : \"This handler forwards data to kafka-cloud.com\" } Note In both types of configuration, for security reasons, the following parameters will be appended to the producer configuration: retries = 0 max.block.ms = 8000 Select forwarded events by applying the filter # Each handler can forward events of only one of two types: Telemetry events or Device events. For handlers that forward telemetry data, you can state for which LwM2M objects and resources the forwarding should happen, by specifying a list of LwM2M URLs in the filter definition. For example, the following filter allows all events for resource Latitude in object Location (URL: /6/0/0) and also all events for object Temperature (URL /3303): \"filter\" : { \"type\" : \"telemetry\" , \"lwm2mUrls\" : [ \"/6/0/0\" , \"/3303\" ] } For handlers that forward device events, you have to point to the event types. For example, the following filter selects the events of registration and carrying out FOTA: \"filter\" : { \"type\" : \"lifecycle\" , \"eventTypes\" : [ \"deviceFirstRegistration\" , \"deviceUpdatedViaFota\" ] } The following is an example of the request creating a handler with custom Kafka properties and device events: cURL curl -X POST \\ -H \"accept: application/json\" \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"type\":\"kafka\",\"name\":\"Domain Kafka event handler\",\"enabled\":true,\"connectionConfig\":{\"type\":\"domainProperties\",\"topic\":\"coiote.deviceEvents\",\"headers\":{\"Origin\":\"Coiote-DM\"}},\"filter\":{\"type\":\"lifecycle\",\"eventTypes\":[\"deviceCreated\"]},\"description\":\"This handler forwards data to kafka-cloud.com\"}' \\ \"https://#HOSTNAME/api/coiotedm/v3/deviceEvents/handler/kafka\" Coiote Python from coiote.client import Coiote from coiote.v3.model.device_events import CustomKafkaConnectionConfig , DeviceLifecycleEventType , EventHandlerConfiguration , HandlerType , LifecycleEventHandlerFilter coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) event_handler = EventHandlerConfiguration ( type = HandlerType . Kafka , name = \"Custom Kafka event handler\" , enabled = True , filter = LifecycleEventHandlerFilter ( eventTypes = [ DeviceLifecycleEventType . Created ] ), connectionConfig = CustomKafkaConnectionConfig ( from coiote.client import Coiote from coiote.v3.model.device_events import DeviceLifecycleEventType , EventHandlerConfiguration , HandlerType , KafkaFromPropertiesConnectionConfig , LifecycleEventHandlerFilter coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) event_handler = EventHandlerConfiguration ( type = HandlerType . Kafka , name = \"Domain Kafka event handler\" , enabled = True , filter = LifecycleEventHandlerFilter ( eventTypes = [ DeviceLifecycleEventType . Created ]), connectionConfig = KafkaFromPropertiesConnectionConfig ( topic = \"coiote.deviceEvents\" , headers = { \"Origin\" : \"Coiote-DM\" } ), description = \"This handler forwards data to kafka-cloud.com\" ) print ( client . device_events . create_handler ( event_handler ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Create a Webhook event handler # Send a POST request to the endpoint /deviceEvents/handler/webhook . Use the domain query parameter to specify the domain, otherwise, the domain of the user authorizing the request will be selected. In the request body, provide the event handler configuration. It consists of three parts: Configure the connection # Each Webhook event handler can forward events both to HTTP and HTTPS endpoints. If you specify the target URL to be HTTPS, handler execution will fail if the certificate is not valid. The requests can be authorized: using basic authorization (user and password), by specifying connectionConfig.auth field of request body: { \"connectionConfig\" : { \"type\" : \"basic\" , \"user\" : \"<your username>\" , \"password\" : \"<your password>\" } ... } using bearer authorization (token), by specifying connectionConfig.token field of request body: { \"connectionConfig\" : { \"type\" : \"token\" , \"token\" : \"<your token>\" } ... } using custom static header, by specifying connectionConfig.additionalHeaders field of request body: { \"connectionConfig\" : null , \"additionalHeaders\" : { \"<custom authorization header>\" : \"<header value>\" } ... } Specify delivery method and payload format # If you do not select the HTTP method using connectionConfig.method field, the requests will be sent using HTTP POST. You can specify the method to be one of \"post\", \"put\" or \"patch\". By default, the events are represented as JSON when the request payload is prepared. You can change the format to InfluxDB line protocol by setting the connectionConfig.format field to \"influxDb\". Select forwarded events by applying the filter # Each handler can forward events of only one of two types: Telemetry events or Device events. For handlers that forward telemetry data, you can state for which LwM2M objects and resources the forwarding should happen, by specifying a list of LwM2M URLs in the filter definition. For example, the following filter selects all events for resource Latitude in object Location (URL: /6/0/0) and also all events for object Temperature (URL /3303): \"filter\" : { \"type\" : \"telemetry\" , \"lwm2mUrls\" : [ \"/6/0/0\" , \"/3303\" ] } For handlers that forward device events, you have to point to the event types. For example, the following filter selects the events of registration and carrying out FOTA: \"filter\" : { \"type\" : \"lifecycle\" , \"eventTypes\" : [ \"deviceFirstRegistration\" , \"deviceUpdatedViaFota\" ] } The following is an example of the request: cURL curl -X POST \\ -H \"accept: application/json\" \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"type\":\"webhook\",\"name\":\"Influx event handler\",\"enabled\":true,\"connectionConfig\":{\"method\":\"post\",\"format\":\"influxDb\",\"additionalHeaders\":{\"Authorization\":\"Token <enter your token>\"},\"uri\":\"https://eu-central-1-1.aws.cloud2.influxdata.com/api/v2/write?bucket=<enter bucket ID>\",\"auth\":null},\"filter\":{\"type\":\"telemetry\",\"lwm2mUrls\":[\"/6/0/0\"]},\"description\":\"This handler forwards location data to InfluxDB Cloud\"}' \\ \"https://#HOSTNAME/api/coiotedm/v3/deviceEvents/handler/webhook\" Coiote Python from coiote.client import Coiote from coiote.v3.model.device_events import TelemetryEventHandlerFilter coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . device_events . create_influx_handler ( name = \"Influx event handler\" , host = \"eu-central-1-1.aws.cloud2.influxdata.com\" , bucket_id = \"<enter bucket ID>\" , token = \"<enter your token>\" , filter = TelemetryEventHandlerFilter ( lwm2mUrls = [ \"/6/0/0\" ] ), description = \"This handler forwards location data to InfluxDB Cloud\" ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Step 5: Test the created handler # You can send a POST request to the endpoint /deviceEvents/handler/test/existing/{id} to test if the handler works correctly. The payload will be generated automatically, based on the filter field of the handler configuration. If the event handler was previously disabled due to consecutive failures, after you test it successfully, the system will re-enable it. You can also check if the data from the event has been collected by your \u201creceiver\u201d.","title":"How to send data outside the application with event handlers"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#how-to-send-data-outside-the-application-using-event-handlers","text":"Prerequisites: An active Coiote IoT DM user account with a domain Endpoints used: POST /deviceEvents/handler/kafka POST /deviceEvents/handler/webhook POST /deviceEvents/handler/test/existing/{id}","title":"How to send data outside the application using event handlers"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#overview","text":"You can send data outside the application using one of two methods - Kafka or Webhook . Webhook sends events to an external HTTP server. You can choose this method, if you have an external server, lambda prepared in AWS, or your own application that is able to receive HTTP traffic from Coiote IoT DM. Kafka sends events to an external Kafka server. It\u2019s an option for advanced users. You should choose it if you want to forward a great number of events and you have a good understanding of how Kafka works.","title":"Overview"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#step-1-prepare-a-receiver-for-the-data-from-coiote-iot-dm","text":"Configure a destination to which you want to forward the data. It can be a Kafka cluster , a bucket for data in Influx Cloud , or your own HTTP server.","title":"Step 1: Prepare a \u201creceiver\u201d for the data from Coiote IoT DM"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#step-2-configure-the-authentication","text":"Get the authentication data (password/token) from your data receiver to use it for Coiote IoT DM authentication.","title":"Step 2: Configure the authentication"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#step-3-prepare-the-information-you-want-to-forward","text":"Decide which events you want to send. Event handlers can forward events of two types: Telemetry events - emitted each time a change in the device data is spotted by the system Device events - emitted each time the device state changes Telemetry events are usually emitted when: the device sends an LwM2M Notify message to the server, the device sends an LwM2M Send message to the server, the server carries out Read on the device resource. Device events are emitted when one of the following takes place: deviceCreated - a device is added to the system deviceFirstRegistration - a device connects for the first time deviceUpdatedViaWrite - the server carries out a Write to a device's resource deviceUpdatedViaFota - the server finishes execution of Firmware Upgrade (FOTA) on a device deviceDeleted - a device is deleted from the system","title":"Step 3: Prepare the information you want to forward"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#step-4-create-the-event-handler","text":"The device event handler determines whether an event, telemetry or lifecycle, should be forwarded, decides how it should be forwarded, and then forwards the data. Each domain can have up to 10 event handlers. One event can trigger one or more event handlers. If the event handler fails 5 times in a row, then it is deactivated.","title":"Step 4: Create the event handler"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#create-a-kafka-event-handler","text":"Send a POST request to the endpoint /deviceEvents/handler/kafka. Use the domain query parameter to specify the domain, otherwise, the domain of the user authorizing the request will be used as default. In the request body, provide the event handler configuration. It consists of two parts:","title":"Create a Kafka event handler"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#configure-the-connection-to-the-kafka-instance","text":"You can specify the configuration of the connection to the target Kafka instance: Using Kafka domain properties If your domain has Kafka properties configured, you can reuse them in the handler. Whenever the configuration changes, it will be reflected in your event handler. This can be achieved by setting the connectionConfig.type field to \"domainProperties\" in the request body. The following example of a request body creates a handler from Kafka config stored in domain properties: { \"type\" : \"kafka\" , \"name\" : \"Domain Kafka event handler\" , \"enabled\" : true , \"connectionConfig\" : { \"type\" : \"domainProperties\" , \"topic\" : \"coiote.deviceEvents\" , \"headers\" : { \"Origin\" : \"Coiote-DM\" } }, \"filter\" : { \"type\" : \"lifecycle\" , \"eventTypes\" : [ \"deviceCreated\" ] }, \"description\" : \"This handler forwards data to kafka-cloud.com\" } Using custom Kafka producer configuration You can specify the Kafka configuration directly in the request body. This configuration must follow the .properties file format syntax and contain at least the addresses for bootstrap servers of your Kafka cluster. If your config contains \"sasl.jaas.config\" property, it is advised to skip the \u201c character in the \"username\" and \"password\" fields using . The following example of a request body creates a handler from custom Kafka properties: { \"type\" : \"kafka\" , \"name\" : \"Custom Kafka event handler\" , \"enabled\" : true , \"connectionConfig\" : { \"type\" : \"custom\" , \"value\" : \"bootstrap.servers=kafka-cloud.com:9093\\nsecurity.protocol=SASL_PLAINTEXT\\nsasl.mechanism=SCRAM-SHA-256\\nsasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username=\\\"kafka-user\\\" password=\\\"pass\\\";\" , \"topic\" : \"iot.deviceEvents\" , \"headers\" : { \"Origin\" : \"IoT DM\" } }, \"filter\" : { \"type\" : \"lifecycle\" , \"eventTypes\" : [ \"deviceCreated\" ] }, \"description\" : \"This handler forwards data to kafka-cloud.com\" } Note In both types of configuration, for security reasons, the following parameters will be appended to the producer configuration: retries = 0 max.block.ms = 8000","title":"Configure the connection to the Kafka instance"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#select-forwarded-events-by-applying-the-filter","text":"Each handler can forward events of only one of two types: Telemetry events or Device events. For handlers that forward telemetry data, you can state for which LwM2M objects and resources the forwarding should happen, by specifying a list of LwM2M URLs in the filter definition. For example, the following filter allows all events for resource Latitude in object Location (URL: /6/0/0) and also all events for object Temperature (URL /3303): \"filter\" : { \"type\" : \"telemetry\" , \"lwm2mUrls\" : [ \"/6/0/0\" , \"/3303\" ] } For handlers that forward device events, you have to point to the event types. For example, the following filter selects the events of registration and carrying out FOTA: \"filter\" : { \"type\" : \"lifecycle\" , \"eventTypes\" : [ \"deviceFirstRegistration\" , \"deviceUpdatedViaFota\" ] } The following is an example of the request creating a handler with custom Kafka properties and device events: cURL curl -X POST \\ -H \"accept: application/json\" \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"type\":\"kafka\",\"name\":\"Domain Kafka event handler\",\"enabled\":true,\"connectionConfig\":{\"type\":\"domainProperties\",\"topic\":\"coiote.deviceEvents\",\"headers\":{\"Origin\":\"Coiote-DM\"}},\"filter\":{\"type\":\"lifecycle\",\"eventTypes\":[\"deviceCreated\"]},\"description\":\"This handler forwards data to kafka-cloud.com\"}' \\ \"https://#HOSTNAME/api/coiotedm/v3/deviceEvents/handler/kafka\" Coiote Python from coiote.client import Coiote from coiote.v3.model.device_events import CustomKafkaConnectionConfig , DeviceLifecycleEventType , EventHandlerConfiguration , HandlerType , LifecycleEventHandlerFilter coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) event_handler = EventHandlerConfiguration ( type = HandlerType . Kafka , name = \"Custom Kafka event handler\" , enabled = True , filter = LifecycleEventHandlerFilter ( eventTypes = [ DeviceLifecycleEventType . Created ] ), connectionConfig = CustomKafkaConnectionConfig ( from coiote.client import Coiote from coiote.v3.model.device_events import DeviceLifecycleEventType , EventHandlerConfiguration , HandlerType , KafkaFromPropertiesConnectionConfig , LifecycleEventHandlerFilter coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) event_handler = EventHandlerConfiguration ( type = HandlerType . Kafka , name = \"Domain Kafka event handler\" , enabled = True , filter = LifecycleEventHandlerFilter ( eventTypes = [ DeviceLifecycleEventType . Created ]), connectionConfig = KafkaFromPropertiesConnectionConfig ( topic = \"coiote.deviceEvents\" , headers = { \"Origin\" : \"Coiote-DM\" } ), description = \"This handler forwards data to kafka-cloud.com\" ) print ( client . device_events . create_handler ( event_handler ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Select forwarded events by applying the filter"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#create-a-webhook-event-handler","text":"Send a POST request to the endpoint /deviceEvents/handler/webhook . Use the domain query parameter to specify the domain, otherwise, the domain of the user authorizing the request will be selected. In the request body, provide the event handler configuration. It consists of three parts:","title":"Create a Webhook event handler"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#configure-the-connection","text":"Each Webhook event handler can forward events both to HTTP and HTTPS endpoints. If you specify the target URL to be HTTPS, handler execution will fail if the certificate is not valid. The requests can be authorized: using basic authorization (user and password), by specifying connectionConfig.auth field of request body: { \"connectionConfig\" : { \"type\" : \"basic\" , \"user\" : \"<your username>\" , \"password\" : \"<your password>\" } ... } using bearer authorization (token), by specifying connectionConfig.token field of request body: { \"connectionConfig\" : { \"type\" : \"token\" , \"token\" : \"<your token>\" } ... } using custom static header, by specifying connectionConfig.additionalHeaders field of request body: { \"connectionConfig\" : null , \"additionalHeaders\" : { \"<custom authorization header>\" : \"<header value>\" } ... }","title":"Configure the connection"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#specify-delivery-method-and-payload-format","text":"If you do not select the HTTP method using connectionConfig.method field, the requests will be sent using HTTP POST. You can specify the method to be one of \"post\", \"put\" or \"patch\". By default, the events are represented as JSON when the request payload is prepared. You can change the format to InfluxDB line protocol by setting the connectionConfig.format field to \"influxDb\".","title":"Specify delivery method and payload format"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#select-forwarded-events-by-applying-the-filter_1","text":"Each handler can forward events of only one of two types: Telemetry events or Device events. For handlers that forward telemetry data, you can state for which LwM2M objects and resources the forwarding should happen, by specifying a list of LwM2M URLs in the filter definition. For example, the following filter selects all events for resource Latitude in object Location (URL: /6/0/0) and also all events for object Temperature (URL /3303): \"filter\" : { \"type\" : \"telemetry\" , \"lwm2mUrls\" : [ \"/6/0/0\" , \"/3303\" ] } For handlers that forward device events, you have to point to the event types. For example, the following filter selects the events of registration and carrying out FOTA: \"filter\" : { \"type\" : \"lifecycle\" , \"eventTypes\" : [ \"deviceFirstRegistration\" , \"deviceUpdatedViaFota\" ] } The following is an example of the request: cURL curl -X POST \\ -H \"accept: application/json\" \\ -H \"Authorization: Bearer #TOKEN\" \\ -H \"Content-Type: application/json\" \\ -d '{\"type\":\"webhook\",\"name\":\"Influx event handler\",\"enabled\":true,\"connectionConfig\":{\"method\":\"post\",\"format\":\"influxDb\",\"additionalHeaders\":{\"Authorization\":\"Token <enter your token>\"},\"uri\":\"https://eu-central-1-1.aws.cloud2.influxdata.com/api/v2/write?bucket=<enter bucket ID>\",\"auth\":null},\"filter\":{\"type\":\"telemetry\",\"lwm2mUrls\":[\"/6/0/0\"]},\"description\":\"This handler forwards location data to InfluxDB Cloud\"}' \\ \"https://#HOSTNAME/api/coiotedm/v3/deviceEvents/handler/webhook\" Coiote Python from coiote.client import Coiote from coiote.v3.model.device_events import TelemetryEventHandlerFilter coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . device_events . create_influx_handler ( name = \"Influx event handler\" , host = \"eu-central-1-1.aws.cloud2.influxdata.com\" , bucket_id = \"<enter bucket ID>\" , token = \"<enter your token>\" , filter = TelemetryEventHandlerFilter ( lwm2mUrls = [ \"/6/0/0\" ] ), description = \"This handler forwards location data to InfluxDB Cloud\" ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Select forwarded events by applying the filter"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Send_data_outside_application/#step-5-test-the-created-handler","text":"You can send a POST request to the endpoint /deviceEvents/handler/test/existing/{id} to test if the handler works correctly. The payload will be generated automatically, based on the filter field of the handler configuration. If the event handler was previously disabled due to consecutive failures, after you test it successfully, the system will re-enable it. You can also check if the data from the event has been collected by your \u201creceiver\u201d.","title":"Step 5: Test the created handler"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Use_device_monitoring/","text":"How to use Device monitoring to get data from Coiote # Prerequisites: An active Coiote IoT DM user account Permission monitoring.manageMonitoring Devices already connected to Coiote IoT DM Endpoints used: GET /deviceMonitoring/data/{deviceId}/alias/{alias} GET /deviceMonitoring/data/{deviceId}/resourceUrl/{lwm2mUrl} Overview # You can retrieve monitoring data from a device resource identified by its alias or LwM2M URL. Retrieve monitoring data from a device using its resource alias # Send a GET request to the endpoint /deviceMonitoring/data/{deviceId}/alias/{alias} . You have to provide the path parameters deviceId and alias , and the query parameter timeRangeStart . You can also use two additional parameters: timeRangeEnd and limit . To provide timeRangeStart and timeRangeEnd use ISO format (for example, 2022-12-01T08:05:35Z). If you don\u2019t provide the timeRangeEnd parameter the current time is assumed to be the range end. The default and max value for the limit parameter is 2048 records. Note The value of timeRangeStart is exclusive and the value of timeRangeEnd is inclusive. The following is an example of the request, where you want to get monitoring data of the device with id \u201cdevice123\u201d about the temperature sensor (alias temperature), gathered in the time period starting from 2022-12-01T08:05:35Z. cURL curl -X GET \\ -H \"Authorization: Bearer #TOKEN\" \\ \"https://#HOSTNAME/api/coiotedm/v3/deviceMonitoring/data/device123/alias/temperature?timeRangeStart=2022-12-01T08:05:35Z\" Coiote Python from coiote.client import Coiote from datetime import datetime coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . device_monitoring . get_data_batch ( device_id = \"device123\" , alias = \"temperature\" , start_time = datetime . now () ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Retrieve monitoring data from the device using its resource LwM2M URL # Send a GET request to the endpoint /deviceMonitoring/data/{deviceId}/resourceUrl/{lwm2mUrl} . You have to provide the path parameters deviceId and lwm2mUrl , and the query parameter timeRangeStart . You can also use two additional parameters: timeRangeEnd and limit . To provide the lwm2mUrl parameter use the format \u201c/x/y/\u201d' with numeric values. The following is an example of the request, where you want to get monitoring data of the device with id \u201cdevice123\u201d about the temperature sensor (path /3303/0/5700), gathered in the time period starting from 2022-12-01T08:05:35Z. cURL curl -X GET \\ -H \"Authorization: Bearer #TOKEN\" \\ \"https://#HOSTNAME/api/coiotedm/v3/deviceMonitoring/data/device123/resourceUrl//3303/0/5700?timeRangeStart=2022-12-01T08:05:35Z\" Coiote Python from coiote.client import Coiote from datetime import datetime coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . device_monitoring . get_data_batch ( device_id = \"device123\" , lwm2m_url = \"/3303/0/5700\" , start_time = datetime . now () ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"How to use Device monitoring"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Use_device_monitoring/#how-to-use-device-monitoring-to-get-data-from-coiote","text":"Prerequisites: An active Coiote IoT DM user account Permission monitoring.manageMonitoring Devices already connected to Coiote IoT DM Endpoints used: GET /deviceMonitoring/data/{deviceId}/alias/{alias} GET /deviceMonitoring/data/{deviceId}/resourceUrl/{lwm2mUrl}","title":"How to use Device monitoring to get data from Coiote"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Use_device_monitoring/#overview","text":"You can retrieve monitoring data from a device resource identified by its alias or LwM2M URL.","title":"Overview"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Use_device_monitoring/#retrieve-monitoring-data-from-a-device-using-its-resource-alias","text":"Send a GET request to the endpoint /deviceMonitoring/data/{deviceId}/alias/{alias} . You have to provide the path parameters deviceId and alias , and the query parameter timeRangeStart . You can also use two additional parameters: timeRangeEnd and limit . To provide timeRangeStart and timeRangeEnd use ISO format (for example, 2022-12-01T08:05:35Z). If you don\u2019t provide the timeRangeEnd parameter the current time is assumed to be the range end. The default and max value for the limit parameter is 2048 records. Note The value of timeRangeStart is exclusive and the value of timeRangeEnd is inclusive. The following is an example of the request, where you want to get monitoring data of the device with id \u201cdevice123\u201d about the temperature sensor (alias temperature), gathered in the time period starting from 2022-12-01T08:05:35Z. cURL curl -X GET \\ -H \"Authorization: Bearer #TOKEN\" \\ \"https://#HOSTNAME/api/coiotedm/v3/deviceMonitoring/data/device123/alias/temperature?timeRangeStart=2022-12-01T08:05:35Z\" Coiote Python from coiote.client import Coiote from datetime import datetime coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . device_monitoring . get_data_batch ( device_id = \"device123\" , alias = \"temperature\" , start_time = datetime . now () ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Retrieve monitoring data from a device using its resource alias"},{"location":"Coiote_IoT_DM/API_documentation/Guides/Use_device_monitoring/#retrieve-monitoring-data-from-the-device-using-its-resource-lwm2m-url","text":"Send a GET request to the endpoint /deviceMonitoring/data/{deviceId}/resourceUrl/{lwm2mUrl} . You have to provide the path parameters deviceId and lwm2mUrl , and the query parameter timeRangeStart . You can also use two additional parameters: timeRangeEnd and limit . To provide the lwm2mUrl parameter use the format \u201c/x/y/\u201d' with numeric values. The following is an example of the request, where you want to get monitoring data of the device with id \u201cdevice123\u201d about the temperature sensor (path /3303/0/5700), gathered in the time period starting from 2022-12-01T08:05:35Z. cURL curl -X GET \\ -H \"Authorization: Bearer #TOKEN\" \\ \"https://#HOSTNAME/api/coiotedm/v3/deviceMonitoring/data/device123/resourceUrl//3303/0/5700?timeRangeStart=2022-12-01T08:05:35Z\" Coiote Python from coiote.client import Coiote from datetime import datetime coiote_auth = \"#TOKEN\" client = Coiote ( url = \"https://#HOSTNAME\" , auth = coiote_auth ) print ( client . device_monitoring . get_data_batch ( device_id = \"device123\" , lwm2m_url = \"/3303/0/5700\" , start_time = datetime . now () ) ) Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname.","title":"Retrieve monitoring data from the device using its resource LwM2M URL"},{"location":"Coiote_IoT_DM/API_documentation/Overview/About_Coiote_API/","text":"About API # Coiote IoT DM is a tool for managing IoT devices and sensor data, as well as monitoring the operation of devices throughout their lifespan. It uses various radio communication technologies, such as Cellular, WiFi, or Thread, and integrates with cloud services. Coiote IoT DM API is intended for both individual developers and technical teams of commercial users. Using the Coiote IoT DM API you can push FOTA updates to IoT devices remotely, implement complete IoT device lifecycle management, or send telemetry data to the Cloud. If you need any support with Coiote IoT DM API implementation and usage, join our Discord community support channel .","title":"About API"},{"location":"Coiote_IoT_DM/API_documentation/Overview/About_Coiote_API/#about-api","text":"Coiote IoT DM is a tool for managing IoT devices and sensor data, as well as monitoring the operation of devices throughout their lifespan. It uses various radio communication technologies, such as Cellular, WiFi, or Thread, and integrates with cloud services. Coiote IoT DM API is intended for both individual developers and technical teams of commercial users. Using the Coiote IoT DM API you can push FOTA updates to IoT devices remotely, implement complete IoT device lifecycle management, or send telemetry data to the Cloud. If you need any support with Coiote IoT DM API implementation and usage, join our Discord community support channel .","title":"About API"},{"location":"Coiote_IoT_DM/API_documentation/Overview/Getting_access/","text":"Getting access # Registration # To use the Coiote IoT DM API you need to have a user account in the platform. Individual users can sign up for a free Developer account using the sign-up page . They are granted a regular user account that has access to a selected set of endpoints, such as devices, groups or deviceEvents. You can find the list of endpoints accessible for a Developer account in the Permissions section. For more information about account types, see Plans and pricing . Authentication # Type of authentication Coiote IoT DM API uses OAuth 2.0 Password Grant authentication. In this form of authentication you have to provide the username and password in a POST request to the server. The server then exchanges the password for an access token. The POST request contains the following parameters: grant_type - by providing the value \u201cpassword\u201d you indicate the password grant authentication type username - your username password - your password Note SSO users (usually business users) need to have an Identity Access Management (IAM) service account. Contact the platform administrator to have this account created. Note In some installations the users obtain access token through exchange token procedure. Contact the platform administrator for more information. How to get access token You can obtain a REST API access token by sending the POST request on an authentication endpoint. If you want to use cURL enter the following command in the terminal: curl -X - `POST` \\ -H \"Content-Type:application/x-www-form-urlencoded\" \\ --data-urlencode \"grant_type=password\" \\ --data-urlencode \"username=user@mail.com\" \\ --data-urlencode \"password=pass\" \\ 'https://#HOSTNAME/api/auth/oauth_password' You can send the request using any of the tools described in section Tools to test our API . The response to this request will contain the access token and its expiration time expressed in seconds: {\"access_token\":\"your_access_token\",\"token_type\":\"Bearer\",\"expires_in\":\"number_of_seconds\"} How to authenticate requests Include the obtained token in the \"authorization\" header of the request. For example: curl -i -X - `GET` \"http://#HOSTNAME/api/coiotedm/v3/devices\" -H \"accept: application/json\" -H \"authorization: Bearer #TOKEN\" Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Error messages related to invalid authentication 401: Unauthorized - you may encounter this error, if you provide incorrect access token 403: Forbidden - you may encounter this error, if you attempt to access an endpoint without the necessary permission Token expiration time The expiration time of the token is determined by the administrator and remains consistent for all user types. Typically, the token expires after around 5 minutes. Permissions # Each endpoint has a separate permission. Developer and Business accounts have permissions for the access to the following set of API endpoints: GET cachedDataModels/{deviceId} DELETE deviceEvents/handler/{id} GET deviceEvents/handler GET deviceEvents/handler/{id} POST deviceMonitoring/configuration/{group_groupId}/enable/ GET deviceMonitoring/{data_deviceId}/alias/{alias} GET deviceMonitoring/{data_deviceId}/resourceUrl/{lwm2mUrl} DELETE devices/{id} GET devices GET devices/{id} POST devices PUT devices/{id} GET devices/all/count POST dialects/addObject GET domains GET domains/{id} DELETE groups/{id} GET groups GET groups/{id} POST groups PUT groups/{id} GET instantiatedResources/dataModelDefinition/{deviceId} GET instantiatedResources/resourcesData/{deviceId} DELETE monitoring/{monitoringName} GET monitoring GET monitoring/{monitoringName} POST monitoring PUT monitoring/{monitoringName} GET monitoringData/aggregates/numerical/{monitoringName}/{groupId}/{resourceName} GET monitoringData/aggregates/textual/{monitoringName}/{groupId}/{resourceName} GET monitoringData/moreSamples GET monitoringData/samples/{monitoringName}/{deviceId} GET observations DELETE observations/device/{deviceId}/{path} GET observations/device/{deviceId}/{path} POST observations/device/{deviceId}/{path} POST sessions/{deviceId} GET settingValues PUT settingValues GET settingValues/deviceProfile/{deviceId} GET settingValues/groupProfile/{groupId} GET taskReports GET taskReports/{taskId}/{deviceId} GET tasks GET tasks/{id} DELETE tasks/callback/{taskId}/{callbackName} GET users/{id}","title":"Getting access"},{"location":"Coiote_IoT_DM/API_documentation/Overview/Getting_access/#getting-access","text":"","title":"Getting access"},{"location":"Coiote_IoT_DM/API_documentation/Overview/Getting_access/#registration","text":"To use the Coiote IoT DM API you need to have a user account in the platform. Individual users can sign up for a free Developer account using the sign-up page . They are granted a regular user account that has access to a selected set of endpoints, such as devices, groups or deviceEvents. You can find the list of endpoints accessible for a Developer account in the Permissions section. For more information about account types, see Plans and pricing .","title":"Registration"},{"location":"Coiote_IoT_DM/API_documentation/Overview/Getting_access/#authentication","text":"Type of authentication Coiote IoT DM API uses OAuth 2.0 Password Grant authentication. In this form of authentication you have to provide the username and password in a POST request to the server. The server then exchanges the password for an access token. The POST request contains the following parameters: grant_type - by providing the value \u201cpassword\u201d you indicate the password grant authentication type username - your username password - your password Note SSO users (usually business users) need to have an Identity Access Management (IAM) service account. Contact the platform administrator to have this account created. Note In some installations the users obtain access token through exchange token procedure. Contact the platform administrator for more information. How to get access token You can obtain a REST API access token by sending the POST request on an authentication endpoint. If you want to use cURL enter the following command in the terminal: curl -X - `POST` \\ -H \"Content-Type:application/x-www-form-urlencoded\" \\ --data-urlencode \"grant_type=password\" \\ --data-urlencode \"username=user@mail.com\" \\ --data-urlencode \"password=pass\" \\ 'https://#HOSTNAME/api/auth/oauth_password' You can send the request using any of the tools described in section Tools to test our API . The response to this request will contain the access token and its expiration time expressed in seconds: {\"access_token\":\"your_access_token\",\"token_type\":\"Bearer\",\"expires_in\":\"number_of_seconds\"} How to authenticate requests Include the obtained token in the \"authorization\" header of the request. For example: curl -i -X - `GET` \"http://#HOSTNAME/api/coiotedm/v3/devices\" -H \"accept: application/json\" -H \"authorization: Bearer #TOKEN\" Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Error messages related to invalid authentication 401: Unauthorized - you may encounter this error, if you provide incorrect access token 403: Forbidden - you may encounter this error, if you attempt to access an endpoint without the necessary permission Token expiration time The expiration time of the token is determined by the administrator and remains consistent for all user types. Typically, the token expires after around 5 minutes.","title":"Authentication"},{"location":"Coiote_IoT_DM/API_documentation/Overview/Getting_access/#permissions","text":"Each endpoint has a separate permission. Developer and Business accounts have permissions for the access to the following set of API endpoints: GET cachedDataModels/{deviceId} DELETE deviceEvents/handler/{id} GET deviceEvents/handler GET deviceEvents/handler/{id} POST deviceMonitoring/configuration/{group_groupId}/enable/ GET deviceMonitoring/{data_deviceId}/alias/{alias} GET deviceMonitoring/{data_deviceId}/resourceUrl/{lwm2mUrl} DELETE devices/{id} GET devices GET devices/{id} POST devices PUT devices/{id} GET devices/all/count POST dialects/addObject GET domains GET domains/{id} DELETE groups/{id} GET groups GET groups/{id} POST groups PUT groups/{id} GET instantiatedResources/dataModelDefinition/{deviceId} GET instantiatedResources/resourcesData/{deviceId} DELETE monitoring/{monitoringName} GET monitoring GET monitoring/{monitoringName} POST monitoring PUT monitoring/{monitoringName} GET monitoringData/aggregates/numerical/{monitoringName}/{groupId}/{resourceName} GET monitoringData/aggregates/textual/{monitoringName}/{groupId}/{resourceName} GET monitoringData/moreSamples GET monitoringData/samples/{monitoringName}/{deviceId} GET observations DELETE observations/device/{deviceId}/{path} GET observations/device/{deviceId}/{path} POST observations/device/{deviceId}/{path} POST sessions/{deviceId} GET settingValues PUT settingValues GET settingValues/deviceProfile/{deviceId} GET settingValues/groupProfile/{groupId} GET taskReports GET taskReports/{taskId}/{deviceId} GET tasks GET tasks/{id} DELETE tasks/callback/{taskId}/{callbackName} GET users/{id}","title":"Permissions"},{"location":"Coiote_IoT_DM/API_documentation/Overview/Using_the_API/","text":"Using the API # Tools to test our API # After obtaining your access token, you can use any available method to send HTTP requests to the Coiote IoT DM API. The following are a few tools that you may find useful. Note You can learn how to get your access token in the Authentication section. cURL cURL is a command-line tool used for making requests to various servers and retrieving data. It is widely used for making HTTP requests. To test Coiote IoT DM API using cURL: Open a terminal or command prompt. Type \"curl\" followed by the URL with the endpoint you want to request and the desired options. You have to include the access token in the authorization header. For example: curl -i -X GET \"http://#HOSTNAME/api/coiotedm/v3/devices\" -H \"accept: application/json\" -H \"authorization: Bearer #TOKEN\" Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Execute the command by pressing Enter. cURL will send the request to the server and display the response on the terminal. Postman Postman is a popular API development and testing tool with a user-friendly interface for making HTTP requests. To test Coiote IoT DM API using Postman: Open Postman in the browser or download the Postman desktop app. Navigate to the new request tab. Enter the URL in the address bar: https://#HOSTNAME/api/coiotedm/v3/ Replace #HOSTNAME with your actual hostname. Include the API endpoint to which you want to send a request, for example: https://#HOSTNAME/api/coiotedm/v3/devices Replace #HOSTNAME with your actual hostname. Go to the Authorization tab. From the Type dropdown list select Bearer Token . Paste your access token. Customize your request by adding headers, query parameters, or request body content. You can do this by clicking on the corresponding tabs. Click Send . Postman will display the response received from the server, including the status code, headers, and response body. You can analyze the response data, save it, or perform additional actions. Postman provides features like response validation, saving requests in collections, or organizing requests into folders. Swagger UI Note Swagger can be used only if the user's password is stored in the Coiote IoT DM DM IAM. It doesn\u2019t work for Single sign-on users. Swagger UI is a tool for visualizing and interacting with APIs that are documented using the OpenAPI Specification. Using Swagger you can expand API endpoints, view request/response details, try out requests directly from the UI, and see the corresponding responses. To access Coiote IoT DM API in Swagger UI: Log in to your Coiote IoT DM account. Click the question mark icon in the top navigation bar. Go to Specification > API v3 . In the Swagger UI: Click Authorize and type your username and password. You will be granted an access token to make requests. Your token expires after around 5 minutes. After that time you have to authorize again. Select an endpoint and click Try it out . Type your search criteria and click Execute . Swagger UI displays your request in cURL and URL format along with the response and description of possible response codes. Making a request # Once you decide on a tool, you can start to form a request. Identify the endpoint you want to use. Decide which endpoint and method will provide you with the results you need. For example, to get a list of devices, you would use GET and the endpoint /devices. For a detailed description of available endpoints consult the API reference. Use parameters to adjust your request. Look for available query parameters to refine your request. If you want to get a list of devices that connected to the system in a selected period of time, you can use the parameter \"lastSessionTime\". Evaluate the response. The API response typically includes a status code, headers, and a response body. If your request from the example is successful, you will receive the status code 200. The headers will include information such as content-length, content-type and time of request. The response body will contain an array of device identifiers: [ \"device_id\", \"device_id\", \"device_id\", \"device_id\", \"device_id\", \"device_id\", \"device_id\", \"device_id\" ] You can encounter the following success response codes: Code Text Description 200 Success The request was successfully processed and the server sends back the requested content in the response body. 201 Created The request to create a new resource was successful. The server includes information about the newly created resource in the response body or through headers. 204 No Content The request was successfully processed, but there is no new data to include in the response body. This status code is often used for requests that update or delete a resource. Error responses # Coiote IoT DM API implements the Standard HTTP error codes as well as custom codes. Every response body contains additional information about the error in JSON format. Standard HTTP error codes The following table lists possible error codes with a short explanation. Code Text Description 400 bad request The server can't process the request because of missing or malformed parameters, or invalid data. You should review the request details, make sure that all required parameters are provided correctly, and validate the syntax of any included data. 403 request forbidden The server can't fulfill the request because you don\u2019t have sufficient permissions for accessing the resource. Check your permissions and contact the server admin if you need help. 404 entity not found The server couldn't locate the requested resource. This could happen, for example, because of a mistyped URL, a deleted or moved resource, or an invalid link or reference. You should verify that the requested URL is correct or check server-side configurations and file availability. 409 conflict with server state The server can\u2019t fulfill the request because of a conflict with the current state of the target resource. This error often happens when a requested resource has been modified by another user, blocking an update or modification request. You should revise your request or coordinate with other users to make sure that conflicting modifications are avoided. 429 too many requests You have sent too many requests to the server within a given timeframe, exceeding the server's rate limit. You should implement mechanisms to control your request rate and respect the server's rate limiting policies. 503 service unavailable The server is currently unable to process the request. This can happen when the server is experiencing high traffic, undergoing maintenance, or facing temporary resource limitations. You should wait for the server to become available again or contact the server administrator for more information on the expected downtime. Custom error codes Custom error codes are implemented to provide more detailed and contextual explanations of the errors. The description for the error code depends on the endpoint and can be found in the request body. The following table lists a few examples of custom error codes with their possible descriptions. Code Description 4000 The provided time range was invalid. The start date must be earlier than the end date and they must be past dates. / Payload is invalid. 4001 The provided limit was invalid. It must be an integer between 1 and 2048. 4002 The handler id must be a 24-byte hexadecimal string representation. 4003 The provided LwM2M URL was invalid. The correct format is '/x/y/z' with the values being numeric. / Kafka domain property is not configured for this domain. 4004 The available handlers limit is already reached. 4005 Provided handler URI is invalid or forbidden. 4006 Provided bootstrap server(s) is invalid or forbidden. 4030 The user does not have the permissions to perform monitoring actions. 4040 The device with the provided ID was not found. / The handler with the given id was not found. 4041 LwM2M resource with provided URL was not found. / The domain with the given id was not found. 4042 LwM2M resource is outside of the monitored range. Objects with ID between 1 and 65534 inclusive are monitored. 5030 System encountered error while processing request, please try again later. 5031 Monitoring is not enabled.","title":"Using the API"},{"location":"Coiote_IoT_DM/API_documentation/Overview/Using_the_API/#using-the-api","text":"","title":"Using the API"},{"location":"Coiote_IoT_DM/API_documentation/Overview/Using_the_API/#tools-to-test-our-api","text":"After obtaining your access token, you can use any available method to send HTTP requests to the Coiote IoT DM API. The following are a few tools that you may find useful. Note You can learn how to get your access token in the Authentication section. cURL cURL is a command-line tool used for making requests to various servers and retrieving data. It is widely used for making HTTP requests. To test Coiote IoT DM API using cURL: Open a terminal or command prompt. Type \"curl\" followed by the URL with the endpoint you want to request and the desired options. You have to include the access token in the authorization header. For example: curl -i -X GET \"http://#HOSTNAME/api/coiotedm/v3/devices\" -H \"accept: application/json\" -H \"authorization: Bearer #TOKEN\" Replace #TOKEN with your actual access token and #HOSTNAME with your actual hostname. Execute the command by pressing Enter. cURL will send the request to the server and display the response on the terminal. Postman Postman is a popular API development and testing tool with a user-friendly interface for making HTTP requests. To test Coiote IoT DM API using Postman: Open Postman in the browser or download the Postman desktop app. Navigate to the new request tab. Enter the URL in the address bar: https://#HOSTNAME/api/coiotedm/v3/ Replace #HOSTNAME with your actual hostname. Include the API endpoint to which you want to send a request, for example: https://#HOSTNAME/api/coiotedm/v3/devices Replace #HOSTNAME with your actual hostname. Go to the Authorization tab. From the Type dropdown list select Bearer Token . Paste your access token. Customize your request by adding headers, query parameters, or request body content. You can do this by clicking on the corresponding tabs. Click Send . Postman will display the response received from the server, including the status code, headers, and response body. You can analyze the response data, save it, or perform additional actions. Postman provides features like response validation, saving requests in collections, or organizing requests into folders. Swagger UI Note Swagger can be used only if the user's password is stored in the Coiote IoT DM DM IAM. It doesn\u2019t work for Single sign-on users. Swagger UI is a tool for visualizing and interacting with APIs that are documented using the OpenAPI Specification. Using Swagger you can expand API endpoints, view request/response details, try out requests directly from the UI, and see the corresponding responses. To access Coiote IoT DM API in Swagger UI: Log in to your Coiote IoT DM account. Click the question mark icon in the top navigation bar. Go to Specification > API v3 . In the Swagger UI: Click Authorize and type your username and password. You will be granted an access token to make requests. Your token expires after around 5 minutes. After that time you have to authorize again. Select an endpoint and click Try it out . Type your search criteria and click Execute . Swagger UI displays your request in cURL and URL format along with the response and description of possible response codes.","title":"Tools to test our API"},{"location":"Coiote_IoT_DM/API_documentation/Overview/Using_the_API/#making-a-request","text":"Once you decide on a tool, you can start to form a request. Identify the endpoint you want to use. Decide which endpoint and method will provide you with the results you need. For example, to get a list of devices, you would use GET and the endpoint /devices. For a detailed description of available endpoints consult the API reference. Use parameters to adjust your request. Look for available query parameters to refine your request. If you want to get a list of devices that connected to the system in a selected period of time, you can use the parameter \"lastSessionTime\". Evaluate the response. The API response typically includes a status code, headers, and a response body. If your request from the example is successful, you will receive the status code 200. The headers will include information such as content-length, content-type and time of request. The response body will contain an array of device identifiers: [ \"device_id\", \"device_id\", \"device_id\", \"device_id\", \"device_id\", \"device_id\", \"device_id\", \"device_id\" ] You can encounter the following success response codes: Code Text Description 200 Success The request was successfully processed and the server sends back the requested content in the response body. 201 Created The request to create a new resource was successful. The server includes information about the newly created resource in the response body or through headers. 204 No Content The request was successfully processed, but there is no new data to include in the response body. This status code is often used for requests that update or delete a resource.","title":"Making a request"},{"location":"Coiote_IoT_DM/API_documentation/Overview/Using_the_API/#error-responses","text":"Coiote IoT DM API implements the Standard HTTP error codes as well as custom codes. Every response body contains additional information about the error in JSON format. Standard HTTP error codes The following table lists possible error codes with a short explanation. Code Text Description 400 bad request The server can't process the request because of missing or malformed parameters, or invalid data. You should review the request details, make sure that all required parameters are provided correctly, and validate the syntax of any included data. 403 request forbidden The server can't fulfill the request because you don\u2019t have sufficient permissions for accessing the resource. Check your permissions and contact the server admin if you need help. 404 entity not found The server couldn't locate the requested resource. This could happen, for example, because of a mistyped URL, a deleted or moved resource, or an invalid link or reference. You should verify that the requested URL is correct or check server-side configurations and file availability. 409 conflict with server state The server can\u2019t fulfill the request because of a conflict with the current state of the target resource. This error often happens when a requested resource has been modified by another user, blocking an update or modification request. You should revise your request or coordinate with other users to make sure that conflicting modifications are avoided. 429 too many requests You have sent too many requests to the server within a given timeframe, exceeding the server's rate limit. You should implement mechanisms to control your request rate and respect the server's rate limiting policies. 503 service unavailable The server is currently unable to process the request. This can happen when the server is experiencing high traffic, undergoing maintenance, or facing temporary resource limitations. You should wait for the server to become available again or contact the server administrator for more information on the expected downtime. Custom error codes Custom error codes are implemented to provide more detailed and contextual explanations of the errors. The description for the error code depends on the endpoint and can be found in the request body. The following table lists a few examples of custom error codes with their possible descriptions. Code Description 4000 The provided time range was invalid. The start date must be earlier than the end date and they must be past dates. / Payload is invalid. 4001 The provided limit was invalid. It must be an integer between 1 and 2048. 4002 The handler id must be a 24-byte hexadecimal string representation. 4003 The provided LwM2M URL was invalid. The correct format is '/x/y/z' with the values being numeric. / Kafka domain property is not configured for this domain. 4004 The available handlers limit is already reached. 4005 Provided handler URI is invalid or forbidden. 4006 Provided bootstrap server(s) is invalid or forbidden. 4030 The user does not have the permissions to perform monitoring actions. 4040 The device with the provided ID was not found. / The handler with the given id was not found. 4041 LwM2M resource with provided URL was not found. / The domain with the given id was not found. 4042 LwM2M resource is outside of the monitored range. Objects with ID between 1 and 65534 inclusive are monitored. 5030 System encountered error while processing request, please try again later. 5031 Monitoring is not enabled.","title":"Error responses"},{"location":"Coiote_IoT_DM/Cloud_integrations/Use_API_Jenkins_integration/","text":"Jenkins/GitLab integration with device tests API # If you would like to automate your device tests, you can use the Coiote IoT DM API and integrate it with a CI/CD environment like Jenkins or GitLab. Follow the guide below to learn how to configure the integration, run tests and summarize your test execution using these tools. Note The following instruction is based on integration with Jenkins. To integrate with GitLab, you can follow the same steps, but with slight adjustments - for details, please see subsection on GitLab . Prerequisites # An active Jenkins and GitLab account. A Git project repository. A working Coiote IoT DM installation and a port for communication with the installation API. A device registered in the platform (if the tests require the device to be registered). A Coiote IoT DM user with access to the device and the appropriate API permissions. Jenkins - standard pipeline # Set up standard pipeline # Upload a file with python script used to run tests to your project repository: Edit the following python script where required to adjust it to your environment (remember to select the appropriate tab with script depending on whether you want to run your tests on a single device or a device group). Device #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_NAME = \"test-device\" # type the endpoint name of your device. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote IoT DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote IoT DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the device. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/device/\" + DEVICE_NAME REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/device/\" + DEVICE_NAME PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = result . json ()[ \"waitingForExecution\" ] time . sleep ( 15 ) for test in result . json ()[ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Group #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_GROUP = \"root.mt.embedded.devicetypes.test.demo_client.2_9_0\" # type the name of your device group. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote IoT DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote IoT DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the group. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/group/\" + DEVICE_GROUP REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/group/\" + DEVICE_GROUP PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : still_running = 0 result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) exit ( 1 ) for device in result . json (): if not ( result . json ()[ device ][ \"waitingForExecution\" ] == []): still_running += 1 if ( still_running == 0 ): tests_running = False time . sleep ( 15 ) for device in result . json (): for test in result . json ()[ device ][ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ device ][ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ device ][ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Save the script as a .py file and upload it to your project repository. Create a pipeline for your project: Go to your Jenkins account and in the Dashboard view, select New Item from the menu on the left. Enter a name for your pipeline, select Pipeline , and confirm by clicking OK . Configure your pipeline: Go to your newly created pipeline and select Configure from the menu on the left. In the Source Code Management section, select the Git option and provide the following: Repository URL - enter the URL address of your GitLab repository that hosts the python script file from Step 1 . Credentials - add the user name and password of your git repository account. Branch Specifier - choose the GitLab branch you want to use in the pipeline. In the Build section, select the Execute Shell option from the drop-down list and provide the command to run the python script file from Step 1 : python3 example_filename.py Additionally, in the Post-build Actions section, select the Publish Junit test result report to set up test result report generation: Depending on your preferences, check or uncheck the Allow empty results option. Click Save . Run standard pipeline # Enter pipeline and select Build Now . Note Remember to check if the device you run the tests for is connected and registered in Coiote IoT DM. Once the tests are performed, you will see your build status along with a graph reporting the execution status for each test. Jenkins multibranch pipeline # Set up multibranch pipeline # Alternatively to the standard pipeline, you may configure a multibranch pipeline to run your tests. Upload the Jenkinsfile that will define your multibranch pipeline to your project repository: Edit the script where required to adjust it to your environment: Note Remember to change the name example_filename.py to your custom name that you will choose in Step 2 . pipeline { options { disableConcurrentBuilds () } agent any stages { stage ( 'protocol_tests' ) { steps { sh 'python3 example_filename.py' } } } post { always { junit \"report.xml\" archiveArtifacts artifacts : 'report.xml' } cleanup { script { clean () } } } } Save the file as Jenkinsfile and upload it to the chosen branch of your project repository. Upload a file with python script used to run tests to your project repository: Edit the following python script where required to adjust it to your environment (remember to select the appropriate tab with script depending on whether you want to run your tests on a single device or a device group). Device #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_NAME = \"test-device\" # type the endpoint name of your device. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote IoT DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote IoT DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the device. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/device/\" + DEVICE_NAME REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/device/\" + DEVICE_NAME PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = result . json ()[ \"waitingForExecution\" ] time . sleep ( 15 ) for test in result . json ()[ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Group #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_GROUP = \"root.mt.embedded.devicetypes.test.demo_client.2_9_0\" # type the name of your device group. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote IoT DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote IoT DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the group. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/group/\" + DEVICE_GROUP REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/group/\" + DEVICE_GROUP PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : still_running = 0 result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) exit ( 1 ) for device in result . json (): if not ( result . json ()[ device ][ \"waitingForExecution\" ] == []): still_running += 1 if ( still_running == 0 ): tests_running = False time . sleep ( 15 ) for device in result . json (): for test in result . json ()[ device ][ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ device ][ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ device ][ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Save the script as a .py file (using the filename specified in the Jenkinsfile in the previous step) and upload it to your project repository. Create a pipeline for your project: Go to your Jenkins account and in the Dashboard view, select New Item from the menu on the left. Enter a name for your pipeline, select Multibranch Pipeline and confirm by clicking OK . Configure your pipeline: Go to your newly created pipeline and select Configure from the menu on the left. In the Branch Sources section, select the Git option and provide the following: Project Repository - enter the URL address of your project repository that hosts the Jenkinsfile and the python script file from Step 2 . Credentials - add the user name and password of your GitLab account. In the Build Configuration section, select the by Jenkinsfile mode from the drop-down list and provide the GitLab path to the Jenkinsfile from Step 1 (if the file is located in the GitLab root folder, it is enough to type Jenkinsfile ) Click Save . Run multibranch pipeline # Before running the tests for a chosen branch, you have to perform a scan to detect available branches (those with a Jenkinsfile ): Go to your multibranch pipeline and select Scan Multibranch Pipeline Now option from the menu on the left. Once the scan is completed, you will see a list of available branches. Enter a chosen branch by clicking on its name and select Build Now . Note Remember to check if the device you run the tests for is connected and registered in Coiote IoT DM. Once the tests are performed, you will see your build status along with a graph reporting the execution status for each test. GitLab - configure and run pipeline # Coiote IoT DM interop tests API can also be integrated with GitLab using the GitLab's CI/CD toolset. Here is how to do it: Upload the gitlab-ci.yml file that will define your GitLab pipeline to your project repository: Edit the script where required to adjust it to your environment: Note Remember to change the name example_filename.py to your custom name that you will choose in the next step. Also, keep in mind that running a pipeline in GitLab requires a docker image of a Linux distribution (or any operating system that can run python script). image : name : example.repository.com/docker-local/linux_image protocol-tests : stage : test script : - python3 example_filename.py artifacts : when : always paths : - report.xml reports : junit : report.xml Save the file as gitlab-ci.yml and upload it to the chosen branch of your project repository. Follow Step 2 from Creating a Jenkins multibranch pipeline (uploading a file with python script to your GitLab repository). Run a created pipeline for your project: Go to your GitLab project and in the Dashboard view, select CI/CD from the menu on the left and click Pipelines . Attention Note that to be able to run a pipeline, you will need to have the GitLab CI/CD toolset configured. For details, please check https://docs.gitlab.com/ee/ci/introduction/index.html . You should be able to see the branch with the uploaded gitlab-ci.yml file. Select the Run pipeline button, then confirm again by clicking Run pipeline . Once the pipeline execution is finished, you should be able to see the results in the Tests tab of your pipeline. Note Viewing graphs with test results is not supported in GitLab by default as it requires additional plugins.","title":"Jenkins/GitLab integration with device tests API"},{"location":"Coiote_IoT_DM/Cloud_integrations/Use_API_Jenkins_integration/#jenkinsgitlab-integration-with-device-tests-api","text":"If you would like to automate your device tests, you can use the Coiote IoT DM API and integrate it with a CI/CD environment like Jenkins or GitLab. Follow the guide below to learn how to configure the integration, run tests and summarize your test execution using these tools. Note The following instruction is based on integration with Jenkins. To integrate with GitLab, you can follow the same steps, but with slight adjustments - for details, please see subsection on GitLab .","title":"Jenkins/GitLab integration with device tests API"},{"location":"Coiote_IoT_DM/Cloud_integrations/Use_API_Jenkins_integration/#prerequisites","text":"An active Jenkins and GitLab account. A Git project repository. A working Coiote IoT DM installation and a port for communication with the installation API. A device registered in the platform (if the tests require the device to be registered). A Coiote IoT DM user with access to the device and the appropriate API permissions.","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Use_API_Jenkins_integration/#jenkins-standard-pipeline","text":"","title":"Jenkins - standard pipeline"},{"location":"Coiote_IoT_DM/Cloud_integrations/Use_API_Jenkins_integration/#set-up-standard-pipeline","text":"Upload a file with python script used to run tests to your project repository: Edit the following python script where required to adjust it to your environment (remember to select the appropriate tab with script depending on whether you want to run your tests on a single device or a device group). Device #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_NAME = \"test-device\" # type the endpoint name of your device. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote IoT DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote IoT DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the device. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/device/\" + DEVICE_NAME REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/device/\" + DEVICE_NAME PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = result . json ()[ \"waitingForExecution\" ] time . sleep ( 15 ) for test in result . json ()[ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Group #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_GROUP = \"root.mt.embedded.devicetypes.test.demo_client.2_9_0\" # type the name of your device group. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote IoT DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote IoT DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the group. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/group/\" + DEVICE_GROUP REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/group/\" + DEVICE_GROUP PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : still_running = 0 result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) exit ( 1 ) for device in result . json (): if not ( result . json ()[ device ][ \"waitingForExecution\" ] == []): still_running += 1 if ( still_running == 0 ): tests_running = False time . sleep ( 15 ) for device in result . json (): for test in result . json ()[ device ][ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ device ][ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ device ][ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Save the script as a .py file and upload it to your project repository. Create a pipeline for your project: Go to your Jenkins account and in the Dashboard view, select New Item from the menu on the left. Enter a name for your pipeline, select Pipeline , and confirm by clicking OK . Configure your pipeline: Go to your newly created pipeline and select Configure from the menu on the left. In the Source Code Management section, select the Git option and provide the following: Repository URL - enter the URL address of your GitLab repository that hosts the python script file from Step 1 . Credentials - add the user name and password of your git repository account. Branch Specifier - choose the GitLab branch you want to use in the pipeline. In the Build section, select the Execute Shell option from the drop-down list and provide the command to run the python script file from Step 1 : python3 example_filename.py Additionally, in the Post-build Actions section, select the Publish Junit test result report to set up test result report generation: Depending on your preferences, check or uncheck the Allow empty results option. Click Save .","title":"Set up standard pipeline"},{"location":"Coiote_IoT_DM/Cloud_integrations/Use_API_Jenkins_integration/#run-standard-pipeline","text":"Enter pipeline and select Build Now . Note Remember to check if the device you run the tests for is connected and registered in Coiote IoT DM. Once the tests are performed, you will see your build status along with a graph reporting the execution status for each test.","title":"Run standard pipeline"},{"location":"Coiote_IoT_DM/Cloud_integrations/Use_API_Jenkins_integration/#jenkins-multibranch-pipeline","text":"","title":"Jenkins multibranch pipeline"},{"location":"Coiote_IoT_DM/Cloud_integrations/Use_API_Jenkins_integration/#set-up-multibranch-pipeline","text":"Alternatively to the standard pipeline, you may configure a multibranch pipeline to run your tests. Upload the Jenkinsfile that will define your multibranch pipeline to your project repository: Edit the script where required to adjust it to your environment: Note Remember to change the name example_filename.py to your custom name that you will choose in Step 2 . pipeline { options { disableConcurrentBuilds () } agent any stages { stage ( 'protocol_tests' ) { steps { sh 'python3 example_filename.py' } } } post { always { junit \"report.xml\" archiveArtifacts artifacts : 'report.xml' } cleanup { script { clean () } } } } Save the file as Jenkinsfile and upload it to the chosen branch of your project repository. Upload a file with python script used to run tests to your project repository: Edit the following python script where required to adjust it to your environment (remember to select the appropriate tab with script depending on whether you want to run your tests on a single device or a device group). Device #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_NAME = \"test-device\" # type the endpoint name of your device. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote IoT DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote IoT DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the device. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/device/\" + DEVICE_NAME REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/device/\" + DEVICE_NAME PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = result . json ()[ \"waitingForExecution\" ] time . sleep ( 15 ) for test in result . json ()[ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Group #!/usr/bin/python import requests import json import time import xml.etree.cElementTree as ET # ___Edit below___ # DEVICE_GROUP = \"root.mt.embedded.devicetypes.test.demo_client.2_9_0\" # type the name of your device group. INSTALLATION_URL = \"https://lwm2m-test.avsystem.io\" # provide the URL of your Coiote IoT DM installation. INSTALLATION_API_PORT = \"8087\" # provide the port for communication with the API. The default value is `8087`. CREDENTIALS = ( 'user_login' , 'password' ) # provide user name and password of your Coiote IoT DM user account. TEST_NAMES = { # type the names of the tests that you want to execute on the group. \"testCases\" :[ \"protocol_test_1\" , \"protocol_test_2\" , \"protocol_test_3\" , \"protocol_test_4\" , \"protocol_test_5\" , ] } # ___Edit above___ # SCHEDULE_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/schedule/group/\" + DEVICE_GROUP REPORT_URL = INSTALLATION_URL + \":\" + INSTALLATION_API_PORT + \"/api/coiotedm/v3/protocolTests/report/group/\" + DEVICE_GROUP PARAMS = { 'accept' : 'application/json' , 'Content-Type' : 'application/json' } root = ET . Element ( \"testsuite\" ) result = requests . post ( url = SCHEDULE_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 201 : print ( 'Could not schedule the tests.' ) print ( 'Server returned: ' + str ( result . status_code )) print ( 'Error message: ' + str ( result . json ()[ 'error' ])) exit ( 1 ) tests_running = True while tests_running : still_running = 0 result = requests . post ( url = REPORT_URL , json = TEST_NAMES , auth = CREDENTIALS , params = PARAMS ) if result . status_code != 200 : print ( 'Could not read the tests status.' ) print ( 'Server returned: ' + str ( result . status_code )) exit ( 1 ) for device in result . json (): if not ( result . json ()[ device ][ \"waitingForExecution\" ] == []): still_running += 1 if ( still_running == 0 ): tests_running = False time . sleep ( 15 ) for device in result . json (): for test in result . json ()[ device ][ 'failed' ]: a = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( a , \"failure\" , type = \"failure\" ) for test in result . json ()[ device ][ 'passedWithWarning' ]: b = ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) ET . SubElement ( b , \"failure\" , type = \"warning\" ) for test in result . json ()[ device ][ 'passedSuccessfully' ]: ET . SubElement ( root , \"testcase\" , classname = \"interop\" , name = test , device = device ) tree = ET . ElementTree ( root ) tree . write ( \"report.xml\" ) Save the script as a .py file (using the filename specified in the Jenkinsfile in the previous step) and upload it to your project repository. Create a pipeline for your project: Go to your Jenkins account and in the Dashboard view, select New Item from the menu on the left. Enter a name for your pipeline, select Multibranch Pipeline and confirm by clicking OK . Configure your pipeline: Go to your newly created pipeline and select Configure from the menu on the left. In the Branch Sources section, select the Git option and provide the following: Project Repository - enter the URL address of your project repository that hosts the Jenkinsfile and the python script file from Step 2 . Credentials - add the user name and password of your GitLab account. In the Build Configuration section, select the by Jenkinsfile mode from the drop-down list and provide the GitLab path to the Jenkinsfile from Step 1 (if the file is located in the GitLab root folder, it is enough to type Jenkinsfile ) Click Save .","title":"Set up multibranch pipeline"},{"location":"Coiote_IoT_DM/Cloud_integrations/Use_API_Jenkins_integration/#run-multibranch-pipeline","text":"Before running the tests for a chosen branch, you have to perform a scan to detect available branches (those with a Jenkinsfile ): Go to your multibranch pipeline and select Scan Multibranch Pipeline Now option from the menu on the left. Once the scan is completed, you will see a list of available branches. Enter a chosen branch by clicking on its name and select Build Now . Note Remember to check if the device you run the tests for is connected and registered in Coiote IoT DM. Once the tests are performed, you will see your build status along with a graph reporting the execution status for each test.","title":"Run multibranch pipeline"},{"location":"Coiote_IoT_DM/Cloud_integrations/Use_API_Jenkins_integration/#gitlab-configure-and-run-pipeline","text":"Coiote IoT DM interop tests API can also be integrated with GitLab using the GitLab's CI/CD toolset. Here is how to do it: Upload the gitlab-ci.yml file that will define your GitLab pipeline to your project repository: Edit the script where required to adjust it to your environment: Note Remember to change the name example_filename.py to your custom name that you will choose in the next step. Also, keep in mind that running a pipeline in GitLab requires a docker image of a Linux distribution (or any operating system that can run python script). image : name : example.repository.com/docker-local/linux_image protocol-tests : stage : test script : - python3 example_filename.py artifacts : when : always paths : - report.xml reports : junit : report.xml Save the file as gitlab-ci.yml and upload it to the chosen branch of your project repository. Follow Step 2 from Creating a Jenkins multibranch pipeline (uploading a file with python script to your GitLab repository). Run a created pipeline for your project: Go to your GitLab project and in the Dashboard view, select CI/CD from the menu on the left and click Pipelines . Attention Note that to be able to run a pipeline, you will need to have the GitLab CI/CD toolset configured. For details, please check https://docs.gitlab.com/ee/ci/introduction/index.html . You should be able to see the branch with the uploaded gitlab-ci.yml file. Select the Run pipeline button, then confirm again by clicking Run pipeline . Once the pipeline execution is finished, you should be able to see the results in the Tests tab of your pipeline. Note Viewing graphs with test results is not supported in GitLab by default as it requires additional plugins.","title":"GitLab - configure and run pipeline"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/","text":"Set an Observation # This section describes how to set an Observation in your Azure IoT Central application. Setting an Observation lets your devices know what value changes and for what particular resources they need to notify you about. An Observation can be set for any or all the components of the data model : objects, objects instances, and resources. Whenever there is a change in values, a device will send a Notify message to Coiote IoT DM, which in turn will transfer it to Azure IoT Central. In this section, you learn how to: Assign a device template that acts as a translator between Coiote IoT DM and Azure IoT Central. Create a device group in Azure IoT Central, because an Observation is set at the group level. Run Jobs to add, edit or delete Observations. See value changes for the observed resources. Prerequisites # An active Azure IoT Central with hub owner access permissions. A Coiote IoT DM user account with permissions to use the Azure IoT Central integration. A device group created in Coiote IoT DM. A configured integration between Coiote IoT DM and Azure Iot Central . A configured integration template in Coiote IoT DM, assigned to the device group . A connected device in Coiote IoT DM that has been exported to or imported from Azure IoT Central. Assign a device template # To enable correct communication between Coiote IoT DM and Azure IoT Central, you need two templates. The first template configures the Coiote IoT DM integration with Azure. ( Follow the instruction to learn how to configure it.) The second template builds on the first one and allows to provide information that is used only in Azure IoT Central. For example: a given resource is temperature and is measured in Celsius. Download LwM2M template in Coiote IoT DM # In Coiote IoT DM, go to Administration \u2192 Hyperscaler Integration Center and select the Templates tab. In the list of templates, find the one from which you want to generate the IoT Central template. Attention The template must contain the objects that you want to observe. For example, the Velocity object is contained in the Default rich LwM2M schema template that we use in this tutorial. Click Generate Azure IoT Central template to download the template as a JSON file. Info Default minimal LwM2M schema and Default rich LwM2M schema are the default Azure integration templates that you can use to generate a template for Azure IoT Central. Default minimal LwM2M schema contains only two objects: LwM2M Server and Device that are necessary to connect a device to a LwM2M server. Default rich LwM2M schema contains some additional objects that describe the current state of a device. You can use these default templates to test your integration or for some basic operations. If your device contains other LwM2M objects, then you need to create a new template or copy and edit on of the default templates. Create a device template in Azure IoT Central # From the Overview tab of your Azure IoT Central account, go to IoT Central Application URL . To add a new device template, go to Device templates from the left pane and then click + New . On the Select type page, select the IoT device tile and click Next: Customize . Enter a name for your device template and click Next: Review . Leave the checkbox unticked. In this example, our device template is called template_test_name . On the Review page, click Create . Now you'll be prompted to create a model for your template. Select the Import a model tile. This is where you import the .JSON file you exported from Coiote IoT DM. To publish this device template to the application, click Publish on the Model page. Assign a device template in Azure IoT Central # To assign the published template to a device, go to Devices from the left pane and click on the device you want to observe. In our case, the device is called soilquality . Click Manage templates and choose Assign template . In the dialog that appears, find the template you have previously created in Azure (in our case, this is template_test_name ) and click Assign template . Create a group # Now that you have a device with a template assigned to it, you need to add this device to a group. To create a group: In Azure IoT Central, go to Device groups from the left pane and click + New . Note A device group can only contain devices from a single device template. Fill in the following information: Group name and an optional description. In our case, the group is called device_group_test . Device group access : skip, because LwM2M test application doesn\u2019t use organizations. Create a device query : from the Value drop-down menu, select the name of the device template you created in the previous step ( template_test_name ). Click Run query . After running a query, you'll see the list of devices that are associated with this template. In our case it\u2019s the device called soilquality . Click Save . Set up an Observation # Let\u2019s set an Observation operation on resource ID 6/0/4 . This is Velocity, and the data is sent as Telemetry. To add an Observation, you need to use the Jobs tab. In Azure IoT Central, go to Jobs from the left pane and click + New job . Now configure your job: Name *: Provide a name and an optional description of the job. Access : skip, because LwM2M test application doesn\u2019t use organizations. Target devices : select the device group this job will run on. In our case this is device_group_test . Job properties : Set Job type as Property . Under the Name field, select Velocity attribute / Observed and turn the toggle to True . Add the attributes to this observation. Click + Add and select Velocity attributes / Observation attributes / <name> from the drop-down menu. In the dialog that appears, specify the name of the attribute: pmin . Close the dialog. Enter a value of Velocity attributes / Observation attributes / pmin . In this tutorial the value is set at 1 , which means that notifications will be sent every second. Click Next . Info pmin - the minimum time in seconds between two notifications. pmax - the maximum time in seconds between two notifications. The notification is sent even if the value didn't change. Read more about other attributes in our Brief description of OMA LwM2M . In Delivery options , click Next . In Schedule , click Next . Review the job: n6n0n4 stands for Velocity. Note that objects, object instances, and resources are separated by n in Azure IoT Central. observed is set at true The attribute pmin is set at 1 second. Click Run . See the value changes in Azure IoT Central # In Azure IoT Central, go to Devices from the left pane and click on the device you're observing. You'll see the list of messages that notify about any changes in the desired and reported properties for this device. In the Raw data tab, unfold one of the recent messages. Note that this tab contains all the messages received from your device, and some of them might relate to other objects. Look for a recent message where the JSON snippet contains the information that the Observation has been set for the telemetry resource n6n0n4 (Velocity). To see the data received about the value changes, scroll right until you see the Velocity column. Tip If you don\u2019t see any value in the relevant column (e.g., Velocity), scroll all the way right to the very last column Unmodeled data . If it contains an entry similar to {\"n6n0n4\":\"1634741504000\"} , it means there is a mismatch between Coiote IoT DM and the Azure IoT Central templates. Velocity is a Telemetry resource, but apparently it's set as Property in Azure. To fix this error, go to Device templates in Azure IoT Central, select the relevant template and find the resource you want to edit. In the Capability type column, select Telemetry from the drop-down menu so that it\u2019s consistent with what you have in Coiote IoT DM. Click Save . Go back to Devices and refresh the page to see the changes. Edit or delete an Observation # To edit or delete an Observation, you need to create a new job. In Azure IoT Central, go to Jobs from the left pane and click + New job . Alternatively, you can copy an existing job: Select the job and then click Copy job . To edit the Observation attributes , change the value in the text box. To change the map keys (e.g., pmax to pmin), click on the Ellipse button. To delete an Observation, turn off the toggle to False . Check an Observation in Coiote IoT DM # This step is optional. If you want to make sure that the Observation has been set in Coiote IoT DM as well, do the following: In Coiote IoT DM, go to Device inventory and click on the observed device. From the left pane of the device panel, go to Objects . Find the resource you want to check. In our example, this is 4 Velocity resource in the 6 Location object. Click the refresh button to the left from the Value tracking . You'll see that checkboxes next to Value tracking and Attributes are now filled in green. Next steps # Air quality monitoring - tutorial","title":"Set an Observation"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#set-an-observation","text":"This section describes how to set an Observation in your Azure IoT Central application. Setting an Observation lets your devices know what value changes and for what particular resources they need to notify you about. An Observation can be set for any or all the components of the data model : objects, objects instances, and resources. Whenever there is a change in values, a device will send a Notify message to Coiote IoT DM, which in turn will transfer it to Azure IoT Central. In this section, you learn how to: Assign a device template that acts as a translator between Coiote IoT DM and Azure IoT Central. Create a device group in Azure IoT Central, because an Observation is set at the group level. Run Jobs to add, edit or delete Observations. See value changes for the observed resources.","title":"Set an Observation"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#prerequisites","text":"An active Azure IoT Central with hub owner access permissions. A Coiote IoT DM user account with permissions to use the Azure IoT Central integration. A device group created in Coiote IoT DM. A configured integration between Coiote IoT DM and Azure Iot Central . A configured integration template in Coiote IoT DM, assigned to the device group . A connected device in Coiote IoT DM that has been exported to or imported from Azure IoT Central.","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#assign-a-device-template","text":"To enable correct communication between Coiote IoT DM and Azure IoT Central, you need two templates. The first template configures the Coiote IoT DM integration with Azure. ( Follow the instruction to learn how to configure it.) The second template builds on the first one and allows to provide information that is used only in Azure IoT Central. For example: a given resource is temperature and is measured in Celsius.","title":"Assign a device template"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#download-lwm2m-template-in-coiote-iot-dm","text":"In Coiote IoT DM, go to Administration \u2192 Hyperscaler Integration Center and select the Templates tab. In the list of templates, find the one from which you want to generate the IoT Central template. Attention The template must contain the objects that you want to observe. For example, the Velocity object is contained in the Default rich LwM2M schema template that we use in this tutorial. Click Generate Azure IoT Central template to download the template as a JSON file. Info Default minimal LwM2M schema and Default rich LwM2M schema are the default Azure integration templates that you can use to generate a template for Azure IoT Central. Default minimal LwM2M schema contains only two objects: LwM2M Server and Device that are necessary to connect a device to a LwM2M server. Default rich LwM2M schema contains some additional objects that describe the current state of a device. You can use these default templates to test your integration or for some basic operations. If your device contains other LwM2M objects, then you need to create a new template or copy and edit on of the default templates.","title":"Download LwM2M template in Coiote IoT DM"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#create-a-device-template-in-azure-iot-central","text":"From the Overview tab of your Azure IoT Central account, go to IoT Central Application URL . To add a new device template, go to Device templates from the left pane and then click + New . On the Select type page, select the IoT device tile and click Next: Customize . Enter a name for your device template and click Next: Review . Leave the checkbox unticked. In this example, our device template is called template_test_name . On the Review page, click Create . Now you'll be prompted to create a model for your template. Select the Import a model tile. This is where you import the .JSON file you exported from Coiote IoT DM. To publish this device template to the application, click Publish on the Model page.","title":"Create a device template in Azure IoT Central"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#assign-a-device-template-in-azure-iot-central","text":"To assign the published template to a device, go to Devices from the left pane and click on the device you want to observe. In our case, the device is called soilquality . Click Manage templates and choose Assign template . In the dialog that appears, find the template you have previously created in Azure (in our case, this is template_test_name ) and click Assign template .","title":"Assign a device template in Azure IoT Central"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#create-a-group","text":"Now that you have a device with a template assigned to it, you need to add this device to a group. To create a group: In Azure IoT Central, go to Device groups from the left pane and click + New . Note A device group can only contain devices from a single device template. Fill in the following information: Group name and an optional description. In our case, the group is called device_group_test . Device group access : skip, because LwM2M test application doesn\u2019t use organizations. Create a device query : from the Value drop-down menu, select the name of the device template you created in the previous step ( template_test_name ). Click Run query . After running a query, you'll see the list of devices that are associated with this template. In our case it\u2019s the device called soilquality . Click Save .","title":"Create a group"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#set-up-an-observation","text":"Let\u2019s set an Observation operation on resource ID 6/0/4 . This is Velocity, and the data is sent as Telemetry. To add an Observation, you need to use the Jobs tab. In Azure IoT Central, go to Jobs from the left pane and click + New job . Now configure your job: Name *: Provide a name and an optional description of the job. Access : skip, because LwM2M test application doesn\u2019t use organizations. Target devices : select the device group this job will run on. In our case this is device_group_test . Job properties : Set Job type as Property . Under the Name field, select Velocity attribute / Observed and turn the toggle to True . Add the attributes to this observation. Click + Add and select Velocity attributes / Observation attributes / <name> from the drop-down menu. In the dialog that appears, specify the name of the attribute: pmin . Close the dialog. Enter a value of Velocity attributes / Observation attributes / pmin . In this tutorial the value is set at 1 , which means that notifications will be sent every second. Click Next . Info pmin - the minimum time in seconds between two notifications. pmax - the maximum time in seconds between two notifications. The notification is sent even if the value didn't change. Read more about other attributes in our Brief description of OMA LwM2M . In Delivery options , click Next . In Schedule , click Next . Review the job: n6n0n4 stands for Velocity. Note that objects, object instances, and resources are separated by n in Azure IoT Central. observed is set at true The attribute pmin is set at 1 second. Click Run .","title":"Set up an Observation"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#see-the-value-changes-in-azure-iot-central","text":"In Azure IoT Central, go to Devices from the left pane and click on the device you're observing. You'll see the list of messages that notify about any changes in the desired and reported properties for this device. In the Raw data tab, unfold one of the recent messages. Note that this tab contains all the messages received from your device, and some of them might relate to other objects. Look for a recent message where the JSON snippet contains the information that the Observation has been set for the telemetry resource n6n0n4 (Velocity). To see the data received about the value changes, scroll right until you see the Velocity column. Tip If you don\u2019t see any value in the relevant column (e.g., Velocity), scroll all the way right to the very last column Unmodeled data . If it contains an entry similar to {\"n6n0n4\":\"1634741504000\"} , it means there is a mismatch between Coiote IoT DM and the Azure IoT Central templates. Velocity is a Telemetry resource, but apparently it's set as Property in Azure. To fix this error, go to Device templates in Azure IoT Central, select the relevant template and find the resource you want to edit. In the Capability type column, select Telemetry from the drop-down menu so that it\u2019s consistent with what you have in Coiote IoT DM. Click Save . Go back to Devices and refresh the page to see the changes.","title":"See the value changes in Azure IoT Central"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#edit-or-delete-an-observation","text":"To edit or delete an Observation, you need to create a new job. In Azure IoT Central, go to Jobs from the left pane and click + New job . Alternatively, you can copy an existing job: Select the job and then click Copy job . To edit the Observation attributes , change the value in the text box. To change the map keys (e.g., pmax to pmin), click on the Ellipse button. To delete an Observation, turn off the toggle to False .","title":"Edit or delete an Observation"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#check-an-observation-in-coiote-iot-dm","text":"This step is optional. If you want to make sure that the Observation has been set in Coiote IoT DM as well, do the following: In Coiote IoT DM, go to Device inventory and click on the observed device. From the left pane of the device panel, go to Objects . Find the resource you want to check. In our example, this is 4 Velocity resource in the 6 Location object. Click the refresh button to the left from the Value tracking . You'll see that checkboxes next to Value tracking and Attributes are now filled in green.","title":"Check an Observation in Coiote IoT DM"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Central/Set_an_Observation/#next-steps","text":"Air quality monitoring - tutorial","title":"Next steps"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Execute/","text":"Perform LwM2M Execute # This section describes how to perform a LwM2M EXECUTE operation in your Azure IoT Hub. An EXECUTE operation lets you perform operations on IoT devices such as a reboot or a firmware upgrade, only on individual resources. In this section, you learn how to: Perform a LwM2M EXECUTE operation on a resource Prerequisites # An active Azure IoT Hub with hub owner access permissions. A Coiote IoT DM user account with permissions to use the integration extension. A device group created in Coiote IoT DM. A configured extension between Coiote IoT DM and Azure Iot Hub . A configured integration template in Coiote IoT DM, assigned to the device group . A connected device . Perform EXECUTE # Let\u2019s perform an EXECUTE operation on the Factory Reset resource with ID 3/0/5 . Note From the Azure IoT integration standpoint, Factory Reset is interpreted as a Command . Read more about how LwM2M data model is mapped to Azure IoT Hub mechanisms in Concepts . In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Direct method . As Method name , type execute . In Payload , paste the following snippet and click Invoke method : { \"path\": \"3.0.5\" } Note The exact LwM2M path of the Factory reset resource depends on the LwM2M client used and may vary slightly, e.g. in the object instance number: 3/1/5 . For the purpose of this tutorial, the Anjay LwM2M Client is used. If needed, modify the snippet according to your case. See value changes in Azure IoT Hub # The result of the EXECUTE operation is displayed in the same Direct method tab. Scroll down to the Result field and check the HTTP code. The following result means that the device has executed the resource successfully: {\"status\":200,\"payload\":\"Executed `3.0.5` successfully\"}","title":"Perform LwM2M Execute"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Execute/#perform-lwm2m-execute","text":"This section describes how to perform a LwM2M EXECUTE operation in your Azure IoT Hub. An EXECUTE operation lets you perform operations on IoT devices such as a reboot or a firmware upgrade, only on individual resources. In this section, you learn how to: Perform a LwM2M EXECUTE operation on a resource","title":"Perform LwM2M Execute"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Execute/#prerequisites","text":"An active Azure IoT Hub with hub owner access permissions. A Coiote IoT DM user account with permissions to use the integration extension. A device group created in Coiote IoT DM. A configured extension between Coiote IoT DM and Azure Iot Hub . A configured integration template in Coiote IoT DM, assigned to the device group . A connected device .","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Execute/#perform-execute","text":"Let\u2019s perform an EXECUTE operation on the Factory Reset resource with ID 3/0/5 . Note From the Azure IoT integration standpoint, Factory Reset is interpreted as a Command . Read more about how LwM2M data model is mapped to Azure IoT Hub mechanisms in Concepts . In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Direct method . As Method name , type execute . In Payload , paste the following snippet and click Invoke method : { \"path\": \"3.0.5\" } Note The exact LwM2M path of the Factory reset resource depends on the LwM2M client used and may vary slightly, e.g. in the object instance number: 3/1/5 . For the purpose of this tutorial, the Anjay LwM2M Client is used. If needed, modify the snippet according to your case.","title":"Perform EXECUTE"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Execute/#see-value-changes-in-azure-iot-hub","text":"The result of the EXECUTE operation is displayed in the same Direct method tab. Scroll down to the Result field and check the HTTP code. The following result means that the device has executed the resource successfully: {\"status\":200,\"payload\":\"Executed `3.0.5` successfully\"}","title":"See value changes in Azure IoT Hub"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Read_Write/","text":"Perform LwM2M Read and Write # This section describes how to perform a LwM2M WRITE and READ operations in your Azure IoT Hub and Coiote IoT DM. A WRITE operation lets you change the current value on the given data model component: object, object instance, and resource. The READ enables you to see the updated value of an object, object instance, or resource. In this section, you learn how to: Perform WRITE on resources Check for the reported value changes in resources Perform READ on resources Prerequisites # An active Azure IoT Hub with hub owner access permissions. A Coiote IoT DM user account with permissions to use the integration extension. A device group created in Coiote IoT DM. A configured extension between Coiote IoT DM and Azure Iot Hub . A configured integration template in Coiote IoT DM, assigned to the device group . A connected device . Perform WRITE # Let\u2019s perform a WRITE operation on the Lifetime resource with ID 1/1/1 . From the Azure IoT integration standpoint, Lifetime it is interpreted as a Property . In Azure IoT Hub, value changes for both Telemetry and Property are stored in the Device twin . To perform a WRITE operation, do the following: In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Device twin . Find the desired property in the JSON snippet. This is where you define what needs to be observed. To the 1/1/1 (Lifetime) resource, add the following snippet under the \"desired\": { property and click Save : \"lwm2m\": { \"1\": { \"1\": { \"0\": {}, \"1\": { \"value\": 60 }, } }, }, Note The exact LwM2M path of the Lifetime resource depends on the LwM2M client used and may vary slightly, e.g. in the object instance number: 1/0/1 . For the purpose of this tutorial, the Anjay LwM2M Client is used. If needed, modify the snippet according to your case. After you click Save , the line with value: 60 will trigger the WRITE operation. See value changes # In Azure IoT Hub # The value change for the resource is displayed in the same Device Twin JSON snippet. Scroll down to the Reported property and find the value line for the 1/1/1 resource. \"reported\": { \"lwm2m\": { \"1\": { \"1\": { \"0\": {}, \"1\": { \"value\": 60 }, If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether the WRITE operation has been performed in Coiote IoT DM as well. In Coiote IoT DM # This step is optional. If you want to make sure the WRITE has been correctly performed in Coiote IoT DM, do the following: In Coiote IoT DM, go to your device and select the Data model tab. Expand the LwM2M Server object, find the Lifetime (1/1/1) resource in the list. If there is no change in data, use the Refresh icon in the top right corner of the screen. You have successfully performed a LwM2M WRITE on a resource. Perform READ # Let\u2019s perform a READ operation on the Temperature object's Sensor Value resource with ID 3303/0/5700 defined as a Property in the integration template in Coiote IoT DM . To learn more about reading value changes for both Telemetry and Property , refer to LwM2M mappings for Azure IoT Hub . To perform a READ operation, do the following: In Coiote IoT DM, go to your device and select the Data model tab. Expand the Temperature object, and find the Sensor Value (3303/0/5700) resource in the list. Click the Read resource icon located under the OPERATIONS column. The READ is scheduled - if there is any value change, it should be displayed in a few moments (depending on device settings, like the Lifetime resource). See value change in Azure IoT Hub # The value change for the resource is displayed in the Device Twin JSON snippet. Scroll down to the Reported property and find the value line for the 3303/0/5700 resource. \"reported\": { \"lwm2m\": { \"3303\": { \"0\": { \"5601\": {}, \"5602\": {}, \"5603\": {}, \"5604\": {}, \"5700\": { \"value\": 18 }, If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether the READ operation has been performed in Coiote IoT DM as well. Next steps # Air quality monitoring - tutorial","title":"Perform LwM2M Read and Write"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Read_Write/#perform-lwm2m-read-and-write","text":"This section describes how to perform a LwM2M WRITE and READ operations in your Azure IoT Hub and Coiote IoT DM. A WRITE operation lets you change the current value on the given data model component: object, object instance, and resource. The READ enables you to see the updated value of an object, object instance, or resource. In this section, you learn how to: Perform WRITE on resources Check for the reported value changes in resources Perform READ on resources","title":"Perform LwM2M Read and Write"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Read_Write/#prerequisites","text":"An active Azure IoT Hub with hub owner access permissions. A Coiote IoT DM user account with permissions to use the integration extension. A device group created in Coiote IoT DM. A configured extension between Coiote IoT DM and Azure Iot Hub . A configured integration template in Coiote IoT DM, assigned to the device group . A connected device .","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Read_Write/#perform-write","text":"Let\u2019s perform a WRITE operation on the Lifetime resource with ID 1/1/1 . From the Azure IoT integration standpoint, Lifetime it is interpreted as a Property . In Azure IoT Hub, value changes for both Telemetry and Property are stored in the Device twin . To perform a WRITE operation, do the following: In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Device twin . Find the desired property in the JSON snippet. This is where you define what needs to be observed. To the 1/1/1 (Lifetime) resource, add the following snippet under the \"desired\": { property and click Save : \"lwm2m\": { \"1\": { \"1\": { \"0\": {}, \"1\": { \"value\": 60 }, } }, }, Note The exact LwM2M path of the Lifetime resource depends on the LwM2M client used and may vary slightly, e.g. in the object instance number: 1/0/1 . For the purpose of this tutorial, the Anjay LwM2M Client is used. If needed, modify the snippet according to your case. After you click Save , the line with value: 60 will trigger the WRITE operation.","title":"Perform WRITE"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Read_Write/#see-value-changes","text":"","title":"See value changes"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Read_Write/#in-azure-iot-hub","text":"The value change for the resource is displayed in the same Device Twin JSON snippet. Scroll down to the Reported property and find the value line for the 1/1/1 resource. \"reported\": { \"lwm2m\": { \"1\": { \"1\": { \"0\": {}, \"1\": { \"value\": 60 }, If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether the WRITE operation has been performed in Coiote IoT DM as well.","title":"In Azure IoT Hub"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Read_Write/#in-coiote-iot-dm","text":"This step is optional. If you want to make sure the WRITE has been correctly performed in Coiote IoT DM, do the following: In Coiote IoT DM, go to your device and select the Data model tab. Expand the LwM2M Server object, find the Lifetime (1/1/1) resource in the list. If there is no change in data, use the Refresh icon in the top right corner of the screen. You have successfully performed a LwM2M WRITE on a resource.","title":"In Coiote IoT DM"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Read_Write/#perform-read","text":"Let\u2019s perform a READ operation on the Temperature object's Sensor Value resource with ID 3303/0/5700 defined as a Property in the integration template in Coiote IoT DM . To learn more about reading value changes for both Telemetry and Property , refer to LwM2M mappings for Azure IoT Hub . To perform a READ operation, do the following: In Coiote IoT DM, go to your device and select the Data model tab. Expand the Temperature object, and find the Sensor Value (3303/0/5700) resource in the list. Click the Read resource icon located under the OPERATIONS column. The READ is scheduled - if there is any value change, it should be displayed in a few moments (depending on device settings, like the Lifetime resource).","title":"Perform READ"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Read_Write/#see-value-change-in-azure-iot-hub","text":"The value change for the resource is displayed in the Device Twin JSON snippet. Scroll down to the Reported property and find the value line for the 3303/0/5700 resource. \"reported\": { \"lwm2m\": { \"3303\": { \"0\": { \"5601\": {}, \"5602\": {}, \"5603\": {}, \"5604\": {}, \"5700\": { \"value\": 18 }, If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether the READ operation has been performed in Coiote IoT DM as well.","title":"See value change in Azure IoT Hub"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Perform_Read_Write/#next-steps","text":"Air quality monitoring - tutorial","title":"Next steps"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Set_an_Observation/","text":"Set an Observation # This section describes how to set an Observation in your Azure IoT Hub. Setting an Observation lets your devices know what value changes and for what particular resources they need to notify you about. An Observation can be set for any or all the components of the data model : objects, objects instances, and resources. Whenever there is a change in values, a device will send a Notify message to Coiote IoT DM, which in turn will transfer it to Azure IoT Hub. In this section, you learn how to: Set an Observation on objects and resources Define Observation attributes See value changes for the observed objects and resources Prerequisites # An active Azure IoT Hub with hub owner access permissions. A Coiote IoT DM user account with permissions to use the integration extension. A device group created in Coiote IoT DM. A configured extension between Coiote IoT DM and Azure Iot Hub . A configured integration template in Coiote IoT DM, assigned to the device group . A connected device . Set an Observation and define its attributes # Let\u2019s set two Observations: one on the whole object with ID 1/1 (1 LwM2M Server, 1 Lifetime) and on the resource with ID 3/0/13 (3 Device, 13 Current time). Both of them are Properties. In Azure IoT Hub, value changes for both Telemetry and Property are stored in Device twin , because Observation is a Property in itself and it does not keep track of historical changes in values. To set an Observation, do the following: In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Device twin . Find the desired property in the JSON snippet. This is where you define what needs to be observed. To set an Observation on object 1/1 (Lifetime) and resource 3/0/13 (Current time) , add the following fragment under the \"desired\": { property: \"lwm2m\": { \"1\": { \"1\": { \"observed\": true, \"attributes\": { \"pmin\": 60 } } }, \"3\": { \"0\": { \"13\": { \"observed\": true, \"attributes\": { \"pmin\": 1 } } } } }, The line with \u201cobserved\u201d: true sets an Observation. The line with \u201cattributes\u201d specifies the conditions under which notifications will be sent: \u201cpmin\u201d: 1 means that notifications will be sent every second. Info pmin - the minimum time in seconds between two notifications. pmax - the maximum time in seconds between two notifications. The notification is sent even if the value didn't change. Read more about other attributes in our Brief description of OMA LwM2M . Click Save . See value changes # In Azure IoT Hub # The value changes for the observed object and resource are displayed in the same JSON snippet where you set an Observation. Scroll down to the Reported property and find the value line. \"13\": { \"value\": 1634653218000, \"attributes\": { \"pmin\": \"1\" }, \"observed\": true } Because we have specified in the Desired properties that the maximum time between two notifications for the Current time (3/0/13) resource is 1 second ( pmax: 1 ), the number next to value will be changing every 1 second. E.g., 163465321 8 000 will become 163465321 9 000. If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether observation has been set in Coiote IoT DM as well. In Coiote IoT DM # This step is optional. If you want to make sure the Observation has been correctly set in Coiote IoT DM, do the following: In Coiote IoT DM, go to Device inventory --> Objects . For the Observation set on the whole object (1/1) , click the vertical Ellipse button next the search field and then click Refresh . If the Observation has been set correctly, the checkboxes will be filled in green. For the Observation set on the specific resource (3/0/13) , find this resource in the list and click the Refresh button to the left from the Value tracking. You will see that checkboxes next to Value tracking and Attributes are now filled in green. Click Value tracking . You will see pmin set to 1, which is the same as you defined in the JSON in Azure IoT Hub. You have successfully set an Observation on LwM2M object and resource. To add another Observation, add the lines in the same JSON snippet, as described in Step 4 . Delete an Observation # To stop observing an object or resource, do the following: In Azure IoT Hub, click on the device and then go to Device twin . In the JSON snippet, change \"observed\" from true to false . In Coiote IoT DM, you can now go to Device inventory --> Objects and see how Value tracking and Attributes boxes are now unchecked. Next steps # Air quality monitoring - tutorial","title":"Set an Observation"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Set_an_Observation/#set-an-observation","text":"This section describes how to set an Observation in your Azure IoT Hub. Setting an Observation lets your devices know what value changes and for what particular resources they need to notify you about. An Observation can be set for any or all the components of the data model : objects, objects instances, and resources. Whenever there is a change in values, a device will send a Notify message to Coiote IoT DM, which in turn will transfer it to Azure IoT Hub. In this section, you learn how to: Set an Observation on objects and resources Define Observation attributes See value changes for the observed objects and resources","title":"Set an Observation"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Set_an_Observation/#prerequisites","text":"An active Azure IoT Hub with hub owner access permissions. A Coiote IoT DM user account with permissions to use the integration extension. A device group created in Coiote IoT DM. A configured extension between Coiote IoT DM and Azure Iot Hub . A configured integration template in Coiote IoT DM, assigned to the device group . A connected device .","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Set_an_Observation/#set-an-observation-and-define-its-attributes","text":"Let\u2019s set two Observations: one on the whole object with ID 1/1 (1 LwM2M Server, 1 Lifetime) and on the resource with ID 3/0/13 (3 Device, 13 Current time). Both of them are Properties. In Azure IoT Hub, value changes for both Telemetry and Property are stored in Device twin , because Observation is a Property in itself and it does not keep track of historical changes in values. To set an Observation, do the following: In your Azure IoT Hub account, go to Devices from the left pane. Click on the device and then go to Device twin . Find the desired property in the JSON snippet. This is where you define what needs to be observed. To set an Observation on object 1/1 (Lifetime) and resource 3/0/13 (Current time) , add the following fragment under the \"desired\": { property: \"lwm2m\": { \"1\": { \"1\": { \"observed\": true, \"attributes\": { \"pmin\": 60 } } }, \"3\": { \"0\": { \"13\": { \"observed\": true, \"attributes\": { \"pmin\": 1 } } } } }, The line with \u201cobserved\u201d: true sets an Observation. The line with \u201cattributes\u201d specifies the conditions under which notifications will be sent: \u201cpmin\u201d: 1 means that notifications will be sent every second. Info pmin - the minimum time in seconds between two notifications. pmax - the maximum time in seconds between two notifications. The notification is sent even if the value didn't change. Read more about other attributes in our Brief description of OMA LwM2M . Click Save .","title":"Set an Observation and define its attributes"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Set_an_Observation/#see-value-changes","text":"","title":"See value changes"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Set_an_Observation/#in-azure-iot-hub","text":"The value changes for the observed object and resource are displayed in the same JSON snippet where you set an Observation. Scroll down to the Reported property and find the value line. \"13\": { \"value\": 1634653218000, \"attributes\": { \"pmin\": \"1\" }, \"observed\": true } Because we have specified in the Desired properties that the maximum time between two notifications for the Current time (3/0/13) resource is 1 second ( pmax: 1 ), the number next to value will be changing every 1 second. E.g., 163465321 8 000 will become 163465321 9 000. If you don\u2019t see any changes, click Refresh . If it doesn\u2019t help, you can check whether observation has been set in Coiote IoT DM as well.","title":"In Azure IoT Hub"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Set_an_Observation/#in-coiote-iot-dm","text":"This step is optional. If you want to make sure the Observation has been correctly set in Coiote IoT DM, do the following: In Coiote IoT DM, go to Device inventory --> Objects . For the Observation set on the whole object (1/1) , click the vertical Ellipse button next the search field and then click Refresh . If the Observation has been set correctly, the checkboxes will be filled in green. For the Observation set on the specific resource (3/0/13) , find this resource in the list and click the Refresh button to the left from the Value tracking. You will see that checkboxes next to Value tracking and Attributes are now filled in green. Click Value tracking . You will see pmin set to 1, which is the same as you defined in the JSON in Azure IoT Hub. You have successfully set an Observation on LwM2M object and resource. To add another Observation, add the lines in the same JSON snippet, as described in Step 4 .","title":"In Coiote IoT DM"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Set_an_Observation/#delete-an-observation","text":"To stop observing an object or resource, do the following: In Azure IoT Hub, click on the device and then go to Device twin . In the JSON snippet, change \"observed\" from true to false . In Coiote IoT DM, you can now go to Device inventory --> Objects and see how Value tracking and Attributes boxes are now unchecked.","title":"Delete an Observation"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Set_an_Observation/#next-steps","text":"Air quality monitoring - tutorial","title":"Next steps"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Upgrading_firmware/","text":"Upgrade device firmware # If you would like to upgrade the firmware of devices using the Azure IoT Hub, follow the instruction below. Prerequisites # At least one synchronized Coiote IoT DM - Azure IoT Hub device. A firmware file hosted on an HTTP server that is reachable by the Coiote IoT DM server. Note In this stage of integration, no authentication method is supported for this endpoint - it is required that the firmware is publicly available (or hosted in a private network but with access granted for the Coiote IoT DM server). Scheduling a firmware upgrade # Introduction # The process of upgrading device firmware for Azure IoT Hub devices synchronized with Coiote IoT DM is based on two main elements: the Azure Direct Method mechanism and the Coiote IoT DM Firmware Upgrade task. In the process, the Azure scheduleFirmwareUpdate direct method is invoked, enabling the Coiote IoT DM to download the specified firmware file and add it to its resources. Then, an XML task is scheduled in Coiote IoT DM and the upgrade is performed on the device. Info For firmware file recognition in Coiote IoT DM, global identifiers are used. This means that it is recommended to name your firmware files using the format: yourdomainName + randomized value. If the same firmware file name is used again, then Coiote IoT DM will be able to utilize the once downloaded resource without the need to download it again. Step 1: Invoking the Azure scheduleFirmwareUpdate direct method # To initiate the firmware upgrade procedure for your device: Go to your Azure hub account and under Explorers , select IoT devices . From the list, choose the device for which you want to upgrade the firmware. In the device view, select the Direct Method tab. Provide data for the following fields: Method Name - paste the scheduleFirmwareUpdate direct method name here. Payload - use the following payload with firmware upgrade parameters (remember to replace the example values where needed): { \"name\": \"anjay-firmware\", \"firmwareUrl\": \"https://example.repository.com/artifactory/gitlfs/demo.fw-pkg\", // optional - default=\"1200s\", any valid duration in format \"<length><unit>\" \"timeout\": \"1200s\", // optional - default=\"COAP\" \"protocolType\": \"COAP\", // optional - default=null <-> keep firmware file forever, any valid duration in format \"<length><unit>\" or null \"retentionPeriod\": \"300s\", // optional - default=\"\" \"description\": \"This is anjay demo firmware\", // optional - default=false \"useQuota\": false, // optional - default=false \"useCachedData\": false, // optional - default=false \"resumeAfterDownlinkFailure\": false, // optional - default=\"Pull\", possible values = [\"Pull\", \"Push\"] \"imageDeliveryMethod\": \"Pull\", // optional - default=\"WithoutObservations\", possible values = [\"ObservationTrigger\", \"WithoutObservations\", \"ObservationBased\", \"SendBased\"] \"upgradeStrategy\": \"WithoutObservations\", // optional - default=\"always\", possible values = [\"always\", \"weekends\", \"nights-home\", \"nights-enterprise-weekends\", \"nights-enterprise\", user-defined schedules] \"schedule\": \"always\" } Connection timeout - specify a timeout for the Azure - Coiote IoT DM connection (the recommended value is not less than 5 seconds). Method timeout - specify a timeout for direct method result notification. Once you have provided the required data, click Invoke method . After a short moment, you should be able to see the direct method result in the Result field. The 200 as the \"status\" parameter value means that the firmware upgrade task was completed successfully. Importantly, the result \"payload\" value will be needed for other FOTA actions like status check or cancellation, so be sure to copy it to your clipboard if needed. Tip Out of all the parameters provided in Firmware upgrade direct method payload, only two are mandatory: name - the unique file name used for firmware identification. firmwareUrl - the URL used by Coiote IoT DM to download the firmware file and include it as a resource. Therefore it is correct to include only those two in the payload, as in here: { \"name\": \"anjay-firmware\", \"firmwareUrl\": \"https://example.repository.com/artifactory/gitlfs/demo.fw-pkg\", } Step 2: Checking the firmware upgrade result # To check the status of a scheduled firmware upgrade, follow these steps: In the Direct Method tab of your device, provide data for the following fields: Method Name - paste the checkFirmwareUpdateStatus direct method name here. Payload - use the payload displayed in the Firmware upgrade result field (remember to replace the placeholder value with your copied value): { \"fotaId\": \"fotaIdReturnedByScheduleOperation\" } Click Invoke method . Check the direct method status in the Result field: Step 3: Checking Coiote IoT DM FOTA task execution # Once you have executed the Azure-side steps of the procedure, you can check its status from the side of Coiote IoT DM. Go to your Coiote IoT DM account and in the Device Inventory , select your device. In the Device Management Center, enter the LwM2M firmware tab. Check the status of the FOTA task execution for your device: In the Current firmware section, check if the device firmware is updated to the newest version. In the Installation history section, check if the lwm2mFirmwareUpdate task invoked earlier by the Azure scheduleFirmwareUpdate direct method has been completed with success. Cancelling the firmware upgrade procedure # To cancel the firmware upgrade procedure, follow these steps: In the Direct Method tab of your device, provide data for the following fields: Method Name - paste the cancelFirmwareUpdate direct method name here. Payload - use the payload displayed in the Firmware upgrade result field (remember to replace the placeholder value with your copied value): { \"fotaId\": \"fotaIdReturnedByScheduleOperation\" } Click Invoke method . Check the direct method status in the Result field: See also # See the relevant section of LwM2M mappings to learn the details of how Azure IoT Hub Direct Methods are mapped in Coiote IoT DM.","title":"Upgrade device firmware"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Upgrading_firmware/#upgrade-device-firmware","text":"If you would like to upgrade the firmware of devices using the Azure IoT Hub, follow the instruction below.","title":"Upgrade device firmware"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Upgrading_firmware/#prerequisites","text":"At least one synchronized Coiote IoT DM - Azure IoT Hub device. A firmware file hosted on an HTTP server that is reachable by the Coiote IoT DM server. Note In this stage of integration, no authentication method is supported for this endpoint - it is required that the firmware is publicly available (or hosted in a private network but with access granted for the Coiote IoT DM server).","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Upgrading_firmware/#scheduling-a-firmware-upgrade","text":"","title":"Scheduling a firmware upgrade"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Upgrading_firmware/#introduction","text":"The process of upgrading device firmware for Azure IoT Hub devices synchronized with Coiote IoT DM is based on two main elements: the Azure Direct Method mechanism and the Coiote IoT DM Firmware Upgrade task. In the process, the Azure scheduleFirmwareUpdate direct method is invoked, enabling the Coiote IoT DM to download the specified firmware file and add it to its resources. Then, an XML task is scheduled in Coiote IoT DM and the upgrade is performed on the device. Info For firmware file recognition in Coiote IoT DM, global identifiers are used. This means that it is recommended to name your firmware files using the format: yourdomainName + randomized value. If the same firmware file name is used again, then Coiote IoT DM will be able to utilize the once downloaded resource without the need to download it again.","title":"Introduction"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Upgrading_firmware/#step-1-invoking-the-azure-schedulefirmwareupdate-direct-method","text":"To initiate the firmware upgrade procedure for your device: Go to your Azure hub account and under Explorers , select IoT devices . From the list, choose the device for which you want to upgrade the firmware. In the device view, select the Direct Method tab. Provide data for the following fields: Method Name - paste the scheduleFirmwareUpdate direct method name here. Payload - use the following payload with firmware upgrade parameters (remember to replace the example values where needed): { \"name\": \"anjay-firmware\", \"firmwareUrl\": \"https://example.repository.com/artifactory/gitlfs/demo.fw-pkg\", // optional - default=\"1200s\", any valid duration in format \"<length><unit>\" \"timeout\": \"1200s\", // optional - default=\"COAP\" \"protocolType\": \"COAP\", // optional - default=null <-> keep firmware file forever, any valid duration in format \"<length><unit>\" or null \"retentionPeriod\": \"300s\", // optional - default=\"\" \"description\": \"This is anjay demo firmware\", // optional - default=false \"useQuota\": false, // optional - default=false \"useCachedData\": false, // optional - default=false \"resumeAfterDownlinkFailure\": false, // optional - default=\"Pull\", possible values = [\"Pull\", \"Push\"] \"imageDeliveryMethod\": \"Pull\", // optional - default=\"WithoutObservations\", possible values = [\"ObservationTrigger\", \"WithoutObservations\", \"ObservationBased\", \"SendBased\"] \"upgradeStrategy\": \"WithoutObservations\", // optional - default=\"always\", possible values = [\"always\", \"weekends\", \"nights-home\", \"nights-enterprise-weekends\", \"nights-enterprise\", user-defined schedules] \"schedule\": \"always\" } Connection timeout - specify a timeout for the Azure - Coiote IoT DM connection (the recommended value is not less than 5 seconds). Method timeout - specify a timeout for direct method result notification. Once you have provided the required data, click Invoke method . After a short moment, you should be able to see the direct method result in the Result field. The 200 as the \"status\" parameter value means that the firmware upgrade task was completed successfully. Importantly, the result \"payload\" value will be needed for other FOTA actions like status check or cancellation, so be sure to copy it to your clipboard if needed. Tip Out of all the parameters provided in Firmware upgrade direct method payload, only two are mandatory: name - the unique file name used for firmware identification. firmwareUrl - the URL used by Coiote IoT DM to download the firmware file and include it as a resource. Therefore it is correct to include only those two in the payload, as in here: { \"name\": \"anjay-firmware\", \"firmwareUrl\": \"https://example.repository.com/artifactory/gitlfs/demo.fw-pkg\", }","title":"Step 1: Invoking the Azure scheduleFirmwareUpdate direct method"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Upgrading_firmware/#step-2-checking-the-firmware-upgrade-result","text":"To check the status of a scheduled firmware upgrade, follow these steps: In the Direct Method tab of your device, provide data for the following fields: Method Name - paste the checkFirmwareUpdateStatus direct method name here. Payload - use the payload displayed in the Firmware upgrade result field (remember to replace the placeholder value with your copied value): { \"fotaId\": \"fotaIdReturnedByScheduleOperation\" } Click Invoke method . Check the direct method status in the Result field:","title":"Step 2: Checking the firmware upgrade result"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Upgrading_firmware/#step-3-checking-coiote-iot-dm-fota-task-execution","text":"Once you have executed the Azure-side steps of the procedure, you can check its status from the side of Coiote IoT DM. Go to your Coiote IoT DM account and in the Device Inventory , select your device. In the Device Management Center, enter the LwM2M firmware tab. Check the status of the FOTA task execution for your device: In the Current firmware section, check if the device firmware is updated to the newest version. In the Installation history section, check if the lwm2mFirmwareUpdate task invoked earlier by the Azure scheduleFirmwareUpdate direct method has been completed with success.","title":"Step 3: Checking Coiote IoT DM FOTA task execution"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Upgrading_firmware/#cancelling-the-firmware-upgrade-procedure","text":"To cancel the firmware upgrade procedure, follow these steps: In the Direct Method tab of your device, provide data for the following fields: Method Name - paste the cancelFirmwareUpdate direct method name here. Payload - use the payload displayed in the Firmware upgrade result field (remember to replace the placeholder value with your copied value): { \"fotaId\": \"fotaIdReturnedByScheduleOperation\" } Click Invoke method . Check the direct method status in the Result field:","title":"Cancelling the firmware upgrade procedure"},{"location":"Coiote_IoT_DM/Cloud_integrations/Azure_IoT_Hub/Upgrading_firmware/#see-also","text":"See the relevant section of LwM2M mappings to learn the details of how Azure IoT Hub Direct Methods are mapped in Coiote IoT DM.","title":"See also"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/atlas/","text":"Atlas # This tutorial explains how to use Data Integration Center to send data to MongoDB Atlas using its API. Prerequisites # MongoDB Atlas Account MongoDB Atlas cluster Setup atlas # Enable Data API access. In the User tab, create a user and copy the API key. Copy URL Endpoint . Info To learn more details on MongoDB Atlas, see Introduction to the MongoDB Atlas Data API . Create webhook # From the previous section, get the API url and append action/insertOne to it. Example: https://europe-west1.gcp.data.mongodb-api.com/app/data-kjqsw/endpoint/data/v1/action/insertOne As headers, set: api-key: <api-key-from-previous-section> Access-Control-Request-Headers: * As a body template, set e.g: { \"collection\" : \"devices\" , \"database\" : \"coiote\" , \"dataSource\" : \"coiote\" , \"document\" : { \"endpointName\" : \"$endpointName\" } } You can adjust the payload according to your needs. Investigate database # Now, go to Collections and verify if there is a new entity.","title":"Atlas"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/atlas/#atlas","text":"This tutorial explains how to use Data Integration Center to send data to MongoDB Atlas using its API.","title":"Atlas"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/atlas/#prerequisites","text":"MongoDB Atlas Account MongoDB Atlas cluster","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/atlas/#setup-atlas","text":"Enable Data API access. In the User tab, create a user and copy the API key. Copy URL Endpoint . Info To learn more details on MongoDB Atlas, see Introduction to the MongoDB Atlas Data API .","title":"Setup atlas"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/atlas/#create-webhook","text":"From the previous section, get the API url and append action/insertOne to it. Example: https://europe-west1.gcp.data.mongodb-api.com/app/data-kjqsw/endpoint/data/v1/action/insertOne As headers, set: api-key: <api-key-from-previous-section> Access-Control-Request-Headers: * As a body template, set e.g: { \"collection\" : \"devices\" , \"database\" : \"coiote\" , \"dataSource\" : \"coiote\" , \"document\" : { \"endpointName\" : \"$endpointName\" } } You can adjust the payload according to your needs.","title":"Create webhook"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/atlas/#investigate-database","text":"Now, go to Collections and verify if there is a new entity.","title":"Investigate database"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/datacake/","text":"Datacake # This tutorial explains how to integrate with Datacake using webhooks and a custom payload decoder. See the Datacake docs covering this type of integrations. Prerequisites # A user with access to the Coiote IoT Device Management platform and appropriate permissions A LwM2M device A Datacake account (you can create a free Datacake account ) Setup Datacake # Open your Datacake account. Create a new workspace or select an existing one. Create a new API Device representing your device by going to: Devices > Add device . Select or create a Product that will be used as a template for your device. Products aggregate devices sharing similar configurations, you will later use an endpoint dedicated to your Product to ingest data for your device. Create a dedicated product for the demo device to use in this tutorial. Name your device and enter its endpoint name as the device serial number. Pick a plan for billing your integration and complete the process. You can add up to 5 devices in the free plan of your workspace. Configure fields for your device # From the devices list, select the device and open its details by clicking on its name. To configure the data model of your device, in the Configuration tab, find the Fields of the device and add new field representing the temperature measured by your device. You can add fields of different types as Datacake field types cover all LwM2M resource types. For the temperature measurements, pick the Float type and name it TEMPERATURE . Configure payload decoder # Follow to the HTTP Payload Decoder section to configure the decoder for JSON values that will arrive from Coiote IoT DM. To parse the incoming Webhook data from Coiote IoT DM, you will need a decoder similar to the following one: function Decoder ( request ) { // Parse JSON into Object var payload = JSON . parse ( request . body ); var endpointName = payload . endpointName ; var temperatureUrl = \"/3303/0/5700\" ; if ( payload . url == temperatureUrl ) { var temperature = parseFloat ( payload . value ); var time = payload . timestamp ; return [{ device : endpointName , field : \"TEMPERATURE\" , value : temperature , timestamp : time / 1000 }]; } else { return []; } } This decoder does several things required to ingest device data into the Datacake database: it selects the endpointName field used for identification of the device in the platform, it accepts only changes from LwM2M URL /3303/0/5700 which represents the Temperature/Sensor value resource, it parses the value and timestamp from the payload of the event. Save the configuration and copy the HTTP Endpoint URL , which will be used as webhook target for Coiote IoT DM event handler. Create webhook in Coiote IoT Device Management platform # Go back to your domain in Coiote IoT Device Management platform. Go to Integrations > Data Integration Center and create a Webhook event handler that will forward device telemetry. Configure Datacake webhook parameters # Apply the filter and go to the connection configuration step to configure the fields as follows: set the formatting to Generic , set the URL to the HTTP Endpoint URL you copied before from the Datacake configuration view. It should look like this: https://api.datacake.co/integrations/api/aaaaaaaa-bbbb-cccc-dddd-eeeeffffggg/ , set the Authorization to No authorization , as Datacake treats the endpoint URL as a token itself. To confirm that you entered your data correctly, test the event handler. To create the event handler, click Next step and Add event handler . Monitor events in Datacake # After activating the event handler, go to your Datacake account and open the Dashboard of your device. If you have already set an observation on the Temperature object , you should see that the Last update field of your device in Datacake changed to the time when Datacake received last information from Coiote IoT DM. Let's set up a Datacake dashboard to display the received Temperature data. Create widget in Datacake # Enter the edit mode by clicking the toggle on the right side of the dashboard. Click Add Widget and pick Chart type. In the configuration view, go to Data tab and select the previously created TEMPERATURE field as the source of data for your chart. To see better the incoming data, go to Timeframe tab and select Custom . Change the Resolution to 1 minute . Save the chart and resize it on the dashboard according to your taste. You can read more about Datacake's device dashboards in their docs .","title":"Datacake"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/datacake/#datacake","text":"This tutorial explains how to integrate with Datacake using webhooks and a custom payload decoder. See the Datacake docs covering this type of integrations.","title":"Datacake"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/datacake/#prerequisites","text":"A user with access to the Coiote IoT Device Management platform and appropriate permissions A LwM2M device A Datacake account (you can create a free Datacake account )","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/datacake/#setup-datacake","text":"Open your Datacake account. Create a new workspace or select an existing one. Create a new API Device representing your device by going to: Devices > Add device . Select or create a Product that will be used as a template for your device. Products aggregate devices sharing similar configurations, you will later use an endpoint dedicated to your Product to ingest data for your device. Create a dedicated product for the demo device to use in this tutorial. Name your device and enter its endpoint name as the device serial number. Pick a plan for billing your integration and complete the process. You can add up to 5 devices in the free plan of your workspace.","title":"Setup Datacake"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/datacake/#configure-fields-for-your-device","text":"From the devices list, select the device and open its details by clicking on its name. To configure the data model of your device, in the Configuration tab, find the Fields of the device and add new field representing the temperature measured by your device. You can add fields of different types as Datacake field types cover all LwM2M resource types. For the temperature measurements, pick the Float type and name it TEMPERATURE .","title":"Configure fields for your device"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/datacake/#configure-payload-decoder","text":"Follow to the HTTP Payload Decoder section to configure the decoder for JSON values that will arrive from Coiote IoT DM. To parse the incoming Webhook data from Coiote IoT DM, you will need a decoder similar to the following one: function Decoder ( request ) { // Parse JSON into Object var payload = JSON . parse ( request . body ); var endpointName = payload . endpointName ; var temperatureUrl = \"/3303/0/5700\" ; if ( payload . url == temperatureUrl ) { var temperature = parseFloat ( payload . value ); var time = payload . timestamp ; return [{ device : endpointName , field : \"TEMPERATURE\" , value : temperature , timestamp : time / 1000 }]; } else { return []; } } This decoder does several things required to ingest device data into the Datacake database: it selects the endpointName field used for identification of the device in the platform, it accepts only changes from LwM2M URL /3303/0/5700 which represents the Temperature/Sensor value resource, it parses the value and timestamp from the payload of the event. Save the configuration and copy the HTTP Endpoint URL , which will be used as webhook target for Coiote IoT DM event handler.","title":"Configure payload decoder"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/datacake/#create-webhook-in-coiote-iot-device-management-platform","text":"Go back to your domain in Coiote IoT Device Management platform. Go to Integrations > Data Integration Center and create a Webhook event handler that will forward device telemetry.","title":"Create webhook in Coiote IoT Device Management platform"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/datacake/#configure-datacake-webhook-parameters","text":"Apply the filter and go to the connection configuration step to configure the fields as follows: set the formatting to Generic , set the URL to the HTTP Endpoint URL you copied before from the Datacake configuration view. It should look like this: https://api.datacake.co/integrations/api/aaaaaaaa-bbbb-cccc-dddd-eeeeffffggg/ , set the Authorization to No authorization , as Datacake treats the endpoint URL as a token itself. To confirm that you entered your data correctly, test the event handler. To create the event handler, click Next step and Add event handler .","title":"Configure Datacake webhook parameters"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/datacake/#monitor-events-in-datacake","text":"After activating the event handler, go to your Datacake account and open the Dashboard of your device. If you have already set an observation on the Temperature object , you should see that the Last update field of your device in Datacake changed to the time when Datacake received last information from Coiote IoT DM. Let's set up a Datacake dashboard to display the received Temperature data.","title":"Monitor events in Datacake"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/datacake/#create-widget-in-datacake","text":"Enter the edit mode by clicking the toggle on the right side of the dashboard. Click Add Widget and pick Chart type. In the configuration view, go to Data tab and select the previously created TEMPERATURE field as the source of data for your chart. To see better the incoming data, go to Timeframe tab and select Custom . Change the Resolution to 1 minute . Save the chart and resize it on the dashboard according to your taste. You can read more about Datacake's device dashboards in their docs .","title":"Create widget in Datacake"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/graphql/","text":"GraphQL # GraphQL is a query language for APIs that enables clients to request only the data they need. This tutorial explains how to use Data Integration Center to send e.g. a mutation to a GraphQL server. Prerequisites # Basic knowledge of GraphQL Working GraphQL server e.g. Apollo Server GraphQL client e.g. Sandbox Create webhook # First of all, adjust body template to send query with mutation. Mutation must be compatible with your schema, so for: type Mutation { devices(endpointName: String, domainId: String): Device } it would be { \"query\" : \"mutation AddDevice { devices(endpointName: \\\"$endpointName\\\", domainId: \\\"$domainId\\\") { endpointName domainId } }\" } Set the host URL to point to your server. Info For detailed instructions on how to create webhooks, see the Webhook and Overview chapters. Query the GraphQL server # Now, check if the new device has been added.","title":"GraphQL"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/graphql/#graphql","text":"GraphQL is a query language for APIs that enables clients to request only the data they need. This tutorial explains how to use Data Integration Center to send e.g. a mutation to a GraphQL server.","title":"GraphQL"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/graphql/#prerequisites","text":"Basic knowledge of GraphQL Working GraphQL server e.g. Apollo Server GraphQL client e.g. Sandbox","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/graphql/#create-webhook","text":"First of all, adjust body template to send query with mutation. Mutation must be compatible with your schema, so for: type Mutation { devices(endpointName: String, domainId: String): Device } it would be { \"query\" : \"mutation AddDevice { devices(endpointName: \\\"$endpointName\\\", domainId: \\\"$domainId\\\") { endpointName domainId } }\" } Set the host URL to point to your server. Info For detailed instructions on how to create webhooks, see the Webhook and Overview chapters.","title":"Create webhook"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/graphql/#query-the-graphql-server","text":"Now, check if the new device has been added.","title":"Query the GraphQL server"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/influx/","text":"InfluxDB # This tutorial explains how to simplify the integration with InfluxDB using webhooks formatted to align with Influx\u2019s data API requirements. Prerequisites # A user with access to the Coiote IoT Device Management platform and appropriate permissions A LwM2M device An InfluxDB account (you can create a free InfluxDB Cloud account ) Setup InfluxDB # Open your InfluxDB account. Create a new Bucket for storing the time series data by going to: \u2191 > Buckets . Name the Bucket. Copy the Bucket ID and save it to use later. Create API Token # Go to the API Tokens tab. Create a new API token Create a custom API Token Preferably, create a custom API Token which has only access to the specific Bucket you just created. Make sure to select Read and Write rights. Copy the API Token and save it for later. Create webhook in Coiote IoT DM # In your Coiote IoT DM, select: Integrations > Data Integration Center. Click Add event handler and select Webhook . Provide Basic information such as the name and description. Also, you can activate the event handler after creation. Select the events which will trigger the HTTP(S) requests. Configure parameters # Select the Influx data formatting option. Set the URL address. The URL address is composed of the following parts: The Influx URL e.g.: https://eu-central-1-1.aws.cloud2.influxdata.com . You can find the URL in the address bar of your browser when using InfluxDB Cloud. The InfluxDB API : /api/v2/write The precision parameter indicating our data is ingested with millisecond precision: ?precision=ms The Bucket ID , starting with &bucket= When combined, the URL address looks as follows: https://eu-central-1-1.aws.cloud2.influxdata.com/api/v2/write?precision=ms&bucket=bc123456789ABCDE Info For more information about the Influx API, visit Influx's API documentation . Add the API token which you previously created in your InfluxDB account. To create the event handler, click Next step and Add event handler . Tip You can use the Test event handler option to validate the configuration of the HTTP request before creating the event handler. When performing such test, an event should arrive in your Influx bucket. Configure body template # Influx uses custom protocol named line protocol . It consists of four components: measurement name, tags, fields and timestamp. You can adjust each one according to your needs by editing the body template. <measurement>[,<tag_key>=<tag_value>] <field_key>=<field_value> [<timestamp>] You should first define the body template When influx creates a measurement table, columns types are defined and all requests that don't match the type are rejected. It implies that any further changes are impossible and you will need to setup a proper body template before sending data. Telemetry with string type resources For influx to work with string value resources, you should add extra quotes around $value . This will cause all value resources to be of string type. Therefore to create e.g. diagrams, you need casting . telemetryEvent,domain=$domainId,endpointName=$endpointName,eventType=\"telemetry\" $url=\"$value\" $timestamp Monitor events in InfluxDB # After activating the event handler, in your InfluxDB account, open your Bucket. Add the following query: Telemetry events SELECT * FROM \"telemetryEvent\" WHERE time >= now() - interval '1 hour' Device events SELECT * FROM \"deviceEvent\" WHERE time >= now() - interval '1 hour' To run the script, press: RUN . If the integration is set up correctly, the device events are visible in the table.","title":"InfluxDB"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/influx/#influxdb","text":"This tutorial explains how to simplify the integration with InfluxDB using webhooks formatted to align with Influx\u2019s data API requirements.","title":"InfluxDB"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/influx/#prerequisites","text":"A user with access to the Coiote IoT Device Management platform and appropriate permissions A LwM2M device An InfluxDB account (you can create a free InfluxDB Cloud account )","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/influx/#setup-influxdb","text":"Open your InfluxDB account. Create a new Bucket for storing the time series data by going to: \u2191 > Buckets . Name the Bucket. Copy the Bucket ID and save it to use later.","title":"Setup InfluxDB"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/influx/#create-api-token","text":"Go to the API Tokens tab. Create a new API token Create a custom API Token Preferably, create a custom API Token which has only access to the specific Bucket you just created. Make sure to select Read and Write rights. Copy the API Token and save it for later.","title":"Create API Token"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/influx/#create-webhook-in-coiote-iot-dm","text":"In your Coiote IoT DM, select: Integrations > Data Integration Center. Click Add event handler and select Webhook . Provide Basic information such as the name and description. Also, you can activate the event handler after creation. Select the events which will trigger the HTTP(S) requests.","title":"Create webhook in Coiote IoT DM"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/influx/#configure-parameters","text":"Select the Influx data formatting option. Set the URL address. The URL address is composed of the following parts: The Influx URL e.g.: https://eu-central-1-1.aws.cloud2.influxdata.com . You can find the URL in the address bar of your browser when using InfluxDB Cloud. The InfluxDB API : /api/v2/write The precision parameter indicating our data is ingested with millisecond precision: ?precision=ms The Bucket ID , starting with &bucket= When combined, the URL address looks as follows: https://eu-central-1-1.aws.cloud2.influxdata.com/api/v2/write?precision=ms&bucket=bc123456789ABCDE Info For more information about the Influx API, visit Influx's API documentation . Add the API token which you previously created in your InfluxDB account. To create the event handler, click Next step and Add event handler . Tip You can use the Test event handler option to validate the configuration of the HTTP request before creating the event handler. When performing such test, an event should arrive in your Influx bucket.","title":"Configure parameters"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/influx/#configure-body-template","text":"Influx uses custom protocol named line protocol . It consists of four components: measurement name, tags, fields and timestamp. You can adjust each one according to your needs by editing the body template. <measurement>[,<tag_key>=<tag_value>] <field_key>=<field_value> [<timestamp>] You should first define the body template When influx creates a measurement table, columns types are defined and all requests that don't match the type are rejected. It implies that any further changes are impossible and you will need to setup a proper body template before sending data. Telemetry with string type resources For influx to work with string value resources, you should add extra quotes around $value . This will cause all value resources to be of string type. Therefore to create e.g. diagrams, you need casting . telemetryEvent,domain=$domainId,endpointName=$endpointName,eventType=\"telemetry\" $url=\"$value\" $timestamp","title":"Configure body template"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/influx/#monitor-events-in-influxdb","text":"After activating the event handler, in your InfluxDB account, open your Bucket. Add the following query: Telemetry events SELECT * FROM \"telemetryEvent\" WHERE time >= now() - interval '1 hour' Device events SELECT * FROM \"deviceEvent\" WHERE time >= now() - interval '1 hour' To run the script, press: RUN . If the integration is set up correctly, the device events are visible in the table.","title":"Monitor events in InfluxDB"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/slack/","text":"Slack # This tutorial explains how to use Data Integration Center to send messages to a Slack channel using the Slack API. Prerequisites # Slack account with appropriate permissions Chosen Slack channel Setup Slack # To send messages to Slack: Install Incoming Webhooks . Configure it by choosing a channel e.g coiote-integration . Copy Webhook URL. Create webhook # From the previous step, paste Webhook URL as url. Set the Authorization to No authorization , as Slack treats the URL as a token itself. As body template, set e.g: { \"text\" : \"Created new device: $endpointName\" } You can adjust the webhook according to your needs. Info For detailed instructions on how to create webhooks, see the Webhook and Overview chapters. Follow chat # To verify if our webhook works, go to the coiote-integration channel.","title":"Slack"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/slack/#slack","text":"This tutorial explains how to use Data Integration Center to send messages to a Slack channel using the Slack API.","title":"Slack"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/slack/#prerequisites","text":"Slack account with appropriate permissions Chosen Slack channel","title":"Prerequisites"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/slack/#setup-slack","text":"To send messages to Slack: Install Incoming Webhooks . Configure it by choosing a channel e.g coiote-integration . Copy Webhook URL.","title":"Setup Slack"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/slack/#create-webhook","text":"From the previous step, paste Webhook URL as url. Set the Authorization to No authorization , as Slack treats the URL as a token itself. As body template, set e.g: { \"text\" : \"Created new device: $endpointName\" } You can adjust the webhook according to your needs. Info For detailed instructions on how to create webhooks, see the Webhook and Overview chapters.","title":"Create webhook"},{"location":"Coiote_IoT_DM/Cloud_integrations/Device_Integration_Center/slack/#follow-chat","text":"To verify if our webhook works, go to the coiote-integration channel.","title":"Follow chat"},{"location":"Coiote_IoT_DM/Coiote_videos/How_to_perform_secure_Over-the-Air_updates/","text":"How to perform secure Over-the-Air (OTA) updates? (nRF9160 DK) # The LwM2M standard makes Over-the-Air (OTA) updates straightforward, reducing the complexity of implementation and management. What's crucial is that it enhances security through authentication and encryption. To demonstrate the potential of a single update, we will use an IoT device with nRF9160 DK integrated with Anjay IoT SDK \u2014 a setup that enables LwM2M Connectivity. In the tutorial, we'll guide you through a few steps to handle OTA updates, monitor update statuses, and confirm if the device was successfully updated. Connect your IoT devices with Anjay LwM2M Client: Anjay Client repository Anjay Zephyr Client repository Coiote IoT Device Management - free registration: Test it out yourself by registering for a free Developer account Coiote IoT DM user account.","title":"How to perform secure Over-the-Air (OTA) updates? (nRF9160 DK)"},{"location":"Coiote_IoT_DM/Coiote_videos/How_to_perform_secure_Over-the-Air_updates/#how-to-perform-secure-over-the-air-ota-updates-nrf9160-dk","text":"The LwM2M standard makes Over-the-Air (OTA) updates straightforward, reducing the complexity of implementation and management. What's crucial is that it enhances security through authentication and encryption. To demonstrate the potential of a single update, we will use an IoT device with nRF9160 DK integrated with Anjay IoT SDK \u2014 a setup that enables LwM2M Connectivity. In the tutorial, we'll guide you through a few steps to handle OTA updates, monitor update statuses, and confirm if the device was successfully updated. Connect your IoT devices with Anjay LwM2M Client: Anjay Client repository Anjay Zephyr Client repository Coiote IoT Device Management - free registration: Test it out yourself by registering for a free Developer account Coiote IoT DM user account.","title":"How to perform secure Over-the-Air (OTA) updates? (nRF9160 DK)"},{"location":"Coiote_IoT_DM/Coiote_videos/How_to_remotely_configure_IoT_devices/","text":"How to remotely configure IoT devices? # With IoT devices enabled with LwM2M protocol, you can use a set of standardized operations to configure your devices remotely. To prepare your device with LwM2M connectivity, grab Anjay IoT SDK, Anjay Zephyr Client, or any LwM2M Client. In our tutorial, we'll be exploring remote configuration options such as Read, Write, Observe, and Execute operations. Connect your IoT devices with Anjay LwM2M Client: Anjay Client repository Anjay Zephyr Client repository Coiote IoT Device Management - free registration: Test it out yourself by registering for a free Developer account Coiote IoT DM user account.","title":"How to remotely configure IoT devices?"},{"location":"Coiote_IoT_DM/Coiote_videos/How_to_remotely_configure_IoT_devices/#how-to-remotely-configure-iot-devices","text":"With IoT devices enabled with LwM2M protocol, you can use a set of standardized operations to configure your devices remotely. To prepare your device with LwM2M connectivity, grab Anjay IoT SDK, Anjay Zephyr Client, or any LwM2M Client. In our tutorial, we'll be exploring remote configuration options such as Read, Write, Observe, and Execute operations. Connect your IoT devices with Anjay LwM2M Client: Anjay Client repository Anjay Zephyr Client repository Coiote IoT Device Management - free registration: Test it out yourself by registering for a free Developer account Coiote IoT DM user account.","title":"How to remotely configure IoT devices?"},{"location":"Coiote_IoT_DM/Coiote_videos/How_to_remotely_monitor_IoT_devices_and_diagnose_issues/","text":"How to remotely monitor IoT devices and diagnose issues? # With Coiote IoT Device Management Platform, you can effortlessly monitor and troubleshoot all your IoT devices from one central location. Our tutorial will walk you through the real-time monitoring for each device and will demonstrate how to manage an entire fleet of IoT devices by resolving issues remotely. Connect your IoT devices with Anjay LwM2M Client: Anjay Client repository Anjay Zephyr Client repository Coiote IoT Device Management - free registration: Test it out yourself by registering for a free Developer account Coiote IoT DM user account.","title":"How to remotely monitor IoT devices and diagnose issues?"},{"location":"Coiote_IoT_DM/Coiote_videos/How_to_remotely_monitor_IoT_devices_and_diagnose_issues/#how-to-remotely-monitor-iot-devices-and-diagnose-issues","text":"With Coiote IoT Device Management Platform, you can effortlessly monitor and troubleshoot all your IoT devices from one central location. Our tutorial will walk you through the real-time monitoring for each device and will demonstrate how to manage an entire fleet of IoT devices by resolving issues remotely. Connect your IoT devices with Anjay LwM2M Client: Anjay Client repository Anjay Zephyr Client repository Coiote IoT Device Management - free registration: Test it out yourself by registering for a free Developer account Coiote IoT DM user account.","title":"How to remotely monitor IoT devices and diagnose issues?"},{"location":"Coiote_IoT_DM/Coiote_videos/How_to_simply_onboard_and_provision_IoT_devices/","text":"How to simply onboard and provision IoT devices? # If you've struggled with getting your IoT devices securely connected to the cloud, you're not alone \u2013 it's a common challenge for many developers. But here's the good news: we've got a straightforward solution, and using the Coiote IoT Device Management Platform can make it easier. To get started, grab a board with Anjay IoT SDK, Anjay Zephyr Client, or any LwM2M Client. You can find the list here . In our tutorial, we'll guide you through registering your device and ensuring it's securely provisioned. We'll cover authentication, confirmed registration, and show you how to check your device's status. Connect your IoT devices with Anjay LwM2M Client: Anjay Client repository Anjay Zephyr Client repository Coiote IoT Device Management - free registration: Test it out yourself by registering for a free Developer account Coiote IoT DM user account.","title":"How to simply onboard and provision IoT devices?"},{"location":"Coiote_IoT_DM/Coiote_videos/How_to_simply_onboard_and_provision_IoT_devices/#how-to-simply-onboard-and-provision-iot-devices","text":"If you've struggled with getting your IoT devices securely connected to the cloud, you're not alone \u2013 it's a common challenge for many developers. But here's the good news: we've got a straightforward solution, and using the Coiote IoT Device Management Platform can make it easier. To get started, grab a board with Anjay IoT SDK, Anjay Zephyr Client, or any LwM2M Client. You can find the list here . In our tutorial, we'll guide you through registering your device and ensuring it's securely provisioned. We'll cover authentication, confirmed registration, and show you how to check your device's status. Connect your IoT devices with Anjay LwM2M Client: Anjay Client repository Anjay Zephyr Client repository Coiote IoT Device Management - free registration: Test it out yourself by registering for a free Developer account Coiote IoT DM user account.","title":"How to simply onboard and provision IoT devices?"},{"location":"Coiote_IoT_DM/Coiote_videos/What_types_of_IoT_data_are_collected_and_stored_in_the_Coiote/","text":"What types of IoT data are collected and stored in the Coiote? # The Coiote IoT Device Management Platform enables you to gather diverse data types inside the standardized data model offered by the LwM2M protocol. Within the platform, you'll discover, for example: Device Information Connectivity Status Firmware and Software Versions Configuration Data Sensor Data Location Data Security Information Battery Status It equips you with everything needed to monitor the device's health and collect essential data for IoT applications or external platforms. Follow the tutorial to understand where to locate the necessary information. Connect your IoT devices with Anjay LwM2M Client: Anjay Client repository Anjay Zephyr Client repository Coiote IoT Device Management - free registration: Test it out yourself by registering for a free Developer account Coiote IoT DM user account.","title":"What types of IoT data are collected and stored in the Coiote?"},{"location":"Coiote_IoT_DM/Coiote_videos/What_types_of_IoT_data_are_collected_and_stored_in_the_Coiote/#what-types-of-iot-data-are-collected-and-stored-in-the-coiote","text":"The Coiote IoT Device Management Platform enables you to gather diverse data types inside the standardized data model offered by the LwM2M protocol. Within the platform, you'll discover, for example: Device Information Connectivity Status Firmware and Software Versions Configuration Data Sensor Data Location Data Security Information Battery Status It equips you with everything needed to monitor the device's health and collect essential data for IoT applications or external platforms. Follow the tutorial to understand where to locate the necessary information. Connect your IoT devices with Anjay LwM2M Client: Anjay Client repository Anjay Zephyr Client repository Coiote IoT Device Management - free registration: Test it out yourself by registering for a free Developer account Coiote IoT DM user account.","title":"What types of IoT data are collected and stored in the Coiote?"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.22.1/","text":"v2021.22.1 # Previous version: v2021.19.0 Features # New Device inventory view The new Device inventory is now the default for viewing devices in the Coiote IoT DM platform. It has an improved design as well as faster and more stable performance. The new Device inventory is available directly from the left navigation bar. If you need to access the old Device inventory view, go to Administration -> Device inventory . Enhancements # EST DER format support We switched from the PEM to the DER content format of enrolling and re-enrolling requests sent to the EST server. Thanks to this change more EST Server implementations will be supported and compliance with RFC7030 is enhanced. Bug fixes # Larger limits for HTTP request headers Thanks to a new configuration for Jetty, you can now access REST API and Coiote IoT DM GUI even with large HTTP request headers. Security # Updated Grafana version to fix the CVE-2021-43798 vulnerability. Our security scan confirmed that Coiote IoT DM isn\u2019t affected by the Apache Log4j vulnerability.","title":"v2021.22.1"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.22.1/#v2021221","text":"Previous version: v2021.19.0","title":"v2021.22.1"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.22.1/#features","text":"New Device inventory view The new Device inventory is now the default for viewing devices in the Coiote IoT DM platform. It has an improved design as well as faster and more stable performance. The new Device inventory is available directly from the left navigation bar. If you need to access the old Device inventory view, go to Administration -> Device inventory .","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.22.1/#enhancements","text":"EST DER format support We switched from the PEM to the DER content format of enrolling and re-enrolling requests sent to the EST server. Thanks to this change more EST Server implementations will be supported and compliance with RFC7030 is enhanced.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.22.1/#bug-fixes","text":"Larger limits for HTTP request headers Thanks to a new configuration for Jetty, you can now access REST API and Coiote IoT DM GUI even with large HTTP request headers.","title":"Bug fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.22.1/#security","text":"Updated Grafana version to fix the CVE-2021-43798 vulnerability. Our security scan confirmed that Coiote IoT DM isn\u2019t affected by the Apache Log4j vulnerability.","title":"Security"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.23.0/","text":"v2021.23.0 # Previous version: v2021.22.1 Enhancements # Record headers in Kafka messages You can now add record headers to the kafkaPublish tag when configuring an XML task. It means that the components responsible for the Kafka event processing (e.g., routing) no longer need to read each binary message. Instead, these components read only the record headers and therefore work faster. Support for additional non-standard device type We continue to improve compatibility with devices that have incomplete or faulty support of the standard LwM2M protocol. To make such a device ready to work with Coiote IoT DM, you can now turn on and configure a non-standard logic in the Device dialects section. New error pages The 400, 404, and 5XX error pages now have a cleaner and more user-friendly look. Bug fixes # Uninterrupted access to GUI Fixed a bug where the GUI of Coiote IoT DM would crash after 30 minutes of inactivity on some installations. Thanks to the new configuration, the GUI now works smoothly even after hours of inactivity. JDK downgrade To improve the speed performance of Coiote IoT DM, we\u2019ve downgraded the JDK version from 17 to 11. No action is required for the virtual machine deployments because the JRE is included in the docker image.","title":"v2021.23.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.23.0/#v2021230","text":"Previous version: v2021.22.1","title":"v2021.23.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.23.0/#enhancements","text":"Record headers in Kafka messages You can now add record headers to the kafkaPublish tag when configuring an XML task. It means that the components responsible for the Kafka event processing (e.g., routing) no longer need to read each binary message. Instead, these components read only the record headers and therefore work faster. Support for additional non-standard device type We continue to improve compatibility with devices that have incomplete or faulty support of the standard LwM2M protocol. To make such a device ready to work with Coiote IoT DM, you can now turn on and configure a non-standard logic in the Device dialects section. New error pages The 400, 404, and 5XX error pages now have a cleaner and more user-friendly look.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.23.0/#bug-fixes","text":"Uninterrupted access to GUI Fixed a bug where the GUI of Coiote IoT DM would crash after 30 minutes of inactivity on some installations. Thanks to the new configuration, the GUI now works smoothly even after hours of inactivity. JDK downgrade To improve the speed performance of Coiote IoT DM, we\u2019ve downgraded the JDK version from 17 to 11. No action is required for the virtual machine deployments because the JRE is included in the docker image.","title":"Bug fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.24.5/","text":"v2021.24.5 # Previous version: v2021.23.0 Features # Read Model Factory on EU Cloud installation The data for the Dashboard and Device Inventory views is now provided by the Read Model Factory module deployed as a separate application to optimize resource consumption and data processing. What changes in the application: Both the Dashboard and Device Inventory views now display bootstrap and management device entities in a single line, with links to the Device Management Center for each device entity. In the Dashboard view, you can now search for alerts by device data - lifecycle status, domain, group, manufacturer, model name, firmware version. Bypassing light sessions by HealthChecker We have added a possibility to create a list of device IDs in cdm.conf that will have normal sessions even when the light session threshold is reached. Enhancements # Whitelabelling and custom URLs in Identity and Access Management When logging to Coiote IoT DM (cloud installations) using a custom tenant hostname, the user can now be redirected to a login page under the same custom tenant hostname. The change applies to the Coiote IoT DM login page , User Management view and the change password view.","title":"v2021.24.5"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.24.5/#v2021245","text":"Previous version: v2021.23.0","title":"v2021.24.5"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.24.5/#features","text":"Read Model Factory on EU Cloud installation The data for the Dashboard and Device Inventory views is now provided by the Read Model Factory module deployed as a separate application to optimize resource consumption and data processing. What changes in the application: Both the Dashboard and Device Inventory views now display bootstrap and management device entities in a single line, with links to the Device Management Center for each device entity. In the Dashboard view, you can now search for alerts by device data - lifecycle status, domain, group, manufacturer, model name, firmware version. Bypassing light sessions by HealthChecker We have added a possibility to create a list of device IDs in cdm.conf that will have normal sessions even when the light session threshold is reached.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2021.24.5/#enhancements","text":"Whitelabelling and custom URLs in Identity and Access Management When logging to Coiote IoT DM (cloud installations) using a custom tenant hostname, the user can now be redirected to a login page under the same custom tenant hostname. The change applies to the Coiote IoT DM login page , User Management view and the change password view.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.13.5/","text":"v2022.13.5 # Previous version: v2022.12.4 Features # New Device Center We have introduced the new Device Center for effective management of single devices. Designed to enable IoT developers build LwM2M applications quickly and intuitively, it features the following actionable views: Summary sidebar Use device actions (reboot, data model refresh, clear DTLS context, delete device) Quickly check connection status and parameters See basic device info Overview tab Display widgets related to device status and connectivity View Device location on the map and check location details Configuration tab Upload device image and change its Friendly name View and copy device connection parameters Data model tab Perform or schedule operations on device objects, object instances, and resources: Read Write Execute Set observations View the details of individual objects and resources Search the data model for device objects, object instances, and resources The Device Center replaces the old Device Management Center view (DMC) which is still supported - use the Go to previous version button and the Go to new Device Center link to switch between them.","title":"v2022.13.5"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.13.5/#v2022135","text":"Previous version: v2022.12.4","title":"v2022.13.5"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.13.5/#features","text":"New Device Center We have introduced the new Device Center for effective management of single devices. Designed to enable IoT developers build LwM2M applications quickly and intuitively, it features the following actionable views: Summary sidebar Use device actions (reboot, data model refresh, clear DTLS context, delete device) Quickly check connection status and parameters See basic device info Overview tab Display widgets related to device status and connectivity View Device location on the map and check location details Configuration tab Upload device image and change its Friendly name View and copy device connection parameters Data model tab Perform or schedule operations on device objects, object instances, and resources: Read Write Execute Set observations View the details of individual objects and resources Search the data model for device objects, object instances, and resources The Device Center replaces the old Device Management Center view (DMC) which is still supported - use the Go to previous version button and the Go to new Device Center link to switch between them.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.16.0/","text":"v2022.16.0 # Previous version: v2022.14.15 Enhancements # Minor GUI enhancements We have fixed the behaviour of dialog windows for some platform views. We have improved the looks of empty states in some places of the GUI. The \u2018Additional costs\u2019 calculator in the Payment service panel has been modified so that it now includes base and additional costs. Validations have been added in the Set observation side navigation dialog of the Device Center . We have changed the date format presented in the GUI so that it conforms to the ISO standard. Float values presented in the data model are now rounded to at most two significant digits. Domain hierarchy support for DTLS/TLS certificates The DTLS/TLS Certificates panel now displays only certificates from the current domain that the user is logged into. Bug Fixes # Fixed the Certificate Request message when connecting over TLS/TCP We have fixed the Certificate Request message when the Server and Client try to connect over TLS/TCP. Connection errors for clients that use MBed TLS (including Anjay ) are now solved. Fixed the license invalidation We have corrected the License invalidation action so that it is done only after a configurable retry backoff time limit. Added validation the Azure IoT Hub integration We have added a validation for the Device ID in the Hyperscaler Integration Center . Now the Device ID should be a string up to 128 characters long consisting of alphanumeric characters plus the special characters: '-', '.', '_', ':'. The last character must be alphanumeric or dash. Fixed scheduling firmware upgrades when resource value is an empty string We have fixed an error that prevented scheduling firmware upgrades on devices whose Firmware Update Protocol Support resource value was an empty string.","title":"v2022.16.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.16.0/#v2022160","text":"Previous version: v2022.14.15","title":"v2022.16.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.16.0/#enhancements","text":"Minor GUI enhancements We have fixed the behaviour of dialog windows for some platform views. We have improved the looks of empty states in some places of the GUI. The \u2018Additional costs\u2019 calculator in the Payment service panel has been modified so that it now includes base and additional costs. Validations have been added in the Set observation side navigation dialog of the Device Center . We have changed the date format presented in the GUI so that it conforms to the ISO standard. Float values presented in the data model are now rounded to at most two significant digits. Domain hierarchy support for DTLS/TLS certificates The DTLS/TLS Certificates panel now displays only certificates from the current domain that the user is logged into.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.16.0/#bug-fixes","text":"Fixed the Certificate Request message when connecting over TLS/TCP We have fixed the Certificate Request message when the Server and Client try to connect over TLS/TCP. Connection errors for clients that use MBed TLS (including Anjay ) are now solved. Fixed the license invalidation We have corrected the License invalidation action so that it is done only after a configurable retry backoff time limit. Added validation the Azure IoT Hub integration We have added a validation for the Device ID in the Hyperscaler Integration Center . Now the Device ID should be a string up to 128 characters long consisting of alphanumeric characters plus the special characters: '-', '.', '_', ':'. The last character must be alphanumeric or dash. Fixed scheduling firmware upgrades when resource value is an empty string We have fixed an error that prevented scheduling firmware upgrades on devices whose Firmware Update Protocol Support resource value was an empty string.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.17.0/","text":"v2022.17.0 # Previous version: v2022.16.0 Features # Configuring EST integration via Domain properties We have introduced dynamic EST integration configuration via the domain properties. It is now possible for each client to set up its own EST server in the Domain management view. The configuration is inherited (analogously to the Kafka settings e.g.). To use the EST configuration property, the domainProperties.est permission is required. If there is no EST configuration on a given domain, then the system uses the value from Coiote IoT DM cdm.conf config file as a fallback, which ensures backward compatibility. Changes have also been made to the DTLS/TLS Certificates view. Now only certificates added in the given domain are presented to avoid cross-domain certificate visibility. Architectural Changes # There were no architectural changes in this release. Enhancements # Minor GUI improvements In Device Inventory, the filter counter is now hidden when there is no filter applied. \u2018Impersonated by\u2019 column in User activity table of Historical analysis We have added a new column to the User activity table that shows the UserID of the actual user (impersonator) who executed the recorded action from the account of the user being impersonated. Bug Fixes # Fixed Cancel all tests action in the Device tests tab of DMC We have fixed the faulty behaviour of the Cancel all tests button used to stop the execution of tests inside the Device tests tab of the Device Management Center. Fixed loading data for multiresources with no instances in the data model We have fixed an error occurring while loading a multiresource that has no instances in the data model. Now the multi-resource value is displayed in the same manner as a single resource without value. Fixed task execution status (report) not displayed after device domain change When moving devices between domains, their task execution statuses (reports) are now updated accordingly.","title":"v2022.17.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.17.0/#v2022170","text":"Previous version: v2022.16.0","title":"v2022.17.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.17.0/#features","text":"Configuring EST integration via Domain properties We have introduced dynamic EST integration configuration via the domain properties. It is now possible for each client to set up its own EST server in the Domain management view. The configuration is inherited (analogously to the Kafka settings e.g.). To use the EST configuration property, the domainProperties.est permission is required. If there is no EST configuration on a given domain, then the system uses the value from Coiote IoT DM cdm.conf config file as a fallback, which ensures backward compatibility. Changes have also been made to the DTLS/TLS Certificates view. Now only certificates added in the given domain are presented to avoid cross-domain certificate visibility.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.17.0/#architectural-changes","text":"There were no architectural changes in this release.","title":"Architectural Changes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.17.0/#enhancements","text":"Minor GUI improvements In Device Inventory, the filter counter is now hidden when there is no filter applied. \u2018Impersonated by\u2019 column in User activity table of Historical analysis We have added a new column to the User activity table that shows the UserID of the actual user (impersonator) who executed the recorded action from the account of the user being impersonated.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.17.0/#bug-fixes","text":"Fixed Cancel all tests action in the Device tests tab of DMC We have fixed the faulty behaviour of the Cancel all tests button used to stop the execution of tests inside the Device tests tab of the Device Management Center. Fixed loading data for multiresources with no instances in the data model We have fixed an error occurring while loading a multiresource that has no instances in the data model. Now the multi-resource value is displayed in the same manner as a single resource without value. Fixed task execution status (report) not displayed after device domain change When moving devices between domains, their task execution statuses (reports) are now updated accordingly.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.18.3/","text":"v2022.18.3 # Previous version: v2022.17.0 Enhancements # FOTA panel redirection page in Device Center We have added a new FOTA tab in the Device Center. It redirects users to the previous version of the Device Management Center to perform a device Firmware upgrade. The new FOTA view is currently under development. Improvements in Device inventory and Operations center We have introduced some enhancements to the Device inventory and Operations center . Now it is the Device inventory that is the default page displayed upon logging in to the platform. The order in the navigation menu has also been changed. In the Operations center , the Alerts tab is now the default view that is displayed. The tables that list devices and alerts have new columns: Device inventory : Status , Bootstrap Operations center Alerts tab: Status , Alert status Operations center Device list tab: Status , Device alert status Sorting has been enabled in the newly added columns. Bug Fixes # Fixed Select template button behaviour in Task templates In the Task template panel, the Select template button now appears correctly even for long template names. section for description of bug fixes. Fixed Device registration status action We have fixed the behaviour of the Devices registration status action feature so that now the configured action is performed only for the domain it was set up in - no conflict of domains occurs. Fixed the Leave tag in XML tasks We have fixed the behaviour of the leave tag in the XML tasks, so that the device now leaves all the defined subgroups and the task finishes successfully. Fixed loading page when migrating large numbers of devices between domains We have fixed the GUI action of changing the domain for large numbers of devices via the Device inventory . Now the loading page doesn\u2019t freeze while handling bulk migrations. Fixed no response for 2nd Register Update in some devices As a result of failure to persist updated device lifetime, the Server responded with the 4.04 error for the second Register Update in some devices. We have fixed it so that concurrent update handling in the Coiote IoT DM database is avoided.","title":"v2022.18.3"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.18.3/#v2022183","text":"Previous version: v2022.17.0","title":"v2022.18.3"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.18.3/#enhancements","text":"FOTA panel redirection page in Device Center We have added a new FOTA tab in the Device Center. It redirects users to the previous version of the Device Management Center to perform a device Firmware upgrade. The new FOTA view is currently under development. Improvements in Device inventory and Operations center We have introduced some enhancements to the Device inventory and Operations center . Now it is the Device inventory that is the default page displayed upon logging in to the platform. The order in the navigation menu has also been changed. In the Operations center , the Alerts tab is now the default view that is displayed. The tables that list devices and alerts have new columns: Device inventory : Status , Bootstrap Operations center Alerts tab: Status , Alert status Operations center Device list tab: Status , Device alert status Sorting has been enabled in the newly added columns.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.18.3/#bug-fixes","text":"Fixed Select template button behaviour in Task templates In the Task template panel, the Select template button now appears correctly even for long template names. section for description of bug fixes. Fixed Device registration status action We have fixed the behaviour of the Devices registration status action feature so that now the configured action is performed only for the domain it was set up in - no conflict of domains occurs. Fixed the Leave tag in XML tasks We have fixed the behaviour of the leave tag in the XML tasks, so that the device now leaves all the defined subgroups and the task finishes successfully. Fixed loading page when migrating large numbers of devices between domains We have fixed the GUI action of changing the domain for large numbers of devices via the Device inventory . Now the loading page doesn\u2019t freeze while handling bulk migrations. Fixed no response for 2nd Register Update in some devices As a result of failure to persist updated device lifetime, the Server responded with the 4.04 error for the second Register Update in some devices. We have fixed it so that concurrent update handling in the Coiote IoT DM database is avoided.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.19.2/","text":"v2022.19.2 # Previous version: v2022.18.3 Enhancements # Connection status indicator in Device creator summary We have introduced the connection status indicator to the summary step of the Device creator . It is now consistent with the Device Center summary \u2018Impersonated by\u2019 column in task edition history of Historical analysis We have added the \u2018Impersonated by\u2019 column to theTask edition history table that shows the UserID of the actual user (impersonator) who executed the recorded action from the account of the user being impersonated. Architectural Changes # Device ID changes to Endpoint name We have changed the Device ID label to Endpoint name in Device inventory, Device Center and other relevant views. This has been triggered by major changes in how the device endpoint name is now encrypted in the database. Bug Fixes # Fixed Devices registration status action causing domain change Deleting Devices registration status action no longer causes devices to change domains. Fixed behavior of snackbars persisting between steps of the Device creator Snackbars appearing In the \"Connect your device\u201d step of Device creator will now disappear when navigating to the next step. Fixed searching for task templates We have fixed the search option available when selecting a task template. It now works correctly, also for old Expressions and for characters such as square brackets.","title":"v2022.19.2"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.19.2/#v2022192","text":"Previous version: v2022.18.3","title":"v2022.19.2"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.19.2/#enhancements","text":"Connection status indicator in Device creator summary We have introduced the connection status indicator to the summary step of the Device creator . It is now consistent with the Device Center summary \u2018Impersonated by\u2019 column in task edition history of Historical analysis We have added the \u2018Impersonated by\u2019 column to theTask edition history table that shows the UserID of the actual user (impersonator) who executed the recorded action from the account of the user being impersonated.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.19.2/#architectural-changes","text":"Device ID changes to Endpoint name We have changed the Device ID label to Endpoint name in Device inventory, Device Center and other relevant views. This has been triggered by major changes in how the device endpoint name is now encrypted in the database.","title":"Architectural Changes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.19.2/#bug-fixes","text":"Fixed Devices registration status action causing domain change Deleting Devices registration status action no longer causes devices to change domains. Fixed behavior of snackbars persisting between steps of the Device creator Snackbars appearing In the \"Connect your device\u201d step of Device creator will now disappear when navigating to the next step. Fixed searching for task templates We have fixed the search option available when selecting a task template. It now works correctly, also for old Expressions and for characters such as square brackets.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.20.4/","text":"v2022.20.4 # Previous version: v2022.19.2 Features # Connect single device to Azure We have added an option to connect single devices in Device inventory to the currently integrated Azure service. It is available in the context menu for each created device displayed in the Device inventory table. The operation can only be performed for a device with a configured LwM2M Management server and in the domain that the device belongs to. Saving filter state of the Device inventory in URL fragment In Device inventory , we have introduced saving filter data as state in a URL fragment. This allows saving any filter data e.g. groups, domain, lifecycle status, and search text. When the user saves a filter or types in the search field, the URL fragment is updated. When copying and pasting the URL, the relevant data context will be applied in the filter. Architectural Changes # New monitoring endpoints in restAPI We have implemented two device monitoring restAPI endpoints: /deviceMonitoring/data/{deviceId}/resourceUrl/{lwm2mUrl} - returns a series of monitoring data from the device's resource identified by its LwM2M URL that were reported between the timeRangeStart and timeRangeEnd . /deviceMonitoring/data/{deviceId}/alias/{alias} - returns a series of monitoring data from the device's resource identified by its alias that were reported between the timeRangeStart and timeRangeEnd . Enhancements # New methods added to lwM2M context in XML tasks Added two methods to lwm2m context in XML tasks: dmPathToLwM2MPath - transforms a dmPath to a lwm2mPath (eg. Device.0.Manufacturer -> /3/0/0 ) getDataType gets the data type for a given path (eg. Device.0.Manufacturer -> string) If the specified dmPath is not known, because either: the model is invalid or the path itself is invalid, then the method will return null . Bug Fixes # Fixed adding devices to inaccessible group using <join> tag We have changed the behavior of the XML task <join> tag so that it is no longer possible to create a group in the wrong domain using the tag. Fixed values of Connectivity widgets in Device Center Overview tab We have fixed the Cell ID , APN , Radio signal strength and Network bearer Connectivity widgets in Device Center so that each displays the relevant values.","title":"v2022.20.4"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.20.4/#v2022204","text":"Previous version: v2022.19.2","title":"v2022.20.4"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.20.4/#features","text":"Connect single device to Azure We have added an option to connect single devices in Device inventory to the currently integrated Azure service. It is available in the context menu for each created device displayed in the Device inventory table. The operation can only be performed for a device with a configured LwM2M Management server and in the domain that the device belongs to. Saving filter state of the Device inventory in URL fragment In Device inventory , we have introduced saving filter data as state in a URL fragment. This allows saving any filter data e.g. groups, domain, lifecycle status, and search text. When the user saves a filter or types in the search field, the URL fragment is updated. When copying and pasting the URL, the relevant data context will be applied in the filter.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.20.4/#architectural-changes","text":"New monitoring endpoints in restAPI We have implemented two device monitoring restAPI endpoints: /deviceMonitoring/data/{deviceId}/resourceUrl/{lwm2mUrl} - returns a series of monitoring data from the device's resource identified by its LwM2M URL that were reported between the timeRangeStart and timeRangeEnd . /deviceMonitoring/data/{deviceId}/alias/{alias} - returns a series of monitoring data from the device's resource identified by its alias that were reported between the timeRangeStart and timeRangeEnd .","title":"Architectural Changes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.20.4/#enhancements","text":"New methods added to lwM2M context in XML tasks Added two methods to lwm2m context in XML tasks: dmPathToLwM2MPath - transforms a dmPath to a lwm2mPath (eg. Device.0.Manufacturer -> /3/0/0 ) getDataType gets the data type for a given path (eg. Device.0.Manufacturer -> string) If the specified dmPath is not known, because either: the model is invalid or the path itself is invalid, then the method will return null .","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.20.4/#bug-fixes","text":"Fixed adding devices to inaccessible group using <join> tag We have changed the behavior of the XML task <join> tag so that it is no longer possible to create a group in the wrong domain using the tag. Fixed values of Connectivity widgets in Device Center Overview tab We have fixed the Cell ID , APN , Radio signal strength and Network bearer Connectivity widgets in Device Center so that each displays the relevant values.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.21.6/","text":"v2022.21.6 # Previous version: v2022.20.4 Features # New domain property group for configuring historical data storage period In Domain management , we have introduced the possibility to define how long the device historical data should be stored. It can be configured using a property for a specific domain. The default maximum storage limit is 30 days. Bug Fixes # Fixed no EST logs generated for device when EST request is made EST logs are now generated correctly for the device bootstrap entity. Fixed no possibility to delete \u201cbillable\u201d domain We have restored the possibility to delete billing admin domains by superusers (under the standard condition that they don\u2019t contain any subdomains, users, and devices). Fixed failing Azure IoT Hub device export We have fixed the issue with exporting devices to Azure IoT Hub via GUI and API by upgrading the Azure SDK libraries to the newest versions. We have also added possibility to re-initialize client connection to Azure on demand via the REST API using the new extensions/hyperscaler/restartClient method. Fixed Clear all button that disabled searching the same phrase in Device inventory We have fixed the behaviour of the Device inventory search field. Now clicking the Clear all button after having searched a phrase, then trying to search the same phrase works as intended. Fixed API user not able retrieve test results if the test definition comes from parent domain We have fixed the inability to retrieve test results by REST API users for tests defined in parent domains by aligning the API with the correct behaviour of the feature in GUI. Fixed inactive scroll for domain list in XML task creation view We have fixed scrolling for the drop-down domain list used when creating an XML task.","title":"v2022.21.6"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.21.6/#v2022216","text":"Previous version: v2022.20.4","title":"v2022.21.6"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.21.6/#features","text":"New domain property group for configuring historical data storage period In Domain management , we have introduced the possibility to define how long the device historical data should be stored. It can be configured using a property for a specific domain. The default maximum storage limit is 30 days.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.21.6/#bug-fixes","text":"Fixed no EST logs generated for device when EST request is made EST logs are now generated correctly for the device bootstrap entity. Fixed no possibility to delete \u201cbillable\u201d domain We have restored the possibility to delete billing admin domains by superusers (under the standard condition that they don\u2019t contain any subdomains, users, and devices). Fixed failing Azure IoT Hub device export We have fixed the issue with exporting devices to Azure IoT Hub via GUI and API by upgrading the Azure SDK libraries to the newest versions. We have also added possibility to re-initialize client connection to Azure on demand via the REST API using the new extensions/hyperscaler/restartClient method. Fixed Clear all button that disabled searching the same phrase in Device inventory We have fixed the behaviour of the Device inventory search field. Now clicking the Clear all button after having searched a phrase, then trying to search the same phrase works as intended. Fixed API user not able retrieve test results if the test definition comes from parent domain We have fixed the inability to retrieve test results by REST API users for tests defined in parent domains by aligning the API with the correct behaviour of the feature in GUI. Fixed inactive scroll for domain list in XML task creation view We have fixed scrolling for the drop-down domain list used when creating an XML task.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.22.0/","text":"v2022.22.0 # Previous version: v2022.21.6 Features # Added bulk device removal in Device inventory for non-superusers We have added bulk device removal (as a group action) in the Device inventory with a limit of 100 devices for non-superusers who have the ui.deviceInventory.deleteDevice role. New REST API endpoints for setting observations on device groups We have created two new endpoints for setting observations on device groups. /observations/group/resourcePath/{groupId}/{path} creates or updates group observations for a given path. /observations/group/resourceUrl/{groupId}/{url} creates or updates group observations for a given LwM2M URL. Both endpoints have the createEnsureObserveIfNotExists attribute which determines if the ensureObserve task should be created in case it doesn\u2019t exist. Enhancements # Removed outdated Azure IoT integration extension We have removed the outdated method of connecting the Azure IoT integration which was available as an extension in the Administration -> Extensions view. Removed Device settings XML panels from default configuration We have removed the default XML panels in the Device settings tab of the old DMC: Access Control Connectivity Device Location Servers Also, the Device settings tab is no longer a default DMC menu tab. Added possibility to configure Execution logs storage for tasks and task templates We have added a new option for tasks and task templates that allows selecting which type of execution logs should be stored, with three options: Store all - default behavior, all logs are generated and stored. Store failed - logs will be generated only if task execution fails. Store none - logs are not generated. Bug Fixes # Fixed inability to create an Azure template with custom LwM2M objects in non-root domain LwM2M objects created by means of custom object definitions can be now included in Azure integration templates by users in non-root domains. Fixed static documentation not respecting multitenancy We have fixed the behavior of static documentation (i.e. generated via files uploaded in the Resources panel ) so that it is only visible for users in relevant domains. Fixed different results of reading and writing executable resources Writing to an executable resource caused the platform to report communication failure. We have aligned this behavior with the results of reading an executable resource, in which case a response with the correct 4.05 MethodNotAllowed error code is returned.","title":"v2022.22.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.22.0/#v2022220","text":"Previous version: v2022.21.6","title":"v2022.22.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.22.0/#features","text":"Added bulk device removal in Device inventory for non-superusers We have added bulk device removal (as a group action) in the Device inventory with a limit of 100 devices for non-superusers who have the ui.deviceInventory.deleteDevice role. New REST API endpoints for setting observations on device groups We have created two new endpoints for setting observations on device groups. /observations/group/resourcePath/{groupId}/{path} creates or updates group observations for a given path. /observations/group/resourceUrl/{groupId}/{url} creates or updates group observations for a given LwM2M URL. Both endpoints have the createEnsureObserveIfNotExists attribute which determines if the ensureObserve task should be created in case it doesn\u2019t exist.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.22.0/#enhancements","text":"Removed outdated Azure IoT integration extension We have removed the outdated method of connecting the Azure IoT integration which was available as an extension in the Administration -> Extensions view. Removed Device settings XML panels from default configuration We have removed the default XML panels in the Device settings tab of the old DMC: Access Control Connectivity Device Location Servers Also, the Device settings tab is no longer a default DMC menu tab. Added possibility to configure Execution logs storage for tasks and task templates We have added a new option for tasks and task templates that allows selecting which type of execution logs should be stored, with three options: Store all - default behavior, all logs are generated and stored. Store failed - logs will be generated only if task execution fails. Store none - logs are not generated.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.22.0/#bug-fixes","text":"Fixed inability to create an Azure template with custom LwM2M objects in non-root domain LwM2M objects created by means of custom object definitions can be now included in Azure integration templates by users in non-root domains. Fixed static documentation not respecting multitenancy We have fixed the behavior of static documentation (i.e. generated via files uploaded in the Resources panel ) so that it is only visible for users in relevant domains. Fixed different results of reading and writing executable resources Writing to an executable resource caused the platform to report communication failure. We have aligned this behavior with the results of reading an executable resource, in which case a response with the correct 4.05 MethodNotAllowed error code is returned.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.23.11/","text":"v2022.23.11 # Previous version: v2022.22.0 Features # Visualizing data with widgets in the new Dashboard view We have introduced a brand new Dashboard view for displaying widgets used for data visualization. Widgets are set and configured in the Data model tab of the Device Center , along with their corresponding Observations to enable data collection. The Dashboard data is displayed per domain and features the following kinds of charts based on the type of data collected: Line chart Boolean chart Gantt chart Punch card chart Architectural Changes # Renamed cdm.conf configuration file to devman.conf We have renamed the cdm.conf configuration filename to devman.conf according to the established naming convention. Device ID compatibility translation in REST API v3 endpoints We have completed the bidirectional compatibility translation between the old and new Device ID format for all the REST API v3 endpoints. In the new Device ID format, the Endpoint name is now hashed for better security. Enhancements # Improvements in displaying tooltips We have fixed the behavior of the tooltips so that the displayed tooltip of one button doesn\u2019t prevent clicking on the neighboring element. We have also introduced small delays when showing and hiding tooltips upon hovering on an UI element. Consistent spacings between text fields We have introduced consistent spacings between text fields in Operations Center and Device inventory . Bug Fixes # Fixed Azure IoT devices cannot be deleted We have fixed a bug which prevented the user from deleting devices connected to an Azure IoT integration. Now, device deletion is instantaneous. Fixed hex key validation when adding a device with PSK mode We have fixed the validation of keys typed in the hexadecimal format so that the warning message shows immediately after unclicking the key input. Domain verification when updating Management device entity in Bootstrap We have added domain verification when updating the Management device entity inside the Bootstrap entity. Now, if the Management entity already exists it must be visible from the level of Bootstrap task domain, otherwise the task fails.","title":"v2022.23.11"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.23.11/#v20222311","text":"Previous version: v2022.22.0","title":"v2022.23.11"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.23.11/#features","text":"Visualizing data with widgets in the new Dashboard view We have introduced a brand new Dashboard view for displaying widgets used for data visualization. Widgets are set and configured in the Data model tab of the Device Center , along with their corresponding Observations to enable data collection. The Dashboard data is displayed per domain and features the following kinds of charts based on the type of data collected: Line chart Boolean chart Gantt chart Punch card chart","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.23.11/#architectural-changes","text":"Renamed cdm.conf configuration file to devman.conf We have renamed the cdm.conf configuration filename to devman.conf according to the established naming convention. Device ID compatibility translation in REST API v3 endpoints We have completed the bidirectional compatibility translation between the old and new Device ID format for all the REST API v3 endpoints. In the new Device ID format, the Endpoint name is now hashed for better security.","title":"Architectural Changes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.23.11/#enhancements","text":"Improvements in displaying tooltips We have fixed the behavior of the tooltips so that the displayed tooltip of one button doesn\u2019t prevent clicking on the neighboring element. We have also introduced small delays when showing and hiding tooltips upon hovering on an UI element. Consistent spacings between text fields We have introduced consistent spacings between text fields in Operations Center and Device inventory .","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.23.11/#bug-fixes","text":"Fixed Azure IoT devices cannot be deleted We have fixed a bug which prevented the user from deleting devices connected to an Azure IoT integration. Now, device deletion is instantaneous. Fixed hex key validation when adding a device with PSK mode We have fixed the validation of keys typed in the hexadecimal format so that the warning message shows immediately after unclicking the key input. Domain verification when updating Management device entity in Bootstrap We have added domain verification when updating the Management device entity inside the Bootstrap entity. Now, if the Management entity already exists it must be visible from the level of Bootstrap task domain, otherwise the task fails.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.24.14/","text":"v2022.24.14 # Previous version: v2022.23.11 Enhancements # Introduce new Angular Material symbols We have replaced the Angular Material theme icons with Material symbols, migrated the old symbol names to new ones, and replaced the custom SVG with Material symbols. Bug Fixes # Fixed FOTA in the \"only observations\" mode failing every second run We have rewritten some of the conditions of the Firmware-over-the-air upgrade process so that it adheres more strictly to the LwM2M specification and thus minimized cases of FOTA failure. Fixed minor visual issues in the Data model tab of Device Center We have fixed the Widget and Operations columns in the Device Center Data model tab so that the green \u2018success\u2019 icons are displayed properly. Also, we have made consistent the titles of the side navigation dialog displayed when performing LwM2M operations on the Data model . Documentation # Administrator Guide updates We have updated the Administrator Guide so that it reflects the changes in relation to Coiote IoT DM services and installation. Other # We have fixed validation when adding a LwM2M object to a dialect We have added a mechanism for deleting collected device data when a device is deleted and for deleting domain widgets when a domain is deleted.","title":"v2022.24.14"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.24.14/#v20222414","text":"Previous version: v2022.23.11","title":"v2022.24.14"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.24.14/#enhancements","text":"Introduce new Angular Material symbols We have replaced the Angular Material theme icons with Material symbols, migrated the old symbol names to new ones, and replaced the custom SVG with Material symbols.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.24.14/#bug-fixes","text":"Fixed FOTA in the \"only observations\" mode failing every second run We have rewritten some of the conditions of the Firmware-over-the-air upgrade process so that it adheres more strictly to the LwM2M specification and thus minimized cases of FOTA failure. Fixed minor visual issues in the Data model tab of Device Center We have fixed the Widget and Operations columns in the Device Center Data model tab so that the green \u2018success\u2019 icons are displayed properly. Also, we have made consistent the titles of the side navigation dialog displayed when performing LwM2M operations on the Data model .","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.24.14/#documentation","text":"Administrator Guide updates We have updated the Administrator Guide so that it reflects the changes in relation to Coiote IoT DM services and installation.","title":"Documentation"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.24.14/#other","text":"We have fixed validation when adding a LwM2M object to a dialect We have added a mechanism for deleting collected device data when a device is deleted and for deleting domain widgets when a domain is deleted.","title":"Other"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.25.20/","text":"v2022.25.20 # Previous version: v2022.24.14 Architectural Changes # Deprecate the /devices/all/count REST API endpoint We have deprecated the /devices/all/count REST API endpoint. The endpoint remains visible in the REST API and will be removed from the public documentation three months after deprecation. Enhancements # Date format in the Data model We have changed the date format in the Data model to YYYY-MM-DD (dashes instead of slashes). Remove vulnerable dom4j 1.6.1 and xmlbeans 2.3.0 dependencies We have resolved vulnerabilities that could have been potentially caused by the dom4j 1.6.1 and xmlbeans 2.3.0 dependencies used to support PDF-based reports in Monitoring & Reporting > Reports . Switch off old alert table for Device groups We have removed the alert table with all its underlying code from the Group Management Center . Bug Fixes # Fixed incorrect Hide key (hex) text field behavior We have fixed the behavior of the PSK key text field and the eye icon so that when the hex key is hidden, the displayed eye icon is closed (and remains open otherwise). Fixed the select action in task templates We have fixed the behavior of the select checkbox in the Task templates view so that now every new selection clears the previous one. Fixed TaskReports API endpoints always returning empty value in translation mode We have fixed the GET /taskReports and GET /taskReports/moreReports API endpoints so that both endpoints now return proper values of task reports. Fixed enforcing at least one observation parameter when setting and observation We have removed the validation which enforced adding at least one parameter when setting an observation on a device data model. Now, all observation parameters are optional as per the OMA LwM2M specification . Also, the limit of Not more often than once every and At least once every has been lowered to 5 seconds. Fixed allowing for uploading non-image files as device images We have added a validation when uploading a file for a device image which checks if the file is actually in an image format.","title":"v2022.25.20"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.25.20/#v20222520","text":"Previous version: v2022.24.14","title":"v2022.25.20"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.25.20/#architectural-changes","text":"Deprecate the /devices/all/count REST API endpoint We have deprecated the /devices/all/count REST API endpoint. The endpoint remains visible in the REST API and will be removed from the public documentation three months after deprecation.","title":"Architectural Changes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.25.20/#enhancements","text":"Date format in the Data model We have changed the date format in the Data model to YYYY-MM-DD (dashes instead of slashes). Remove vulnerable dom4j 1.6.1 and xmlbeans 2.3.0 dependencies We have resolved vulnerabilities that could have been potentially caused by the dom4j 1.6.1 and xmlbeans 2.3.0 dependencies used to support PDF-based reports in Monitoring & Reporting > Reports . Switch off old alert table for Device groups We have removed the alert table with all its underlying code from the Group Management Center .","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.25.20/#bug-fixes","text":"Fixed incorrect Hide key (hex) text field behavior We have fixed the behavior of the PSK key text field and the eye icon so that when the hex key is hidden, the displayed eye icon is closed (and remains open otherwise). Fixed the select action in task templates We have fixed the behavior of the select checkbox in the Task templates view so that now every new selection clears the previous one. Fixed TaskReports API endpoints always returning empty value in translation mode We have fixed the GET /taskReports and GET /taskReports/moreReports API endpoints so that both endpoints now return proper values of task reports. Fixed enforcing at least one observation parameter when setting and observation We have removed the validation which enforced adding at least one parameter when setting an observation on a device data model. Now, all observation parameters are optional as per the OMA LwM2M specification . Also, the limit of Not more often than once every and At least once every has been lowered to 5 seconds. Fixed allowing for uploading non-image files as device images We have added a validation when uploading a file for a device image which checks if the file is actually in an image format.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.26.0/","text":"v2022.26.0 # Previous version: v2022.25.20 Enhancements # Device registration status We have added Never connected status for devices that have never connected to the server. Also, the Clear DTLS context and Refresh data model actions are now disabled for devices with such status. Save user selections in the Dashboard view We have improved the Dashboard view so that the selected time range and sections expansion status in the Dashboard view does not reset upon each page reload. These settings are now locally stored in the user\u2019s browser. Add permissions to the Device Center We have introduced a new set of user permissions for the Device Center . Users without appropriate permissions will only have read-only access to Device Center . Edit permissions can be defined for the following actions: using device actions, viewing the PSK key value, adding and deleting devices, configuring integrations. Bug Fixes # Fixed invalid 401 error after long-lasting operations We have fixed the invalid 401 error , which occurred after longer operations in GUI, e.g. batch device migration actions lasting longer than five minutes. Fixed devices being moved to root domain after bootstrap We have fixed devices being moved to the root domain instead of the designated one after successfully connecting via bootstrap. This occurred if both API translation mode and opaque device ID were enabled. Fixed unwarranted device full register (v2022.26.1) We have fixed the issue with EU Cloud devices sending Register messages instead of the expected Register Updates . The root cause of the issue was incorrect internal load balancing. Introducing DTLS Connection ID support in future releases will further resolve this issue. Documentation # Swagger documentation for V3 API endpoints We have created documentation for the V3 API endpoints in Swagger. Descriptions as well as examples have been provided for V3 API methods. User management documentation update We have added sections in the User Guide explaining how to grant or revoke administrative access to the system for particular users.","title":"v2022.26.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.26.0/#v2022260","text":"Previous version: v2022.25.20","title":"v2022.26.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.26.0/#enhancements","text":"Device registration status We have added Never connected status for devices that have never connected to the server. Also, the Clear DTLS context and Refresh data model actions are now disabled for devices with such status. Save user selections in the Dashboard view We have improved the Dashboard view so that the selected time range and sections expansion status in the Dashboard view does not reset upon each page reload. These settings are now locally stored in the user\u2019s browser. Add permissions to the Device Center We have introduced a new set of user permissions for the Device Center . Users without appropriate permissions will only have read-only access to Device Center . Edit permissions can be defined for the following actions: using device actions, viewing the PSK key value, adding and deleting devices, configuring integrations.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.26.0/#bug-fixes","text":"Fixed invalid 401 error after long-lasting operations We have fixed the invalid 401 error , which occurred after longer operations in GUI, e.g. batch device migration actions lasting longer than five minutes. Fixed devices being moved to root domain after bootstrap We have fixed devices being moved to the root domain instead of the designated one after successfully connecting via bootstrap. This occurred if both API translation mode and opaque device ID were enabled. Fixed unwarranted device full register (v2022.26.1) We have fixed the issue with EU Cloud devices sending Register messages instead of the expected Register Updates . The root cause of the issue was incorrect internal load balancing. Introducing DTLS Connection ID support in future releases will further resolve this issue.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.26.0/#documentation","text":"Swagger documentation for V3 API endpoints We have created documentation for the V3 API endpoints in Swagger. Descriptions as well as examples have been provided for V3 API methods. User management documentation update We have added sections in the User Guide explaining how to grant or revoke administrative access to the system for particular users.","title":"Documentation"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.27.0/","text":"v2022.27.0 # Previous version: v2022.26.0 Enhancements # Adjust width of the PSK fields in the configuration tab We have adjusted the width of the PSK key fields in the Configuration tab of the Device Center to accommodate longer keys in the hex format and display them properly. Differentiate error codes in GET taskReports API method We have introduced differentiating error codes for the GET /taskReports/{taskId}/{deviceId} task report API so that responses for unfound tasks (4040) and not executed tasks (4041) are now different. Bug Fixes # Fixed no translation for key Software Management We have fixed the translation for the /9/ Software Management object key by updating the key Software Management with LWM2M Software Management in the default platform dialect. Fixed incorrectly updated textual chart data in Dashboard We have fixed the behavior of the textual (Gantt) chart in the Dashboard widgets so that it is correctly updated after both automatic and manual data refresh. Fixed notifications in JSON generate errors We have fixed the mechanism of parsing notifications sent by the device when notifications in the JSON format are set. Fixed Incorrect DTLS/TLS Identity for PSK bootstrap profile We have fixed DTLS/TLS identity generation during bootstrap so that it is equal to the endpoint name. Previously, some domain configurations resulted in unwarranted inclusion of deviceID as a prefix. Fixed observations with no attributes not recognized as set up in the data model We have fixed the behavior of observations set without any attributes so that they are now correctly displayed in the Device Center . Also, the Send notifications section when setting observations is now enabled by default.","title":"v2022.27.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.27.0/#v2022270","text":"Previous version: v2022.26.0","title":"v2022.27.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.27.0/#enhancements","text":"Adjust width of the PSK fields in the configuration tab We have adjusted the width of the PSK key fields in the Configuration tab of the Device Center to accommodate longer keys in the hex format and display them properly. Differentiate error codes in GET taskReports API method We have introduced differentiating error codes for the GET /taskReports/{taskId}/{deviceId} task report API so that responses for unfound tasks (4040) and not executed tasks (4041) are now different.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.27.0/#bug-fixes","text":"Fixed no translation for key Software Management We have fixed the translation for the /9/ Software Management object key by updating the key Software Management with LWM2M Software Management in the default platform dialect. Fixed incorrectly updated textual chart data in Dashboard We have fixed the behavior of the textual (Gantt) chart in the Dashboard widgets so that it is correctly updated after both automatic and manual data refresh. Fixed notifications in JSON generate errors We have fixed the mechanism of parsing notifications sent by the device when notifications in the JSON format are set. Fixed Incorrect DTLS/TLS Identity for PSK bootstrap profile We have fixed DTLS/TLS identity generation during bootstrap so that it is equal to the endpoint name. Previously, some domain configurations resulted in unwarranted inclusion of deviceID as a prefix. Fixed observations with no attributes not recognized as set up in the data model We have fixed the behavior of observations set without any attributes so that they are now correctly displayed in the Device Center . Also, the Send notifications section when setting observations is now enabled by default.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.3.2/","text":"v2022.3.2 # Previous version: v2021.24.5 Enhancements # New design and search engine for User Guide We have introduced a new design that changes the look and feel of the Coiote IoT DM User Guide by switching from the Sphinx tool to the MkDocs documentation generator. Thanks to this, the search engine is improved to bring more accuracy to your search results. Also, navigating document sections is now easier with the new clickable table of contents on the right-hand side. Improved logic and added search in device variables management We have improved the logic of the device variables management in DMC - a view that is used as part of the Protocol tests functionality. Also, we have added a possibility to search by name and value for both single and group variables. Bug Fixes # Fixes in Hyperscaler Integration Center view We have introduced a few changes to improve the UX and performance of HIC: The state of the devices list tab is now reloading when changing the domain. Adding/editing/deleting integration configurations is now performed while still inside the dialog window for each action. A 1000-character validator has been added to all fields in the integration configuration It's now possible to copy and preview inherited templates when the user is in a domain lower than that in which a given template was created. Fixed stepper component We have adapted the stepper component so that its appearance is in line with the design system guidelines for Coiote IoT DM.","title":"v2022.3.2"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.3.2/#v202232","text":"Previous version: v2021.24.5","title":"v2022.3.2"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.3.2/#enhancements","text":"New design and search engine for User Guide We have introduced a new design that changes the look and feel of the Coiote IoT DM User Guide by switching from the Sphinx tool to the MkDocs documentation generator. Thanks to this, the search engine is improved to bring more accuracy to your search results. Also, navigating document sections is now easier with the new clickable table of contents on the right-hand side. Improved logic and added search in device variables management We have improved the logic of the device variables management in DMC - a view that is used as part of the Protocol tests functionality. Also, we have added a possibility to search by name and value for both single and group variables.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.3.2/#bug-fixes","text":"Fixes in Hyperscaler Integration Center view We have introduced a few changes to improve the UX and performance of HIC: The state of the devices list tab is now reloading when changing the domain. Adding/editing/deleting integration configurations is now performed while still inside the dialog window for each action. A 1000-character validator has been added to all fields in the integration configuration It's now possible to copy and preview inherited templates when the user is in a domain lower than that in which a given template was created. Fixed stepper component We have adapted the stepper component so that its appearance is in line with the design system guidelines for Coiote IoT DM.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.5.3/","text":"v2022.5.3 # Previous version: v2022.3.2 Features # LwM2M CBOR support Coiote IoT DM now supports LwM2M CBOR, a new encoding format that was introduced in the Lightweight M2M 1.2 specification . It allows to significantly reduce the payload size of the Composite operations (Composite Read, Composite Write, Composite Observe). Kafka producer Kafka is a new property category in the Domain properties view. By setting the properties, you create a Kafka producer that enables you to forward data from devices to your Kafka broker. Enhancements # New design of the Device test repository We\u2019ve introduced a new look and a few changes to improve the UX of the Device tests repository: The Add test button now has two options. You can add a test manually or import tests from a .conf file. Better UI of the search, filter, delete, and mass delete actions. The Preview test option is now available from the context menu. Bug Fixes # HTTP status code 400 Fixed a bug where REST API returned the HTTP status code 500 instead of 400. Now the correct 400 status code is returned in cases when, for example, a DTLS identity is already taken, when PSK contains an odd number of characters, or for the PUT/devices request.","title":"v2022.5.3"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.5.3/#v202253","text":"Previous version: v2022.3.2","title":"v2022.5.3"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.5.3/#features","text":"LwM2M CBOR support Coiote IoT DM now supports LwM2M CBOR, a new encoding format that was introduced in the Lightweight M2M 1.2 specification . It allows to significantly reduce the payload size of the Composite operations (Composite Read, Composite Write, Composite Observe). Kafka producer Kafka is a new property category in the Domain properties view. By setting the properties, you create a Kafka producer that enables you to forward data from devices to your Kafka broker.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.5.3/#enhancements","text":"New design of the Device test repository We\u2019ve introduced a new look and a few changes to improve the UX of the Device tests repository: The Add test button now has two options. You can add a test manually or import tests from a .conf file. Better UI of the search, filter, delete, and mass delete actions. The Preview test option is now available from the context menu.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.5.3/#bug-fixes","text":"HTTP status code 400 Fixed a bug where REST API returned the HTTP status code 500 instead of 400. Now the correct 400 status code is returned in cases when, for example, a DTLS identity is already taken, when PSK contains an odd number of characters, or for the PUT/devices request.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.7.3/","text":"v2022.7.3 # Previous version: v2022.5.3 Enhancements # More formats in the XML Tasks We\u2019ve added a new option in the readResource XML Task. You can now specify the format in which the file content should be read. The available formats are UTF-8 (default) and binary (reads data into a hex string). Furthermore, the REST tag now has the outBinary subtag. This means the payload of HTTP responses can be not only in JSON but also binary. New features in the Device test repository SEND messages You can now record and expect SEND messages when running your device tests. Previously, the record and expectation functionalities were only available for the Notify operations. To run the Start Send recording and Expect Send tasks, go to Device test repository > Server simulator . Click Add test > Add test manually and then select the relevant task from the Action list drop-down menu. In addition, the Send option was added to the Wait for uplink request task. Creation and modification dates The Created and Last modified columns have been added to the Device test repository view . If no creation and modification dates are found, then the time of the migration to the new version of Coiote IoT DM is set. Download device tests You can download a single test or multiple tests as a .conf file. To do so, select the necessary tests from the list and click Download test from the context menu. Bug fixes # Fixed a bug where uploading large CSV files failed if it took longer than one minute. Fixed a bug where Coiote IoT DM sometimes didn\u2019t reply to Register Update.","title":"v2022.7.3"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.7.3/#v202273","text":"Previous version: v2022.5.3","title":"v2022.7.3"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.7.3/#enhancements","text":"More formats in the XML Tasks We\u2019ve added a new option in the readResource XML Task. You can now specify the format in which the file content should be read. The available formats are UTF-8 (default) and binary (reads data into a hex string). Furthermore, the REST tag now has the outBinary subtag. This means the payload of HTTP responses can be not only in JSON but also binary. New features in the Device test repository SEND messages You can now record and expect SEND messages when running your device tests. Previously, the record and expectation functionalities were only available for the Notify operations. To run the Start Send recording and Expect Send tasks, go to Device test repository > Server simulator . Click Add test > Add test manually and then select the relevant task from the Action list drop-down menu. In addition, the Send option was added to the Wait for uplink request task. Creation and modification dates The Created and Last modified columns have been added to the Device test repository view . If no creation and modification dates are found, then the time of the migration to the new version of Coiote IoT DM is set. Download device tests You can download a single test or multiple tests as a .conf file. To do so, select the necessary tests from the list and click Download test from the context menu.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.7.3/#bug-fixes","text":"Fixed a bug where uploading large CSV files failed if it took longer than one minute. Fixed a bug where Coiote IoT DM sometimes didn\u2019t reply to Register Update.","title":"Bug fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.8.2/","text":"v2022.8.2 # Previous version: v2022.7.3 Enhancements # UDP connector in standalone mode or disabled We have removed the option of embedding the UDP connector within the Coiote IoT DM main system process. The UDP connector can be now either disabled or work in standalone mode. When disabling, there is no need for building a new package - setting a single config property in cdm.conf is enough: udpConnector.mode = Disabled # Disabled or Enabled Simplified setup of AWS integration We have simplified the setup of the AWS integration. Now building and updating new lambdas is automated using one configuration template with all the required lambdas and dependencies. The updated integration guide can be found here . Modification and creation dates in Device test repository We have added modification and creation dates as new columns in the Device test repository. Updating user properties via API PATCH method We have added a new PATCH method to the Users API. This allows for updating the following user properties via API: emailVerified , userEnabled , domain , password , roles , permissions , tosAccepted .","title":"v2022.8.2"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.8.2/#v202282","text":"Previous version: v2022.7.3","title":"v2022.8.2"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.8.2/#enhancements","text":"UDP connector in standalone mode or disabled We have removed the option of embedding the UDP connector within the Coiote IoT DM main system process. The UDP connector can be now either disabled or work in standalone mode. When disabling, there is no need for building a new package - setting a single config property in cdm.conf is enough: udpConnector.mode = Disabled # Disabled or Enabled Simplified setup of AWS integration We have simplified the setup of the AWS integration. Now building and updating new lambdas is automated using one configuration template with all the required lambdas and dependencies. The updated integration guide can be found here . Modification and creation dates in Device test repository We have added modification and creation dates as new columns in the Device test repository. Updating user properties via API PATCH method We have added a new PATCH method to the Users API. This allows for updating the following user properties via API: emailVerified , userEnabled , domain , password , roles , permissions , tosAccepted .","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.9.2/","text":"v2022.9.2 # Previous version: v2022.8.2 Enhancements # Edit device tests You can now go to edit a test directly from the Device test repository . Select the necessary test from the list and click Edit test from the context menu. Please note that not all device tests are editable.","title":"v2022.9.2"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.9.2/#v202292","text":"Previous version: v2022.8.2","title":"v2022.9.2"},{"location":"Coiote_IoT_DM/Release_Notes/v2022.9.2/#enhancements","text":"Edit device tests You can now go to edit a test directly from the Device test repository . Select the necessary test from the list and click Edit test from the context menu. Please note that not all device tests are editable.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.10.0/","text":"v2023.10.0 # Previous version: v2023.9.0 Enhancements # Hide change password functionality for SSO users We have removed an unintended functionality. Single sign-on users no longer have access to changing their password through the platform interface. Bug Fixes # Fix Device Inventory pagination issues We have fixed issues with pagination in the Device Inventory , which occurred after returning to that view from Device Center . Bootstrap devices are now properly filtered and the interface shows accurate information. Fix DTLS session resumption We have fixed an issue with DTLS session resumption failing after NAT expiration, even if replication was enabled. Fix REST API user permissions We have fixed inconsistent user permissions, so that it is no longer possible for certain users to delete other users outside the scope of their domain via REST API.","title":"v2023.10.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.10.0/#v2023100","text":"Previous version: v2023.9.0","title":"v2023.10.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.10.0/#enhancements","text":"Hide change password functionality for SSO users We have removed an unintended functionality. Single sign-on users no longer have access to changing their password through the platform interface.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.10.0/#bug-fixes","text":"Fix Device Inventory pagination issues We have fixed issues with pagination in the Device Inventory , which occurred after returning to that view from Device Center . Bootstrap devices are now properly filtered and the interface shows accurate information. Fix DTLS session resumption We have fixed an issue with DTLS session resumption failing after NAT expiration, even if replication was enabled. Fix REST API user permissions We have fixed inconsistent user permissions, so that it is no longer possible for certain users to delete other users outside the scope of their domain via REST API.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.11.0/","text":"v2023.11.0 # Previous version: v2023.10.0 Enhancements # Make placeholder texts consistent We have replaced placeholder texts for search filters in the Operations center to make them consistent throughout the platform. Add FOTA status card We have added a new status card in the Firmware update tab of a given device. Add FOTA configuration info panel We have added Show configuration action to the FOTA updates list in the Device Center . The info panel for each entry contains the following properties: Firmware Update type , Firmware Update name , Notes , Image delivery method , Image transport type , URI format and Timeout . Add endpoint name message We have added explicit information in the UI about the necessity for device Common Name to be the same as Endpoint name if connecting to the platform using certificates. Make search queries consistent We have reworked the search functionality in the Device Group and Device Inventory views. Previously, the fields were not working consistently as some fields searched for only exact instead of partial matches. Currently, all fields allow for filtering data via a partial match. Note that if encryption is enabled, device endpoint names can be filtered only via an exact match. Disable CSV reports download for large files We have introduced a limit (1000) for devices to be included in CSV reports export. This is to prevent the output CSV file being corrupted or incomplete for users with slow internet connection. Update read/write LwM2M Server object resources in UI We have synchronised the dialects with OMA definitions of objects, which were introduced alongside LwM2M 1.2. Object versions corresponding to LwM2M versions were updated and now appropriate device operations are presented in the UI. Bug Fixes # Fix data storage period We have fixed an issue with the Data collection domain property, which resulted in data older than the set storage period value not being removed accordingly. Fix newlines not retained in string values We have fixed an issue with newline characters being incorrectly encoded in XML values. This occasionally resulted in unwarranted line concatenation for certain string values, e.g. while editing a device resource in the Parameter tree tab. Fix REST API authentication error message We have adjusted the error message appearing when requesting a REST API token token for a non-existing user to inform about incorrect credentials. Fix OpenID Connect issue We have fixed an issue with the login domain not being updated properly for existing users logging through OpenID Connect. Fix Dashboard widgets issue We have fixed an issue with Dashboard widgets freezing and not refreshing upon hovering over a tooltip. Fix certificate name issue We have fixed an issue with trusted certificates created via device creator mistakenly receiving device ID as their name.","title":"v2023.11.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.11.0/#v2023110","text":"Previous version: v2023.10.0","title":"v2023.11.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.11.0/#enhancements","text":"Make placeholder texts consistent We have replaced placeholder texts for search filters in the Operations center to make them consistent throughout the platform. Add FOTA status card We have added a new status card in the Firmware update tab of a given device. Add FOTA configuration info panel We have added Show configuration action to the FOTA updates list in the Device Center . The info panel for each entry contains the following properties: Firmware Update type , Firmware Update name , Notes , Image delivery method , Image transport type , URI format and Timeout . Add endpoint name message We have added explicit information in the UI about the necessity for device Common Name to be the same as Endpoint name if connecting to the platform using certificates. Make search queries consistent We have reworked the search functionality in the Device Group and Device Inventory views. Previously, the fields were not working consistently as some fields searched for only exact instead of partial matches. Currently, all fields allow for filtering data via a partial match. Note that if encryption is enabled, device endpoint names can be filtered only via an exact match. Disable CSV reports download for large files We have introduced a limit (1000) for devices to be included in CSV reports export. This is to prevent the output CSV file being corrupted or incomplete for users with slow internet connection. Update read/write LwM2M Server object resources in UI We have synchronised the dialects with OMA definitions of objects, which were introduced alongside LwM2M 1.2. Object versions corresponding to LwM2M versions were updated and now appropriate device operations are presented in the UI.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.11.0/#bug-fixes","text":"Fix data storage period We have fixed an issue with the Data collection domain property, which resulted in data older than the set storage period value not being removed accordingly. Fix newlines not retained in string values We have fixed an issue with newline characters being incorrectly encoded in XML values. This occasionally resulted in unwarranted line concatenation for certain string values, e.g. while editing a device resource in the Parameter tree tab. Fix REST API authentication error message We have adjusted the error message appearing when requesting a REST API token token for a non-existing user to inform about incorrect credentials. Fix OpenID Connect issue We have fixed an issue with the login domain not being updated properly for existing users logging through OpenID Connect. Fix Dashboard widgets issue We have fixed an issue with Dashboard widgets freezing and not refreshing upon hovering over a tooltip. Fix certificate name issue We have fixed an issue with trusted certificates created via device creator mistakenly receiving device ID as their name.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.12.0/","text":"v2023.12.0 # Previous version: v2023.11.0 Features # Improve platform theme white labeling We have improved theme white labelling consistency throughout the platform user interface. Changes include custom styling, colors, fonts and improved readability. Improve IAM login page theme We have made the IAM login page consistent with the established theme. Changes include replacing the background image. Enhancements # Improve FOTA status panel We have improved the status panel in the device Firmware update tab to properly show empty state if no FOTA task has been scheduled or run yet. Otherwise, the panel displays the latest FOTA task details: name and duration. Update LwM2M server certificates We have updated LwM2M server certificates to ensure appropriate security measures. New Anjay Demo commands We have introduced new arguments for the commands used to add a new device with the Anjay LwM2M Client Demo. It is now possible to use --identity-as-string and --key-as-string arguments , without the need to manually convert the values to hexadecimal format. Using hexadecimal string format for identity and pre-shared key is no longer required. The --alternative-logger flag ensures a cleaner output from the device. Add additional messages for each FOTA step We have added additional messages in the user interface to guide the user through the FOTA procedure and provide possible solutions in case of errors. Display platform version in the user interface In addition to the Licensing info view, information about the current platform version is now also displayed at the bottom of the menu bar. Bugfixes # Fix intermittent HTTP 500 internal server error We have fixed the issue with users receiving a HTTP 500 internal server error message after logging into the platform e.g after several hours of inactivity. Additional monitoring and filters have been introduced to rebalance the IAM query processing and prevent such errors.","title":"v2023.12.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.12.0/#v2023120","text":"Previous version: v2023.11.0","title":"v2023.12.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.12.0/#features","text":"Improve platform theme white labeling We have improved theme white labelling consistency throughout the platform user interface. Changes include custom styling, colors, fonts and improved readability. Improve IAM login page theme We have made the IAM login page consistent with the established theme. Changes include replacing the background image.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.12.0/#enhancements","text":"Improve FOTA status panel We have improved the status panel in the device Firmware update tab to properly show empty state if no FOTA task has been scheduled or run yet. Otherwise, the panel displays the latest FOTA task details: name and duration. Update LwM2M server certificates We have updated LwM2M server certificates to ensure appropriate security measures. New Anjay Demo commands We have introduced new arguments for the commands used to add a new device with the Anjay LwM2M Client Demo. It is now possible to use --identity-as-string and --key-as-string arguments , without the need to manually convert the values to hexadecimal format. Using hexadecimal string format for identity and pre-shared key is no longer required. The --alternative-logger flag ensures a cleaner output from the device. Add additional messages for each FOTA step We have added additional messages in the user interface to guide the user through the FOTA procedure and provide possible solutions in case of errors. Display platform version in the user interface In addition to the Licensing info view, information about the current platform version is now also displayed at the bottom of the menu bar.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.12.0/#bugfixes","text":"Fix intermittent HTTP 500 internal server error We have fixed the issue with users receiving a HTTP 500 internal server error message after logging into the platform e.g after several hours of inactivity. Additional monitoring and filters have been introduced to rebalance the IAM query processing and prevent such errors.","title":"Bugfixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.14.0/","text":"v2023.14.0 # Previous version: v2023.12.0 Features # Configure common PSK secret We have configured a common PSK secret for platform installations and ensured appropriate security measures. Implement SIM-based unique PSK store We have implemented a PSK store able to read pre-shared keys from a SIM representation. This allows for bootstrap communication to be used by devices after SIM OTA operation. Implement separate certification sources We have implemented a possibility to use separate certificates for bootstrap and management server. It is now possible to trust device DTLS certificates only during bootstrap communication and not during management communication. Adjust bootstrap task for Common PSK flow - first iteration We have added a custom bootstrap task to account for a separate domain for auto-onboarding devices. Now, automatically added devices correctly complete the bootstrap procedure and have management interface security configured. Enhancements # Add Copy FOTA action We have added a Copy action to Updates list entries in the device Firmware update tab for both Basic and Multicomponent FOTA. The action serves as a shortcut, as it opens the FOTA creator on the first step and sets all fields to the values of the copied entry. Add SIM-based security information We have added info about SIM-based security settings in the old Device Management Center view. It is now displayed along with the standard security settings configuration info. Bugfixes # Allow empty string input in resources We have adjusted field validation in the new Device Center view, so as to make an empty string a valid value for resources. REST API # Removed deprecated api endpoint for serching users REST API endpoint GET /users has been removed as it was deprecated and not working with current users management. The only endpoint for searching usernames is now GET /users/search/usernames","title":"v2023.14.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.14.0/#v2023140","text":"Previous version: v2023.12.0","title":"v2023.14.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.14.0/#features","text":"Configure common PSK secret We have configured a common PSK secret for platform installations and ensured appropriate security measures. Implement SIM-based unique PSK store We have implemented a PSK store able to read pre-shared keys from a SIM representation. This allows for bootstrap communication to be used by devices after SIM OTA operation. Implement separate certification sources We have implemented a possibility to use separate certificates for bootstrap and management server. It is now possible to trust device DTLS certificates only during bootstrap communication and not during management communication. Adjust bootstrap task for Common PSK flow - first iteration We have added a custom bootstrap task to account for a separate domain for auto-onboarding devices. Now, automatically added devices correctly complete the bootstrap procedure and have management interface security configured.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.14.0/#enhancements","text":"Add Copy FOTA action We have added a Copy action to Updates list entries in the device Firmware update tab for both Basic and Multicomponent FOTA. The action serves as a shortcut, as it opens the FOTA creator on the first step and sets all fields to the values of the copied entry. Add SIM-based security information We have added info about SIM-based security settings in the old Device Management Center view. It is now displayed along with the standard security settings configuration info.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.14.0/#bugfixes","text":"Allow empty string input in resources We have adjusted field validation in the new Device Center view, so as to make an empty string a valid value for resources.","title":"Bugfixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.14.0/#rest-api","text":"Removed deprecated api endpoint for serching users REST API endpoint GET /users has been removed as it was deprecated and not working with current users management. The only endpoint for searching usernames is now GET /users/search/usernames","title":"REST API"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.15.0/","text":"v2023.15.0 # Previous version: v2023.14.0 Enhancements # Add FOTA steps preview We have added a new Firmware Update Flow Preview card for basic and multicomponent Firmware Update views. The steps summary depends on the image delivery method and the number of components. Display firmware version We have added information about the current firmware version in the FOTA panel and Device Center. Add abort FOTA action We have added the possibility to abort a firmware update already in progress. Bug Fixes # Fix Azure integration We have fixed an issue with adding devices via Azure Hub and Azure Central on some cloud installations. The devices are now tagged properly and integrate with Azure as expected.","title":"v2023.15.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.15.0/#v2023150","text":"Previous version: v2023.14.0","title":"v2023.15.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.15.0/#enhancements","text":"Add FOTA steps preview We have added a new Firmware Update Flow Preview card for basic and multicomponent Firmware Update views. The steps summary depends on the image delivery method and the number of components. Display firmware version We have added information about the current firmware version in the FOTA panel and Device Center. Add abort FOTA action We have added the possibility to abort a firmware update already in progress.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.15.0/#bug-fixes","text":"Fix Azure integration We have fixed an issue with adding devices via Azure Hub and Azure Central on some cloud installations. The devices are now tagged properly and integrate with Azure as expected.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.16.0/","text":"v2023.16.0 # Previous version: v2023.15.0 Enhancements # Implement separate certification sources We have implemented a possiblity to use separate certificates for bootstrap and management server. It is now possible to trust device DTLS certificates only during bootstrap communication and not during management communication. Bug Fixes # Fix FOTA steps order We have fixed the order of FOTA SubSteps displayed in the FOTA execution status. The steps are now sorted by the order in which they are executed. Fix Device Center refresh We have introduced changes to the refresh mechanism to avoid the request being canceled immediately if the response is not returned within 1 second. It allows for introducing a 1-second refresh, which ensures smooth user experience. Fix cluster routing We have fixed bugged cluster routing on some installations with opaque device IDs. Fix an issue with reports returning empty value We have fixed an issue with reports scheduled using the device data model returning an empty value for expressions with the \"dm\" object. Now, the value is displayed correctly. Fix historical monitoring data access We have ensured that all previous monitoring data is removed after a device migrates from a domain. This ensures, that historical data is returned only from domains to which the user has access. Fix the EnsureObservationTask during FOTA We have fixed an issue with EnsureObservationTask not working during the observation-based FOTA. We have added a setting observation in certain parts of the FOTA task, to ensure that the system carries out the ensureObservationTask.","title":"v2023.16.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.16.0/#v2023160","text":"Previous version: v2023.15.0","title":"v2023.16.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.16.0/#enhancements","text":"Implement separate certification sources We have implemented a possiblity to use separate certificates for bootstrap and management server. It is now possible to trust device DTLS certificates only during bootstrap communication and not during management communication.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.16.0/#bug-fixes","text":"Fix FOTA steps order We have fixed the order of FOTA SubSteps displayed in the FOTA execution status. The steps are now sorted by the order in which they are executed. Fix Device Center refresh We have introduced changes to the refresh mechanism to avoid the request being canceled immediately if the response is not returned within 1 second. It allows for introducing a 1-second refresh, which ensures smooth user experience. Fix cluster routing We have fixed bugged cluster routing on some installations with opaque device IDs. Fix an issue with reports returning empty value We have fixed an issue with reports scheduled using the device data model returning an empty value for expressions with the \"dm\" object. Now, the value is displayed correctly. Fix historical monitoring data access We have ensured that all previous monitoring data is removed after a device migrates from a domain. This ensures, that historical data is returned only from domains to which the user has access. Fix the EnsureObservationTask during FOTA We have fixed an issue with EnsureObservationTask not working during the observation-based FOTA. We have added a setting observation in certain parts of the FOTA task, to ensure that the system carries out the ensureObservationTask.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.17.0/","text":"v2023.17.0 # Previous version: v2023.16.0 Bug Fixes # Fix disappearing dialog windows We have fixed an issue with certain dialog windows occasionally disappearing after performing search action. Fix Dashboard widgets issue We have fixed an issue with the Dashboard loading indefinitely after domain dialect change. Now, the widgets are displayed only for resources that exist in dialect of current domain. Any monitoring data collected prior to dialect change is preserved.","title":"v2023.17.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.17.0/#v2023170","text":"Previous version: v2023.16.0","title":"v2023.17.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.17.0/#bug-fixes","text":"Fix disappearing dialog windows We have fixed an issue with certain dialog windows occasionally disappearing after performing search action. Fix Dashboard widgets issue We have fixed an issue with the Dashboard loading indefinitely after domain dialect change. Now, the widgets are displayed only for resources that exist in dialect of current domain. Any monitoring data collected prior to dialect change is preserved.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.19.0/","text":"v2023.19.0 # Previous version: v2023.17.0 Enhancements # Improve FOTA error reporting We have improved error reporting with information gained from the \"UpdateResult\" resource value. Error messages in the FOTA steps include now the information based on the error or warning message logs from the LwM2M resources. Add reCAPTCHA to IAM registration We have added reCAPTCHA to the IAM registration page. It helps avoid the registration of automatic or non-valuable accounts. Bug Fixes # Fixed issue with logging large set requests We have fixed the issue with logging large set requests. The value size is now limited to 10 000 characters in the log and error messages. Fix the DELETE method of extensions/azureIotHub We have implemented mechanisms to avoid an error when using the DELETE method of extensions/azureIotHub when no integration is configured for the user domain. Now, the method is only called when AzureHubConfig is present. Fix an issue with the POST /resources method We have fixed the issue with POST /resources endpoint accepting an empty id field as a resource id. Now, it is impossible to initialize an entity with empty id and name fields. Fix issue with Multi-Component FOTA We have fixed the issue with Multi-Component FOTA not working if the device was in LwM2M QUEUE mode. Now, Multi-Component FOTA correctly observes devices in QUEUE mode.","title":"v2023.19.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.19.0/#v2023190","text":"Previous version: v2023.17.0","title":"v2023.19.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.19.0/#enhancements","text":"Improve FOTA error reporting We have improved error reporting with information gained from the \"UpdateResult\" resource value. Error messages in the FOTA steps include now the information based on the error or warning message logs from the LwM2M resources. Add reCAPTCHA to IAM registration We have added reCAPTCHA to the IAM registration page. It helps avoid the registration of automatic or non-valuable accounts.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.19.0/#bug-fixes","text":"Fixed issue with logging large set requests We have fixed the issue with logging large set requests. The value size is now limited to 10 000 characters in the log and error messages. Fix the DELETE method of extensions/azureIotHub We have implemented mechanisms to avoid an error when using the DELETE method of extensions/azureIotHub when no integration is configured for the user domain. Now, the method is only called when AzureHubConfig is present. Fix an issue with the POST /resources method We have fixed the issue with POST /resources endpoint accepting an empty id field as a resource id. Now, it is impossible to initialize an entity with empty id and name fields. Fix issue with Multi-Component FOTA We have fixed the issue with Multi-Component FOTA not working if the device was in LwM2M QUEUE mode. Now, Multi-Component FOTA correctly observes devices in QUEUE mode.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.22.0/","text":"v2023.22.0 # Previous version: v2023.19.0 Features # Implement IoT Northbound Interface We have implemented IoT Northbound Interface in the form of Webhook and Kafka event handlers. This feature enables the users to push the device data to external services. The event handler creator is accessible through Integrations > Device Integration Center . Bug Fixes # Fix bugs in FOTA creator We have fixed the position jump of the preview component in the FOTA creator. We have also changed the searching in the files side nav to 'contains' instead of 'prefix'. Fix various FOTA errors We have fixed the width of a component in the multicomponent FOTA creator. We have also changed the tooltip information that appears while hovering on the plus icon in the multicomponent FOTA creator and updated the error snackbar content. Fix missing default LwM2M servers We have fixed an issue with missing default LwM2M servers that occurred when a domain or a group was created. The default LwM2M servers are now displayed properly in Administration -> LwM2M Servers. Fix security automatically switching to Certificate We have fixed an issue with the device security mode automatically switching to Certificate after changing it to PSK when the device was added using a certificate. We blocked the possibility of connecting the device using a certificate while the device has another security mode selected. Introduce endpoint name length validation via REST API We have implemented the mechanism to validate endpoint name length via REST API. Endpoint name length is now limited to 150 characters. Fix inaccurate error code in REST API We have fixed 500 error code with no description being returned if search queries on an encrypted field were used. Such queries now return a 400 (bad request) error code as intended. Fix misleading server error 500 code We have fixed an issue with the endpoint GET /api/coiotedm/v3/groups/test returning an internal server error 500 code if the provided group ID was incorrect. Invalid format of the group ID in a request now causes the server to return error 400 (Bad request). Fix 500 error on returning to Device Inventory We have handled the HTTP 500 error that appeared when returning to Device Inventory from IAM if any filters were applied. Now, the user is redirected to the appropriate page. Fix HIC template names non-uniqueness We have fixed issues with the user interface that occurred when copying a template in Integrations > Hyperscalers Integration Center and changing its name to one that already exists. Duplicate template names are not allowed anymore. Add endpoint name length validation in CSV import We have fixed an issue with the CSV import form allowing to import devices with long endpoint names. The \"endpoint name\" property of a device now has a limit of up to 200 characters.","title":"v2023.22.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.22.0/#v2023220","text":"Previous version: v2023.19.0","title":"v2023.22.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.22.0/#features","text":"Implement IoT Northbound Interface We have implemented IoT Northbound Interface in the form of Webhook and Kafka event handlers. This feature enables the users to push the device data to external services. The event handler creator is accessible through Integrations > Device Integration Center .","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.22.0/#bug-fixes","text":"Fix bugs in FOTA creator We have fixed the position jump of the preview component in the FOTA creator. We have also changed the searching in the files side nav to 'contains' instead of 'prefix'. Fix various FOTA errors We have fixed the width of a component in the multicomponent FOTA creator. We have also changed the tooltip information that appears while hovering on the plus icon in the multicomponent FOTA creator and updated the error snackbar content. Fix missing default LwM2M servers We have fixed an issue with missing default LwM2M servers that occurred when a domain or a group was created. The default LwM2M servers are now displayed properly in Administration -> LwM2M Servers. Fix security automatically switching to Certificate We have fixed an issue with the device security mode automatically switching to Certificate after changing it to PSK when the device was added using a certificate. We blocked the possibility of connecting the device using a certificate while the device has another security mode selected. Introduce endpoint name length validation via REST API We have implemented the mechanism to validate endpoint name length via REST API. Endpoint name length is now limited to 150 characters. Fix inaccurate error code in REST API We have fixed 500 error code with no description being returned if search queries on an encrypted field were used. Such queries now return a 400 (bad request) error code as intended. Fix misleading server error 500 code We have fixed an issue with the endpoint GET /api/coiotedm/v3/groups/test returning an internal server error 500 code if the provided group ID was incorrect. Invalid format of the group ID in a request now causes the server to return error 400 (Bad request). Fix 500 error on returning to Device Inventory We have handled the HTTP 500 error that appeared when returning to Device Inventory from IAM if any filters were applied. Now, the user is redirected to the appropriate page. Fix HIC template names non-uniqueness We have fixed issues with the user interface that occurred when copying a template in Integrations > Hyperscalers Integration Center and changing its name to one that already exists. Duplicate template names are not allowed anymore. Add endpoint name length validation in CSV import We have fixed an issue with the CSV import form allowing to import devices with long endpoint names. The \"endpoint name\" property of a device now has a limit of up to 200 characters.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.24.0/","text":"v2023.24.0 # Previous version: v2023.22.0 Enhancements # Enable LwM2M to use different content-types We have introduced an option to specify content-type for a particular version of the LwM2M protocol. Devices using content-type different than the previously default TLV are able to successfully connect and perform basic operations. Bug Fixes # Fix ConnectionLost error during FOTA We have fixed the issue with the ConnectionLost error occurring while performing FOTA using the CoAP protocol. Both basic and multicomponent FOTA work correctly for CoAP over TCP, and CoAP over UDP. Limit filename length in FOTA creators We have limited the length of filenames that can be uploaded in FOTA creators to up to 150 characters to prevent user inteface issues. Fix HIC template creation We have fixed the data validator not detecting errors upon page refresh in the Hyperscaler Integration Center template creator. Now, it is not possible to go to the next step with undetected validation errors. Fix logs not showing for observations API We have fixed the issue with logs not showing when sending requests on the endpoint /observations/device/\\{deviceId}/\\{path} . Now, it is possible to use both numerical and alphabetic values for the \"path\" filter. Fix old Monitoring view crashes We have fixed the old Monitoring view causing web browser crashes and displaying inaccurate data. Fix user token rejection error We have fixed an issue with the platform failing and responding with an error when IAM rejects a user token. The user is now redirected to the login page in case their token is rejected.","title":"v2023.24.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.24.0/#v2023240","text":"Previous version: v2023.22.0","title":"v2023.24.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.24.0/#enhancements","text":"Enable LwM2M to use different content-types We have introduced an option to specify content-type for a particular version of the LwM2M protocol. Devices using content-type different than the previously default TLV are able to successfully connect and perform basic operations.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.24.0/#bug-fixes","text":"Fix ConnectionLost error during FOTA We have fixed the issue with the ConnectionLost error occurring while performing FOTA using the CoAP protocol. Both basic and multicomponent FOTA work correctly for CoAP over TCP, and CoAP over UDP. Limit filename length in FOTA creators We have limited the length of filenames that can be uploaded in FOTA creators to up to 150 characters to prevent user inteface issues. Fix HIC template creation We have fixed the data validator not detecting errors upon page refresh in the Hyperscaler Integration Center template creator. Now, it is not possible to go to the next step with undetected validation errors. Fix logs not showing for observations API We have fixed the issue with logs not showing when sending requests on the endpoint /observations/device/\\{deviceId}/\\{path} . Now, it is possible to use both numerical and alphabetic values for the \"path\" filter. Fix old Monitoring view crashes We have fixed the old Monitoring view causing web browser crashes and displaying inaccurate data. Fix user token rejection error We have fixed an issue with the platform failing and responding with an error when IAM rejects a user token. The user is now redirected to the login page in case their token is rejected.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.25.2/","text":"v2023.25.2 # Previous version: v2023.24.0 Bug Fixes # Fix device count bug We have fixed an issue with the Devices fully operable card in Operations Center . Now, the device count is displayed properly. Limit the summary field in TaskReports We have limited the summary field size to prevent data overflow and glitches in the user interface. Now, the summary must be shorter than 10000 characters. Fix empty input in Device Creator We have fixed an issue with the Search by input in Device Creator displaying the option to clear the content while empty. Now, the option does not appear in the input with no content. Introduce API changes notification mechanism We have introduced a mechanism to notify about changes in API. Thanks to this mechanism, it is easier to detect that an update of the API version is needed. Fix issue with LegacyMonitoringData API We have fixed an issue with GET /monitoringData/moreSamples endpoint returning an error. Now, the request to the endpoint returns data correctly.","title":"v2023.25.2"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.25.2/#v2023252","text":"Previous version: v2023.24.0","title":"v2023.25.2"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.25.2/#bug-fixes","text":"Fix device count bug We have fixed an issue with the Devices fully operable card in Operations Center . Now, the device count is displayed properly. Limit the summary field in TaskReports We have limited the summary field size to prevent data overflow and glitches in the user interface. Now, the summary must be shorter than 10000 characters. Fix empty input in Device Creator We have fixed an issue with the Search by input in Device Creator displaying the option to clear the content while empty. Now, the option does not appear in the input with no content. Introduce API changes notification mechanism We have introduced a mechanism to notify about changes in API. Thanks to this mechanism, it is easier to detect that an update of the API version is needed. Fix issue with LegacyMonitoringData API We have fixed an issue with GET /monitoringData/moreSamples endpoint returning an error. Now, the request to the endpoint returns data correctly.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.26.1/","text":"v2023.26.1 # Previous version: v2023.25.2 Features # Implement User management We have implemented a User management panel. It is accessible through Administration > User management . Implement LoRaWAN Gateway We have implemented the possibility of connecting LoRaWAN gateways to the platform through the integration with The Things Stack account. The users can now provision LoRaWAN gateways with proper parameters by bootstrapping the device or connecting it to the management server. The feature allows adding single or multiple LoRaWAN devices. Enhancements # Implement event handler edit and copy options We have implemented the possibility to edit and copy an event handler. The edit and copy options can be accessed from the event handler table in the Device Integration Center panel. Add a new operator in XML tasks We have implemented a try-catch-finally operator in XML tasks. It allows to handle errors in XML tasks and perform cleanup operations. Validate setting observation by API We have implemented a validation mechanism for setting observations on a device using API. Trying to set an observation which does not comply with the validation criteria now results in a 400 error code. Bug Fixes # Fix issue with device tables We have fixed the issue with device tables missing entries after deleting a device. Now, the tables in User management , Device inventory and Hyperscaler Integration Center > Device list display entries correctly. Fix issue with observations on TCP devices We have fixed the issue with observations added on TCP devices. The platform did not update the resource value for devices that used TCP. Now, observations on TCP devices work correctly. Fix Raw IP option in FOTA We have fixed the RAW IP option in FOTA scheduling. The FOTA is now scheduled correctly on devices that have to use raw IP.","title":"v2023.26.1"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.26.1/#v2023261","text":"Previous version: v2023.25.2","title":"v2023.26.1"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.26.1/#features","text":"Implement User management We have implemented a User management panel. It is accessible through Administration > User management . Implement LoRaWAN Gateway We have implemented the possibility of connecting LoRaWAN gateways to the platform through the integration with The Things Stack account. The users can now provision LoRaWAN gateways with proper parameters by bootstrapping the device or connecting it to the management server. The feature allows adding single or multiple LoRaWAN devices.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.26.1/#enhancements","text":"Implement event handler edit and copy options We have implemented the possibility to edit and copy an event handler. The edit and copy options can be accessed from the event handler table in the Device Integration Center panel. Add a new operator in XML tasks We have implemented a try-catch-finally operator in XML tasks. It allows to handle errors in XML tasks and perform cleanup operations. Validate setting observation by API We have implemented a validation mechanism for setting observations on a device using API. Trying to set an observation which does not comply with the validation criteria now results in a 400 error code.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.26.1/#bug-fixes","text":"Fix issue with device tables We have fixed the issue with device tables missing entries after deleting a device. Now, the tables in User management , Device inventory and Hyperscaler Integration Center > Device list display entries correctly. Fix issue with observations on TCP devices We have fixed the issue with observations added on TCP devices. The platform did not update the resource value for devices that used TCP. Now, observations on TCP devices work correctly. Fix Raw IP option in FOTA We have fixed the RAW IP option in FOTA scheduling. The FOTA is now scheduled correctly on devices that have to use raw IP.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.27/","text":"v2023.27 # Previous version: v2023.26.1 Enhancements # Fix Swagger UI basic authorization We have fixed an issue with users being unable to authorize in Swagger UI using basic HTTP authorization. Handle identical task spawning We have introduced a mechanism to handle multiple identical tasks spawning when using TasksFromTemplates API. Now, instead of creating an identical task, the already existing task is restarted. This mechanism prevents OutOfMemory errors. Bug Fixes # Fix dropdown issue in FOTA creator We have fixed an issue with the dropdown list moving when scrolling the page in the FOTA creator view. Fix dropdown item duplication in FOTA creator We have fixed dropdown list items being duplicated in the FOTA creator view. The issue occurred when selecting from the dropdown list an item other than the default one.","title":"v2023.27"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.27/#v202327","text":"Previous version: v2023.26.1","title":"v2023.27"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.27/#enhancements","text":"Fix Swagger UI basic authorization We have fixed an issue with users being unable to authorize in Swagger UI using basic HTTP authorization. Handle identical task spawning We have introduced a mechanism to handle multiple identical tasks spawning when using TasksFromTemplates API. Now, instead of creating an identical task, the already existing task is restarted. This mechanism prevents OutOfMemory errors.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.27/#bug-fixes","text":"Fix dropdown issue in FOTA creator We have fixed an issue with the dropdown list moving when scrolling the page in the FOTA creator view. Fix dropdown item duplication in FOTA creator We have fixed dropdown list items being duplicated in the FOTA creator view. The issue occurred when selecting from the dropdown list an item other than the default one.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.28/","text":"v2023.28 # Previous version: v2023.27 Enhancements # Remove unused table column in User account We have removed the Last activity column from the Sessions table in the User account panel. The information provided in the column was unnecessary. Add refresh button in User account We have added a refresh button in the top right corner of the User account panel. The button reloads the data displayed in the panel. Apply error checking in TTS creators We have implemented error checking in TTS LoRa device creators. The errors are checked in both management and bootstrap creator views. Bug Fixes # Fix device batch removal We have fixed an issue with removing devices in batches when using the Select All option in Device inventory . Now, it is not possible to delete more than 100 devices at once without proper permissions.","title":"v2023.28"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.28/#v202328","text":"Previous version: v2023.27","title":"v2023.28"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.28/#enhancements","text":"Remove unused table column in User account We have removed the Last activity column from the Sessions table in the User account panel. The information provided in the column was unnecessary. Add refresh button in User account We have added a refresh button in the top right corner of the User account panel. The button reloads the data displayed in the panel. Apply error checking in TTS creators We have implemented error checking in TTS LoRa device creators. The errors are checked in both management and bootstrap creator views.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.28/#bug-fixes","text":"Fix device batch removal We have fixed an issue with removing devices in batches when using the Select All option in Device inventory . Now, it is not possible to delete more than 100 devices at once without proper permissions.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.29/","text":"v2023.29 # Previous version: v2023.28 Enhancements # Add explanations to Operation Center cards We have added tooltips with explanations to Operation Center cards. The tooltips explain what is included in the count of devices and alerts. Implement state storage in TTS creator We have implemented state storing in the TTS LoRa device creators. After a page refresh, the input fields retain the entered values. Bug Fixes # Fix issue with DMC panel opened in new window We have fixed an issue with missing UI elements when opening a DMC panel in a new window. The panel opened in the new tab now displays properly the top navigation bar. Fix gateway device addition via bootstrap We have fixed issues with adding a gateway device via Bootstrap. The URL is now correct and the PSK security mode works properly.","title":"v2023.29"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.29/#v202329","text":"Previous version: v2023.28","title":"v2023.29"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.29/#enhancements","text":"Add explanations to Operation Center cards We have added tooltips with explanations to Operation Center cards. The tooltips explain what is included in the count of devices and alerts. Implement state storage in TTS creator We have implemented state storing in the TTS LoRa device creators. After a page refresh, the input fields retain the entered values.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.29/#bug-fixes","text":"Fix issue with DMC panel opened in new window We have fixed an issue with missing UI elements when opening a DMC panel in a new window. The panel opened in the new tab now displays properly the top navigation bar. Fix gateway device addition via bootstrap We have fixed issues with adding a gateway device via Bootstrap. The URL is now correct and the PSK security mode works properly.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.3.0/","text":"v2023.3.0 # Previous version: v2022.27.0 Architectural Changes # Device ID compatibility translation in Device CSV import and export We have added the possibility to identify devices through methods other than providing device.id in the imported CSV file. If device.id is not available in the CSV file, it is now composed from other data ( namespace/domain , endpointName , connectorType ). New devices cannot have a device.id provided during import and it is optional for Existing devices and New and existing devices import modes. This ensures full opaque device.id configuration. Enhancements # Improve table filtering We have improved the table filters throughout the platform. We have removed legacy table filters. State of the columns is now saved in local storage and does not revert to default upon page refresh. Bug Fixes # Fix Schedule a report function in Advanced CSV exports We have fixed an error which occurred when trying to use Schedule a report function in the Advanced CSV export . Fix expressions issues in Advanced CSV exports We have fixed the device CSV export not working. We added bootstrap fields to the Simple tab and fixed export fields for DTLS. Exporting CSV files with the use of expressions also works again.","title":"v2023.3.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.3.0/#v202330","text":"Previous version: v2022.27.0","title":"v2023.3.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.3.0/#architectural-changes","text":"Device ID compatibility translation in Device CSV import and export We have added the possibility to identify devices through methods other than providing device.id in the imported CSV file. If device.id is not available in the CSV file, it is now composed from other data ( namespace/domain , endpointName , connectorType ). New devices cannot have a device.id provided during import and it is optional for Existing devices and New and existing devices import modes. This ensures full opaque device.id configuration.","title":"Architectural Changes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.3.0/#enhancements","text":"Improve table filtering We have improved the table filters throughout the platform. We have removed legacy table filters. State of the columns is now saved in local storage and does not revert to default upon page refresh.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.3.0/#bug-fixes","text":"Fix Schedule a report function in Advanced CSV exports We have fixed an error which occurred when trying to use Schedule a report function in the Advanced CSV export . Fix expressions issues in Advanced CSV exports We have fixed the device CSV export not working. We added bootstrap fields to the Simple tab and fixed export fields for DTLS. Exporting CSV files with the use of expressions also works again.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.30.0/","text":"v2023.30.0 # Previous version: v2023.29 Enhancements # Synchronize UI and API endpoints validation We have introduced validation rules for event handler endpoints in API. The endpoint validation rules for API match the rules applied in UI. New status for event handlers We have added a new status \"Failed\" for the event handlers in Data Integration Center . It indicates, that the handler has been automatically disabled because it reached the maximum number of failures. Bug Fixes # Fix device migration issue We have fixed an issue that allowed a device to migrate to another domain when using the platform in multiple browser tabs with different domains selected. Fix domain certificate error We have fixed an error with device verification that occurred when multiple domains had the same certificate. Now, the certificate verifier finds the appropriate certificates matching the device. Fix DTLS session termination We have fixed the problem with DTLS session termination when regenerating PSK. Now, the old DTLS session is not terminated immediately after generating a new PSK, but at the end of the provisioning session.","title":"v2023.30.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.30.0/#v2023300","text":"Previous version: v2023.29","title":"v2023.30.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.30.0/#enhancements","text":"Synchronize UI and API endpoints validation We have introduced validation rules for event handler endpoints in API. The endpoint validation rules for API match the rules applied in UI. New status for event handlers We have added a new status \"Failed\" for the event handlers in Data Integration Center . It indicates, that the handler has been automatically disabled because it reached the maximum number of failures.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.30.0/#bug-fixes","text":"Fix device migration issue We have fixed an issue that allowed a device to migrate to another domain when using the platform in multiple browser tabs with different domains selected. Fix domain certificate error We have fixed an error with device verification that occurred when multiple domains had the same certificate. Now, the certificate verifier finds the appropriate certificates matching the device. Fix DTLS session termination We have fixed the problem with DTLS session termination when regenerating PSK. Now, the old DTLS session is not terminated immediately after generating a new PSK, but at the end of the provisioning session.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.31/","text":"v2023.31 # Previous version: v2023.30.0 Features # Implemented API throttling We have implemented an API request rate throttling mechanism. The throttling mechanism prevents the platform from serving excessive traffic from a single user that could exhaust the platform's computing resources. The functionality can be found under Domain management > Properties > Shared . Introduce \"Send SMS wakeup\" option We have implemented a new action for single devices in Device Center . The option Send SMS wakeup sends an SMS to the device to trigger its registration update. Enhancements # Introduce retention period for FotaConfig entities We have introduced a retention mechanism for FotaConfig and DeviceFotaProgress entities. The time before entity deletion is configurable. By default, it is set to 6 months. Implement tags in event handler headers We have introduced replaceable tags for event handler headers. Variables with header values can be now used to configure headers in event handler creators. Implement event handler payload templates We have introduced templates for event handler payloads. Variables with reusable values can be now used to configure payloads in event handler creators. Bug Fixes # Required CSV import data We have fixed an issue with CSV import in Hyperscaler Integrations Center requiring deviceId in the template. Now, it requires endpointName . Unauthorized user is not logged out We have fixed an issue with an unauthorized user not being logged out from the platform. Unauthorized users are now redirected to the login page. Fix error in settingValues API We have fixed an error that occurred when trying to retrieve settingValues via API endpoint /settingValues/deviceProfile/{deviceId} . Now the results are retrieved correctly. Fix the \"Refresh data\" option We have fixed the \"Refresh data\" option in Device Center . After clicking the refresh button device information refreshes properly. Firmware update fix We have fixed an issue with a single firmware update performed from the Device Center . The process did not proceed past the \"Initializing\" step because of a missing acquiring quota status. Single-device firmware update now works properly. Make hiding columns consistent We have unified the behavior of hiding and displaying columns across the platform. After selecting a column from the column list, the list remains displayed. Selecting or clearing multiple columns at once is possible. Remove possibility to change namespace We have removed the possibility of changing the namespace in the Domain Management edit panel. Instead of the Inherited and Set own options, the inherited namespace is displayed.","title":"v2023.31"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.31/#v202331","text":"Previous version: v2023.30.0","title":"v2023.31"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.31/#features","text":"Implemented API throttling We have implemented an API request rate throttling mechanism. The throttling mechanism prevents the platform from serving excessive traffic from a single user that could exhaust the platform's computing resources. The functionality can be found under Domain management > Properties > Shared . Introduce \"Send SMS wakeup\" option We have implemented a new action for single devices in Device Center . The option Send SMS wakeup sends an SMS to the device to trigger its registration update.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.31/#enhancements","text":"Introduce retention period for FotaConfig entities We have introduced a retention mechanism for FotaConfig and DeviceFotaProgress entities. The time before entity deletion is configurable. By default, it is set to 6 months. Implement tags in event handler headers We have introduced replaceable tags for event handler headers. Variables with header values can be now used to configure headers in event handler creators. Implement event handler payload templates We have introduced templates for event handler payloads. Variables with reusable values can be now used to configure payloads in event handler creators.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.31/#bug-fixes","text":"Required CSV import data We have fixed an issue with CSV import in Hyperscaler Integrations Center requiring deviceId in the template. Now, it requires endpointName . Unauthorized user is not logged out We have fixed an issue with an unauthorized user not being logged out from the platform. Unauthorized users are now redirected to the login page. Fix error in settingValues API We have fixed an error that occurred when trying to retrieve settingValues via API endpoint /settingValues/deviceProfile/{deviceId} . Now the results are retrieved correctly. Fix the \"Refresh data\" option We have fixed the \"Refresh data\" option in Device Center . After clicking the refresh button device information refreshes properly. Firmware update fix We have fixed an issue with a single firmware update performed from the Device Center . The process did not proceed past the \"Initializing\" step because of a missing acquiring quota status. Single-device firmware update now works properly. Make hiding columns consistent We have unified the behavior of hiding and displaying columns across the platform. After selecting a column from the column list, the list remains displayed. Selecting or clearing multiple columns at once is possible. Remove possibility to change namespace We have removed the possibility of changing the namespace in the Domain Management edit panel. Instead of the Inherited and Set own options, the inherited namespace is displayed.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.32/","text":"v2023.32 # Previous version: v2023.31 Enhancements # Length limit for XML tasks We limited the allowed length of XML tasks to prevent system failure due to Out of memory state. XML Tasks can now be no longer than 100,000 characters. Remove IMSI column in HIC CSV upload We removed the IMSI column from the CSV upload in the Hyperscaler Integration Center when it should not be required. The column does not appear when the SIM processing is disabled in the configuration. Allow connectivity to DEP API We changed the internal configuration to allow connectivity to DEP API. Bug Fixes # Get XML invoker error We fixed an issue with the Get XML invoker failing on absent value even with the parameter ignoreFaults set to \"true\". The parameter ignoreFaults works properly in Get, Set, and SetAttributes invokers. Block transfer notification error We fixed the issue with sending notifications using the block transfer. The platform sends ACK for the first block as required by the block transfer specification. Fix \"Log in as client\" option We fixed the issue with the user list loaded when selecting the option \"Log in as client\". The browser retrieves the user list correctly. Change name of object Security We changed the \"LWM2M Security\" object name in the base dialect to \"LwM2M Security\" in version 1.2. The name is now consistent with the previous versions.","title":"v2023.32"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.32/#v202332","text":"Previous version: v2023.31","title":"v2023.32"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.32/#enhancements","text":"Length limit for XML tasks We limited the allowed length of XML tasks to prevent system failure due to Out of memory state. XML Tasks can now be no longer than 100,000 characters. Remove IMSI column in HIC CSV upload We removed the IMSI column from the CSV upload in the Hyperscaler Integration Center when it should not be required. The column does not appear when the SIM processing is disabled in the configuration. Allow connectivity to DEP API We changed the internal configuration to allow connectivity to DEP API.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.32/#bug-fixes","text":"Get XML invoker error We fixed an issue with the Get XML invoker failing on absent value even with the parameter ignoreFaults set to \"true\". The parameter ignoreFaults works properly in Get, Set, and SetAttributes invokers. Block transfer notification error We fixed the issue with sending notifications using the block transfer. The platform sends ACK for the first block as required by the block transfer specification. Fix \"Log in as client\" option We fixed the issue with the user list loaded when selecting the option \"Log in as client\". The browser retrieves the user list correctly. Change name of object Security We changed the \"LWM2M Security\" object name in the base dialect to \"LwM2M Security\" in version 1.2. The name is now consistent with the previous versions.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.33/","text":"v2023.33 # Previous version: v2023.32 Enhancements # Allow defining event handler templates via API We introduced the possibility to define event handler templates via API. The template definition is available as an optional field when creating, editing, or testing event handlers. Add option to change template in HIC We added the option to change the device template in Hyperscalar Integration Center . The templates are available under the tab Templates . Change Factory Unique PSK computation algorithm We changed the Factory Unique PSK computation algorithm to improve security. Bug Fixes # Fix cursors in TaskReports API We resolved the issue with retrieving TaskReports API cursor data. Data retrieval using cursors is now working correctly. Infinite spinner in device creator We fixed the issue with the infinite spinner appearing on validation with the cellular device option enabled. The infinite spinner no longer appears when validating the first step of device creation via the Management Server. Improve formatting in Monitoring view We fixed formatting issues in the Monitoring view. Long text in the title is wrapped and buttons are correctly displayed. Fix \"Back to login page\" action We fixed the issue with \"Back to login page\" action. Clicking the \"Back to login page\" button on an error page no longer causes a redirection loop. Fix FOTA via COAP+TCP connection We fixed the issue with FOTA via COAP+TCP not working when on the same port as FOTA via HTTP. FOTA via TCP/TLS is now served on different ports. Device ID displayed instead of endpoint name We switched the device ID to the endpoint name in the \"Select device to add\" option. The dropdown now displays endpoint names instead of device IDs.","title":"v2023.33"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.33/#v202333","text":"Previous version: v2023.32","title":"v2023.33"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.33/#enhancements","text":"Allow defining event handler templates via API We introduced the possibility to define event handler templates via API. The template definition is available as an optional field when creating, editing, or testing event handlers. Add option to change template in HIC We added the option to change the device template in Hyperscalar Integration Center . The templates are available under the tab Templates . Change Factory Unique PSK computation algorithm We changed the Factory Unique PSK computation algorithm to improve security.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.33/#bug-fixes","text":"Fix cursors in TaskReports API We resolved the issue with retrieving TaskReports API cursor data. Data retrieval using cursors is now working correctly. Infinite spinner in device creator We fixed the issue with the infinite spinner appearing on validation with the cellular device option enabled. The infinite spinner no longer appears when validating the first step of device creation via the Management Server. Improve formatting in Monitoring view We fixed formatting issues in the Monitoring view. Long text in the title is wrapped and buttons are correctly displayed. Fix \"Back to login page\" action We fixed the issue with \"Back to login page\" action. Clicking the \"Back to login page\" button on an error page no longer causes a redirection loop. Fix FOTA via COAP+TCP connection We fixed the issue with FOTA via COAP+TCP not working when on the same port as FOTA via HTTP. FOTA via TCP/TLS is now served on different ports. Device ID displayed instead of endpoint name We switched the device ID to the endpoint name in the \"Select device to add\" option. The dropdown now displays endpoint names instead of device IDs.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.34.0/","text":"v2023.34.0 # Previous version: v2023.33 Enhancements # Device removal process Created an additional step for deleting devices from Coiote and synchronizing the applied changes with the Azure service. Interface improvement for AWS Implemented a new user interface for AWS Integration Center. DIC action presentation Improved description on actions in dialog windows and removed an alert in pending state in the Device Integration Center. Event handler context menu Replaced full screen with a context menu for the event handler creator cards. Bug Fixes # Fixed the FOTA execution issue on EU Cloud Added lacking host entries to fix the error that impacted the process of executing FOTA on the EU cloud environment. Selecting devices Fixed an error on selecting and deselecting devices in the Device Inventory.","title":"v2023.34.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.34.0/#v2023340","text":"Previous version: v2023.33","title":"v2023.34.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.34.0/#enhancements","text":"Device removal process Created an additional step for deleting devices from Coiote and synchronizing the applied changes with the Azure service. Interface improvement for AWS Implemented a new user interface for AWS Integration Center. DIC action presentation Improved description on actions in dialog windows and removed an alert in pending state in the Device Integration Center. Event handler context menu Replaced full screen with a context menu for the event handler creator cards.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.34.0/#bug-fixes","text":"Fixed the FOTA execution issue on EU Cloud Added lacking host entries to fix the error that impacted the process of executing FOTA on the EU cloud environment. Selecting devices Fixed an error on selecting and deselecting devices in the Device Inventory.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.4.0/","text":"v2023.4.0 # Previous version: v2023.3.0 Architectural Changes # Enable DTLSConnection ID load balancing We have enabled DTLS session replication and DTLS Connection ID load balancing on EU-cloud. Enhancements # Remove legacy Nordic Assistance task support We have previously added support for the new Nordic Location Assistance and have kept backward compatibility with older tasks. However, support for the legacy Nordic Assistance task is no longer available. Add LwM2M specification names in tooltips We have added tooltips which show how parameters refer to the names used in the OMA LwM2M specification. Tooltips are now available e.g. in the Set observation panel. Add examples to REST API v3 documentation We have added examples and comments to all methods that were missing ones in the REST API v3 Swagger documentation. Remove range limits for observations We have removed range limits for the Not more often than once every and At least once every parameters for sending notifications. The default value for both parameters now is 5 seconds. Add new cipher suites We have added the following cipher suites to eu.iot.avsystem.cloud: TLS_ECDHE_ECDSA_WITH_AES_128_CCM TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_CCM TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 Bug Fixes # Fix unwarranted device impersonation We have removed the possibility of impersonating other devices in separate domains. Now by default all devices that use certificates must have Common Name set to Endpoint Name in their certificates or use some custom logic (scex). In case a device does not use such a certificate (with CN=EP), but the user still wants to connect the device with a certificate, it is possible, but the Setting Value verifyEpAgainstCertCn on the device has to be set to false. Additionally, in case of incorrect Endpoint Name used when connecting to the platform using PSK we were responding with 4.03. Currently the response has been changed to 4.00 Fix FOTA failing over Azure We have fixed Azure\u2019s DirectMethodPayload type being incorrectly parsed when doing FOTA. This type of Azure request no longer results in an error.","title":"v2023.4.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.4.0/#v202340","text":"Previous version: v2023.3.0","title":"v2023.4.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.4.0/#architectural-changes","text":"Enable DTLSConnection ID load balancing We have enabled DTLS session replication and DTLS Connection ID load balancing on EU-cloud.","title":"Architectural Changes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.4.0/#enhancements","text":"Remove legacy Nordic Assistance task support We have previously added support for the new Nordic Location Assistance and have kept backward compatibility with older tasks. However, support for the legacy Nordic Assistance task is no longer available. Add LwM2M specification names in tooltips We have added tooltips which show how parameters refer to the names used in the OMA LwM2M specification. Tooltips are now available e.g. in the Set observation panel. Add examples to REST API v3 documentation We have added examples and comments to all methods that were missing ones in the REST API v3 Swagger documentation. Remove range limits for observations We have removed range limits for the Not more often than once every and At least once every parameters for sending notifications. The default value for both parameters now is 5 seconds. Add new cipher suites We have added the following cipher suites to eu.iot.avsystem.cloud: TLS_ECDHE_ECDSA_WITH_AES_128_CCM TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_CCM TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.4.0/#bug-fixes","text":"Fix unwarranted device impersonation We have removed the possibility of impersonating other devices in separate domains. Now by default all devices that use certificates must have Common Name set to Endpoint Name in their certificates or use some custom logic (scex). In case a device does not use such a certificate (with CN=EP), but the user still wants to connect the device with a certificate, it is possible, but the Setting Value verifyEpAgainstCertCn on the device has to be set to false. Additionally, in case of incorrect Endpoint Name used when connecting to the platform using PSK we were responding with 4.03. Currently the response has been changed to 4.00 Fix FOTA failing over Azure We have fixed Azure\u2019s DirectMethodPayload type being incorrectly parsed when doing FOTA. This type of Azure request no longer results in an error.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.5.0/","text":"v2023.5.0 # Previous version: v2023.4.0 Enhancements # Display API version in the user interface We have added the API version display in the user interface. It is visible in the dropdown menu: Show documentation links icon -> Specification . Improve domain properties tab We have introduced changes and fixes to the domain properties tab. It is now scrollable, the expansion panels are properly aligned and the cancel action has a new icon. Fix tooltips not being displayed We have fixed tooltips not being displayed for disabled field forms, e.g. in the Set observation panel. Change default CSV import configuration We have introduced a minor change to default expressions used for importing devices from a CSV file, so that the import relies on the endpoint name rather than device identifier. Fix wrong CSV import error messages We have corrected an error message, which could occur during CSV import for devices without a specified connector type. The Identity has to be provided error was returned instead of ConnectorType field is mandatory. Add support for LwM2M CBOR and SenML JSON We have added LwM2M CBOR and SenML JSON formats support for receiving LwM2M Send operations. Bug Fixes # Fix unwarranted HTML rendering in chart tooltips We have introduced a fix, so that device names and resource values that are valid HTML tags are not rendered as HTML in the tooltips on Dashboards . Fix groups appearing outside the standard structure We have fixed redundant groups appearing outside of the standard structure in the Device groups view. This was due to incomplete removal of domains from the database. Fix multi-instance monitoring fail We have fixed an error which occurred while setting up monitoring for a multi-instance resource. Fix lwm2mBestEffortGet tag error We have fixed the use of the lwm2mBestEffortGet tag in an XML task returning an error message despite successfully retrieving data from the device. Fix hanging on the handshake We have fixed a bug where DTLS identity was removed from the PSK store during bootstrap, which prevented the devices from being able to register. Documentation # Administrator documentation update We have added various sections on Alerts in the Administration documentation, under the Monitoring, logs and alerts chapter.","title":"v2023.5.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.5.0/#v202350","text":"Previous version: v2023.4.0","title":"v2023.5.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.5.0/#enhancements","text":"Display API version in the user interface We have added the API version display in the user interface. It is visible in the dropdown menu: Show documentation links icon -> Specification . Improve domain properties tab We have introduced changes and fixes to the domain properties tab. It is now scrollable, the expansion panels are properly aligned and the cancel action has a new icon. Fix tooltips not being displayed We have fixed tooltips not being displayed for disabled field forms, e.g. in the Set observation panel. Change default CSV import configuration We have introduced a minor change to default expressions used for importing devices from a CSV file, so that the import relies on the endpoint name rather than device identifier. Fix wrong CSV import error messages We have corrected an error message, which could occur during CSV import for devices without a specified connector type. The Identity has to be provided error was returned instead of ConnectorType field is mandatory. Add support for LwM2M CBOR and SenML JSON We have added LwM2M CBOR and SenML JSON formats support for receiving LwM2M Send operations.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.5.0/#bug-fixes","text":"Fix unwarranted HTML rendering in chart tooltips We have introduced a fix, so that device names and resource values that are valid HTML tags are not rendered as HTML in the tooltips on Dashboards . Fix groups appearing outside the standard structure We have fixed redundant groups appearing outside of the standard structure in the Device groups view. This was due to incomplete removal of domains from the database. Fix multi-instance monitoring fail We have fixed an error which occurred while setting up monitoring for a multi-instance resource. Fix lwm2mBestEffortGet tag error We have fixed the use of the lwm2mBestEffortGet tag in an XML task returning an error message despite successfully retrieving data from the device. Fix hanging on the handshake We have fixed a bug where DTLS identity was removed from the PSK store during bootstrap, which prevented the devices from being able to register.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.5.0/#documentation","text":"Administrator documentation update We have added various sections on Alerts in the Administration documentation, under the Monitoring, logs and alerts chapter.","title":"Documentation"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.6.0/","text":"v2023.6.0 # Previous version: v2023.5.0 Enhancements # Remove Object ID limit We have removed the current limitation for the number of Object ID (> 502) in new monitoring. Add error message for Azure integration We have added an error message, which informs about incorrect validation of endpoint names in the used CSV file during Azure integration. Add new columns in device tests lists We have added two default new columns in the device tests list table - Created by and Last update by. They indicate which user created or updated a given test case. Task execution scope for tasks and task templates We have introduced a change, so that all tasks and task templates have the execution scope property assigned. This is to avoid potential errors and does not affect existing tasks. XML tasks security improvements For security reasons, we have introduced the following changes to the rest and coioteRest XML tasks tags: Requests to private IP addresses are blocked by default, Following redirections is disabled by default, Allowed protocols are limited to HTTP and HTTPS. Remove domain select dropdown for Developer plan We have removed the domain select dropdown from the navigation bar as domain management is not a functionality available for users with the Developer plan. Bug Fixes # Fix an exception during Azure client refresh We have removed a faulty dependency, which resulted in an unhandled exception during Azure client refresh. We have also updated the Azure SDK library. Fix UI issue in Device Center We have fixed an issue with the Set observation panel in the Device Center. It is no longer possible to interact with the inactive part of the interface, while the panel is extended. Fix setting values not properly applied We have fixed an issue with setting values not being properly logged during the initial session of a device and working only after restarting a task. This occurred if setting values were accessed in a migration rule and therefore initialised prematurely. Fix LwM2M Bootstrap panel notice message format We have fixed the notice message entries in the LwM2M Bootstrap panel being duplicated.","title":"v2023.6.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.6.0/#v202360","text":"Previous version: v2023.5.0","title":"v2023.6.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.6.0/#enhancements","text":"Remove Object ID limit We have removed the current limitation for the number of Object ID (> 502) in new monitoring. Add error message for Azure integration We have added an error message, which informs about incorrect validation of endpoint names in the used CSV file during Azure integration. Add new columns in device tests lists We have added two default new columns in the device tests list table - Created by and Last update by. They indicate which user created or updated a given test case. Task execution scope for tasks and task templates We have introduced a change, so that all tasks and task templates have the execution scope property assigned. This is to avoid potential errors and does not affect existing tasks. XML tasks security improvements For security reasons, we have introduced the following changes to the rest and coioteRest XML tasks tags: Requests to private IP addresses are blocked by default, Following redirections is disabled by default, Allowed protocols are limited to HTTP and HTTPS. Remove domain select dropdown for Developer plan We have removed the domain select dropdown from the navigation bar as domain management is not a functionality available for users with the Developer plan.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.6.0/#bug-fixes","text":"Fix an exception during Azure client refresh We have removed a faulty dependency, which resulted in an unhandled exception during Azure client refresh. We have also updated the Azure SDK library. Fix UI issue in Device Center We have fixed an issue with the Set observation panel in the Device Center. It is no longer possible to interact with the inactive part of the interface, while the panel is extended. Fix setting values not properly applied We have fixed an issue with setting values not being properly logged during the initial session of a device and working only after restarting a task. This occurred if setting values were accessed in a migration rule and therefore initialised prematurely. Fix LwM2M Bootstrap panel notice message format We have fixed the notice message entries in the LwM2M Bootstrap panel being duplicated.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.7.0/","text":"v2023.7.0 # Previous version: v2023.6.0 Enhancements # Add duplicate test action We have added a new functionality, which allows for duplicating single device tests in the Device test repository . Only custom tests can be duplicated. Improve search fields consistency We have made improvements to the Endpoint name , Friendly name and Description search fields in Device inventory and Device groups views. It is now possible to conduct searches in all of the fields using a partial match query. Due to security reasons, if encryption is enabled, the Endpoint name can be found only with an exact match query. Plain text - HEX conversion for PSK We have added the possibility to switch between the two PSK formats in the Device center . A preview of the value converted to the other format is now present in the device creator and the configuration edit dialog. Update lwm2m-test server certificate for lwm2m endpoints We have changed the server certificate on lwm2m-test.avsystem.io installation so that it uses only secp256r1 (EC256) keys. This increases compatibility with constrained devices. To verify server certificate on lwm2m-test.avsystem.io installation, the device should have the https://ca.avsystem.com/certs/AVSystem_ECCA_LV1_SS.crt certificate in the trust store. Update endpoint name error messages We have added custom error messages occurring when attempting to use an endpoint name, which is already in use. Save filtering, paging and sorting options in Device inventory We have added an improvement to platform navigation. If you reach the Device inventory using the back button in your browser, the previously set filtering, paging and sorting options are restored. Ensure device alias uniqueness We have added a requirement for device alias names to be unique in order to prevent data sets not being complete when retrieved via API. Bug Fixes # Fix incorrect traffic routing We have fixed incorrect traffic routing to UDPC, which occasionally failed, especially if direct routing was enabled. Fix data collection domain property We have fixed an issue with the Data collection domain property, where it was possible to retrieve data meant to have been deleted according to the settings. Fix table custom settings We have fixed an error, which occurred for some users and caused the custom settings for menu entries (tabs) in the Device management center being reverted to the default ones. Fix Forbidden Address Issue We have fixed an issue with one of the tasks interfering with security checks, which resulted in the Forbidden Address Issue error.","title":"v2023.7.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.7.0/#v202370","text":"Previous version: v2023.6.0","title":"v2023.7.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.7.0/#enhancements","text":"Add duplicate test action We have added a new functionality, which allows for duplicating single device tests in the Device test repository . Only custom tests can be duplicated. Improve search fields consistency We have made improvements to the Endpoint name , Friendly name and Description search fields in Device inventory and Device groups views. It is now possible to conduct searches in all of the fields using a partial match query. Due to security reasons, if encryption is enabled, the Endpoint name can be found only with an exact match query. Plain text - HEX conversion for PSK We have added the possibility to switch between the two PSK formats in the Device center . A preview of the value converted to the other format is now present in the device creator and the configuration edit dialog. Update lwm2m-test server certificate for lwm2m endpoints We have changed the server certificate on lwm2m-test.avsystem.io installation so that it uses only secp256r1 (EC256) keys. This increases compatibility with constrained devices. To verify server certificate on lwm2m-test.avsystem.io installation, the device should have the https://ca.avsystem.com/certs/AVSystem_ECCA_LV1_SS.crt certificate in the trust store. Update endpoint name error messages We have added custom error messages occurring when attempting to use an endpoint name, which is already in use. Save filtering, paging and sorting options in Device inventory We have added an improvement to platform navigation. If you reach the Device inventory using the back button in your browser, the previously set filtering, paging and sorting options are restored. Ensure device alias uniqueness We have added a requirement for device alias names to be unique in order to prevent data sets not being complete when retrieved via API.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.7.0/#bug-fixes","text":"Fix incorrect traffic routing We have fixed incorrect traffic routing to UDPC, which occasionally failed, especially if direct routing was enabled. Fix data collection domain property We have fixed an issue with the Data collection domain property, where it was possible to retrieve data meant to have been deleted according to the settings. Fix table custom settings We have fixed an error, which occurred for some users and caused the custom settings for menu entries (tabs) in the Device management center being reverted to the default ones. Fix Forbidden Address Issue We have fixed an issue with one of the tasks interfering with security checks, which resulted in the Forbidden Address Issue error.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.9.0/","text":"v2023.9.0 # Previous version: v2023.7.0 Architectural Changes # New Firmware update tab We have added the possibility to conduct both Basic and Multi-component Firmware Update in the user interface. This functionality is accessible through the Device Center > Firmware update > Update Firmware . We have also added two new cards in the device Firmware update tab. The Device firmware card displays the last recorded information about the current firmware version of the device. The Updates list card contains a table with a detailed overview of executed and scheduled firmware updates Enhancements # Improve device logs We have introduced a configuration change, so that information about failed connection attempts is included in the device logs. Bug Fixes # Fix unwarranted tag in XML tasks We have fixed a bug, which caused the <ensureObservation> tag being injected into XML task code when scheduling a task via API. Fix error not being logged We have fixed an error message not being properly logged in case a device could not obtain an EST certificate after being added via Bootstrap. This occurred if the Endpoint name and certificate Common Name verification ( verifyEpAgainstCertCn Setting Value) was disabled and a certificate of a different device was used.","title":"v2023.9.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.9.0/#v202390","text":"Previous version: v2023.7.0","title":"v2023.9.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.9.0/#architectural-changes","text":"New Firmware update tab We have added the possibility to conduct both Basic and Multi-component Firmware Update in the user interface. This functionality is accessible through the Device Center > Firmware update > Update Firmware . We have also added two new cards in the device Firmware update tab. The Device firmware card displays the last recorded information about the current firmware version of the device. The Updates list card contains a table with a detailed overview of executed and scheduled firmware updates","title":"Architectural Changes"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.9.0/#enhancements","text":"Improve device logs We have introduced a configuration change, so that information about failed connection attempts is included in the device logs.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2023.9.0/#bug-fixes","text":"Fix unwarranted tag in XML tasks We have fixed a bug, which caused the <ensureObservation> tag being injected into XML task code when scheduling a task via API. Fix error not being logged We have fixed an error message not being properly logged in case a device could not obtain an EST certificate after being added via Bootstrap. This occurred if the Endpoint name and certificate Common Name verification ( verifyEpAgainstCertCn Setting Value) was disabled and a certificate of a different device was used.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.1.0/","text":"v2024.1.0 # Previous version: v2023.34.0 Features # Interface of a DIC template Implemented new user interface for managing device event templates. Enhancements # New device groups and assigned devices Added a possibility to create a new group in the Device Inventory when assigning devices. Block size configuration Added a possibility to configure the block size in CoAP Block transfer communication for a device or group. Disabling a handlers Added a checkbox Keep active after repeated fails that enables restoring the connection automatically when endpoint is available again. Available for users with administrative permissions. Hide passwords and tokens Passwords and tokens for basic authorization are now hidden behind asterisks in the authorization method view in the Device Integration Center Web Hook Configuration. Influx templates Updated the default Influx telemetry template in the Device Integration Center. Bug Fixes # Provisioning session error Fixed the provisioning session error to enable task execution. Read resource during the FOTA update Fixed a bug causing an incorrect error message displayed when a task was executed during the FOTA update. Types of deviceEvent Fixed the issue with a different type of deviceEvent field in Telemetry and Device events in DIC Influx handlers. Influx handler Fixed an issue with editing the DIC influx handler.","title":"v2024.1.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.1.0/#v202410","text":"Previous version: v2023.34.0","title":"v2024.1.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.1.0/#features","text":"Interface of a DIC template Implemented new user interface for managing device event templates.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.1.0/#enhancements","text":"New device groups and assigned devices Added a possibility to create a new group in the Device Inventory when assigning devices. Block size configuration Added a possibility to configure the block size in CoAP Block transfer communication for a device or group. Disabling a handlers Added a checkbox Keep active after repeated fails that enables restoring the connection automatically when endpoint is available again. Available for users with administrative permissions. Hide passwords and tokens Passwords and tokens for basic authorization are now hidden behind asterisks in the authorization method view in the Device Integration Center Web Hook Configuration. Influx templates Updated the default Influx telemetry template in the Device Integration Center.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.1.0/#bug-fixes","text":"Provisioning session error Fixed the provisioning session error to enable task execution. Read resource during the FOTA update Fixed a bug causing an incorrect error message displayed when a task was executed during the FOTA update. Types of deviceEvent Fixed the issue with a different type of deviceEvent field in Telemetry and Device events in DIC Influx handlers. Influx handler Fixed an issue with editing the DIC influx handler.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.2.0/","text":"v2024.2.0 # Previous version: v2024.1.0 Enhancements # Disable custom template ID by default Disabled the custom template ID by default in the Azure template in the creating, copying and editing mode.","title":"v2024.2.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.2.0/#v202420","text":"Previous version: v2024.1.0","title":"v2024.2.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.2.0/#enhancements","text":"Disable custom template ID by default Disabled the custom template ID by default in the Azure template in the creating, copying and editing mode.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.3.0/","text":"v2024.3.0 # Previous version: v2024.2.0 Features # Fleet FOTA updates, campaigns and configurations Added an option to create configurations of Fleet FOTA and Fleet FOTA campaigns for specified groups of devices with a possibility to adjust: image delivery method, image transport type, URI format and timeout. Implemented a FOTA campaign feature to conduct updates in accordance with selected configurations on more than one device simultaneously. The Upcoming FOTA campaign and Part of FOTA campaign sections added to the platform interface in the Firmware update view. Multi-component firmware update feature allowed for Fleet FOTA devices. Supported by REST API only. Bug Fixes # Adding devices to Coiote Fixed an issue related to an endpoint name while adding a device via LoRaWAN Gateway Bootstrap Server.","title":"v2024.3.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.3.0/#v202430","text":"Previous version: v2024.2.0","title":"v2024.3.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.3.0/#features","text":"Fleet FOTA updates, campaigns and configurations Added an option to create configurations of Fleet FOTA and Fleet FOTA campaigns for specified groups of devices with a possibility to adjust: image delivery method, image transport type, URI format and timeout. Implemented a FOTA campaign feature to conduct updates in accordance with selected configurations on more than one device simultaneously. The Upcoming FOTA campaign and Part of FOTA campaign sections added to the platform interface in the Firmware update view. Multi-component firmware update feature allowed for Fleet FOTA devices. Supported by REST API only.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.3.0/#bug-fixes","text":"Adding devices to Coiote Fixed an issue related to an endpoint name while adding a device via LoRaWAN Gateway Bootstrap Server.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.4.0/","text":"v2024.4.0 # Previous version: v2024.3.0 Features # Multiple devices registration feature Implemented an SMS Wakeup feature accessible in the Mobile connectivity section that allows to send an SMS to multiple devices for a registration update execution. Bug Fixes # Device and server communication Fixed an issue on device communication with server in the certificate mode. Firmware update error Fixed an error informing about an illegal firmware state change during the FOTA execution.","title":"v2024.4.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.4.0/#v202440","text":"Previous version: v2024.3.0","title":"v2024.4.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.4.0/#features","text":"Multiple devices registration feature Implemented an SMS Wakeup feature accessible in the Mobile connectivity section that allows to send an SMS to multiple devices for a registration update execution.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.4.0/#bug-fixes","text":"Device and server communication Fixed an issue on device communication with server in the certificate mode. Firmware update error Fixed an error informing about an illegal firmware state change during the FOTA execution.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.5.0/","text":"v2024.5.0 # Previous version: v2024.4.0 Enhancements # Enhanced Connection Failure Logs Improved logging for connection failures related to DTLS/TLS certificates. Logs now identify issues with denylisted certificates or certificates from invalid CAs, aiding in troubleshooting.","title":"v2024.5.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.5.0/#v202450","text":"Previous version: v2024.4.0","title":"v2024.5.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2024.5.0/#enhancements","text":"Enhanced Connection Failure Logs Improved logging for connection failures related to DTLS/TLS certificates. Logs now identify issues with denylisted certificates or certificates from invalid CAs, aiding in troubleshooting.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.4.0/","text":"v2025.4.0 # Previous version: v2024.5.0 Features # Support for Notifications after device address change Introduced a new allowNotificationAddressChange flag in the LwM2M dialect to support devices that change IP addresses without performing a full registration. This prevents notifications from being rejected while maintaining security with IPsec and CoAP token validation. Retry action in FOTA campaign device list Added a retry action button for devices in the FOTA campaign details view. The action allows restarting the FOTA task for a selected device, if its FOTA update has failed. This improvement enhances campaign management by providing an easy way to retry failed updates directly from the device list. Enhancements # Improved FOTA campaign update information Added columns for versions before and after update in the Updates Started tab of FOTA campaign details. The target version column in Device Center now also includes a tooltip for multi-component FOTA campaigns. Double confirmation for self-account deletion Added a double confirmation panel when deleting the currently logged-in user to prevent accidental account removal. This update includes UI improvements for a clearer and safer account deletion process. Improved API documentation for XML tasks Added an API documentation section in the user documentation introducing new API guides: Read Latest Data from a Device and Schedule Deferred Firmware Upgrade . Additionally, enhanced Tasks API documentation in Swagger with more detailed descriptions and examples. Improved FOTA tab in Device Center Enhanced the Firmware Update tab in Device Center by adding the latest update status to the summary card and four new columns in the updates table: FOTA error type, Version before update, Target version, and Retries for failed updates. These changes provide clearer insights into update history and status. Documented common XML task use cases Introduced how-to-guides on task usage in the user documentation to assist users with common task use cases. The guides include instruction on handling LwM2M notifications with retries, performing advanced JSON operations in device configurations, and forwarding device data in batches. Target firmware version in FOTA creator Added an optional Target version input in the Basic FOTA and Basic FOTA configuration creators. The provided expected version is now saved and displayed in the FOTA and FOTA configuration details. Adjustments to FOTA campaigns list Updated the FOTA campaigns list view introducing minor error indicators and version details for better clarity. New info in FOTA campaign sidebar The FOTA campaign sidebar now displays additional details, including FOTA type, target version, and version before update. If multiple versions are present, a button allows navigation to the information tab. Alerts and highlights indicate whether the target version matches reported FOTA progress statuses. Bug Fixes # Fix for task execution failures Fixed an issue causing failures in certain task executions. The expressions library was updated to the latest version. Additionally, strict validation for task variable names was introduced, with configuration options adjusted to prevent similar issues in the future. Fixed incorrect FOTA status display Resolved an issue where in a few corner cases FOTA updates appeared In Progress even after being Canceled due to a timeout. Now, any steps still marked as ongoing during cancellation are correctly updated to Canceled.","title":"v2025.4.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.4.0/#v202540","text":"Previous version: v2024.5.0","title":"v2025.4.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.4.0/#features","text":"Support for Notifications after device address change Introduced a new allowNotificationAddressChange flag in the LwM2M dialect to support devices that change IP addresses without performing a full registration. This prevents notifications from being rejected while maintaining security with IPsec and CoAP token validation. Retry action in FOTA campaign device list Added a retry action button for devices in the FOTA campaign details view. The action allows restarting the FOTA task for a selected device, if its FOTA update has failed. This improvement enhances campaign management by providing an easy way to retry failed updates directly from the device list.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.4.0/#enhancements","text":"Improved FOTA campaign update information Added columns for versions before and after update in the Updates Started tab of FOTA campaign details. The target version column in Device Center now also includes a tooltip for multi-component FOTA campaigns. Double confirmation for self-account deletion Added a double confirmation panel when deleting the currently logged-in user to prevent accidental account removal. This update includes UI improvements for a clearer and safer account deletion process. Improved API documentation for XML tasks Added an API documentation section in the user documentation introducing new API guides: Read Latest Data from a Device and Schedule Deferred Firmware Upgrade . Additionally, enhanced Tasks API documentation in Swagger with more detailed descriptions and examples. Improved FOTA tab in Device Center Enhanced the Firmware Update tab in Device Center by adding the latest update status to the summary card and four new columns in the updates table: FOTA error type, Version before update, Target version, and Retries for failed updates. These changes provide clearer insights into update history and status. Documented common XML task use cases Introduced how-to-guides on task usage in the user documentation to assist users with common task use cases. The guides include instruction on handling LwM2M notifications with retries, performing advanced JSON operations in device configurations, and forwarding device data in batches. Target firmware version in FOTA creator Added an optional Target version input in the Basic FOTA and Basic FOTA configuration creators. The provided expected version is now saved and displayed in the FOTA and FOTA configuration details. Adjustments to FOTA campaigns list Updated the FOTA campaigns list view introducing minor error indicators and version details for better clarity. New info in FOTA campaign sidebar The FOTA campaign sidebar now displays additional details, including FOTA type, target version, and version before update. If multiple versions are present, a button allows navigation to the information tab. Alerts and highlights indicate whether the target version matches reported FOTA progress statuses.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.4.0/#bug-fixes","text":"Fix for task execution failures Fixed an issue causing failures in certain task executions. The expressions library was updated to the latest version. Additionally, strict validation for task variable names was introduced, with configuration options adjusted to prevent similar issues in the future. Fixed incorrect FOTA status display Resolved an issue where in a few corner cases FOTA updates appeared In Progress even after being Canceled due to a timeout. Now, any steps still marked as ongoing during cancellation are correctly updated to Canceled.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.5.0/","text":"v2025.5.0 # Previous version: v2025.4.0 Features # Reference device selection in FOTA configuration Added a step to select a reference device for multi-component FOTA configuration. Users can filter compatible devices, and the available components are displayed upon selection. New FOTA campaign sidebar details The FOTA campaign sidebar now displays additional details, including campaign type, target version, and the version before the update. Alerts highlight version mismatches, and a new navigation button provides quick access to detailed information. FOTA approval preview with components The FOTA approval window for multi-component FOTA now includes a detailed preview of multi-component configurations. This allows users to review all components before approving a campaign, ensuring greater control over the update process. Enhancements # Improved error logging for Kafka messages Increased the maximum message size limit for error logs from Kafka to provide complete error details. If an error message exceeds 200 characters, a \"Show more\" button is now available to display the full message. Configurable automatic refresh in UpdateRequest Added a new dialect flag allowing users to enable or disable automatic READ and DISCOVER operations when a device sends an UpdateRequest with new objects. By default, this behavior remains enabled, but it can now be turned off to reduce unnecessary load on resource-constrained devices. Disabled irrelevant task parameters for Discard report option When the Discard report option is enabled in task configuration, the fields that are not applicable are now disabled and set to predefined values. This improves clarity by ensuring only relevant settings are available. Improved task domain handling Enhanced task creation rules to ensure tasks created from templates inherit the selected user domain. Group task reports now remain in their original domain when a device moves providing better domain consistency and clearer data visibility. Improved error handling for REST API POST /users The API now returns a 403 error instead of 400 when a user lacks IAM permissions and a 409 error for duplicate usernames. Custom error messages have been added for password policy violations and invalid emails. Improved FOTA session handling Enhanced FOTA execution by ensuring observation resets properly, preventing timeouts during the resetting state machine step. If no notifications are received, the system now falls back to a read request to maintain progress. Expanded permissions for iottenantadmin role The iottenantadmin role now includes permissions to modify the device connectivity domain property and export devices to a CSV file, improving administrative capabilities. Improved group management rules Updated the group assignment process to display only valid groups based on domain hierarchy. This ensures a more structured and consistent approach to managing device groups. Bug Fixes # Bootstrap security mode correction Fixed an issue where the bootstrap security mode was randomly changing from CERT to PSK, causing re-bootstrap failures. The system now ensures that security mode changes are handled correctly, preventing unintended reconfigurations. Fixed domain creation conflicts Resolved an issue where automatically created user domains could conflict with existing domain groups. Now, when a new user logs in for the first time and their domain needs to be generated based on predefined settings, the system detects potential conflicts and prevents them, providing relevant guidance.","title":"v2025.5.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.5.0/#v202550","text":"Previous version: v2025.4.0","title":"v2025.5.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.5.0/#features","text":"Reference device selection in FOTA configuration Added a step to select a reference device for multi-component FOTA configuration. Users can filter compatible devices, and the available components are displayed upon selection. New FOTA campaign sidebar details The FOTA campaign sidebar now displays additional details, including campaign type, target version, and the version before the update. Alerts highlight version mismatches, and a new navigation button provides quick access to detailed information. FOTA approval preview with components The FOTA approval window for multi-component FOTA now includes a detailed preview of multi-component configurations. This allows users to review all components before approving a campaign, ensuring greater control over the update process.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.5.0/#enhancements","text":"Improved error logging for Kafka messages Increased the maximum message size limit for error logs from Kafka to provide complete error details. If an error message exceeds 200 characters, a \"Show more\" button is now available to display the full message. Configurable automatic refresh in UpdateRequest Added a new dialect flag allowing users to enable or disable automatic READ and DISCOVER operations when a device sends an UpdateRequest with new objects. By default, this behavior remains enabled, but it can now be turned off to reduce unnecessary load on resource-constrained devices. Disabled irrelevant task parameters for Discard report option When the Discard report option is enabled in task configuration, the fields that are not applicable are now disabled and set to predefined values. This improves clarity by ensuring only relevant settings are available. Improved task domain handling Enhanced task creation rules to ensure tasks created from templates inherit the selected user domain. Group task reports now remain in their original domain when a device moves providing better domain consistency and clearer data visibility. Improved error handling for REST API POST /users The API now returns a 403 error instead of 400 when a user lacks IAM permissions and a 409 error for duplicate usernames. Custom error messages have been added for password policy violations and invalid emails. Improved FOTA session handling Enhanced FOTA execution by ensuring observation resets properly, preventing timeouts during the resetting state machine step. If no notifications are received, the system now falls back to a read request to maintain progress. Expanded permissions for iottenantadmin role The iottenantadmin role now includes permissions to modify the device connectivity domain property and export devices to a CSV file, improving administrative capabilities. Improved group management rules Updated the group assignment process to display only valid groups based on domain hierarchy. This ensures a more structured and consistent approach to managing device groups.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.5.0/#bug-fixes","text":"Bootstrap security mode correction Fixed an issue where the bootstrap security mode was randomly changing from CERT to PSK, causing re-bootstrap failures. The system now ensures that security mode changes are handled correctly, preventing unintended reconfigurations. Fixed domain creation conflicts Resolved an issue where automatically created user domains could conflict with existing domain groups. Now, when a new user logs in for the first time and their domain needs to be generated based on predefined settings, the system detects potential conflicts and prevents them, providing relevant guidance.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.6.0/","text":"v2025.6.0 # Previous version: v2025.5.0 Features # Cancel FOTA task Added the ability to cancel a FOTA update with a new tag. This allows for programmatic cancellation of FOTA updates, aligned with the same logic used in the FOTA UI. Observation-only strategy for FOTA Added a new FOTA strategy that uses only observations on individual firmware resources, skipping all Read operations. This is especially useful for devices that support limited observation paths and experience connectivity issues with Reads. Device CSV import view in Angular Introduced a new device import view. The updated version supports both basic and advanced import modes, improved validation, import logs, and better user feedback for large imports. Enhancements # Improved group dispatcher with rule-based validation Group dispatcher now follows enhanced validation rules for group assignments. In the Groups > Migrations panel, group suggestions are limited to valid options within the selected domain, helping prevent misconfigurations. Improved domain handling in task creation Domain selection in the task editor now follows updated validation rules to prevent invalid configurations when using task templates. These changes ensure better consistency and control when managing tasks across different domains. Improved validation for device and group assignments Illegal domain or group assignments for devices now trigger improved error messages instead of being automatically corrected. This change ensures stricter validation, better transparency, and easier debugging when trying to save invalid data. Bug Fixes # Fixed missing option to delete multiple devices Restored the ability to delete multiple devices at once from the Device Inventory for users with the correct permissions. The option was previously available only to superusers due to a permission misconfiguration. Fixed group assignment after expression-based search Resolved an issue where devices filtered using expressions couldn\u2019t be added to a group. The action now works correctly for all search types. Fixed removal of outdated group task reports Group task reports are now removed according to the retention policy. This ensures outdated reports don't linger in the system, keeping task results clean and relevant. Fixed duplicate entries in Device logs Resolved an issue where retransmitted CoAP requests were logged multiple times, even though only one request was actually sent. Logs now correctly reflect a single entry per request. Fixed FOTA timeout at resetting state machine step Resolved an issue where pull FOTA tasks could hang due to missing observation refresh, causing timeouts during the reset phase. The update now forces an observation reset and includes a fallback Read to ensure the process can be completed. Fixed missing /3 object in data model Devices now correctly display the Device object (/3) in the data model even when the refresh-data-model task is disabled. The fix ensures data from the initial Read is stored and shown in the UI. Fixed incorrect integer values in Data model view Resolved an issue where large integer values were displayed incorrectly in the Data model . These values are now represented accurately.","title":"v2025.6.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.6.0/#v202560","text":"Previous version: v2025.5.0","title":"v2025.6.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.6.0/#features","text":"Cancel FOTA task Added the ability to cancel a FOTA update with a new tag. This allows for programmatic cancellation of FOTA updates, aligned with the same logic used in the FOTA UI. Observation-only strategy for FOTA Added a new FOTA strategy that uses only observations on individual firmware resources, skipping all Read operations. This is especially useful for devices that support limited observation paths and experience connectivity issues with Reads. Device CSV import view in Angular Introduced a new device import view. The updated version supports both basic and advanced import modes, improved validation, import logs, and better user feedback for large imports.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.6.0/#enhancements","text":"Improved group dispatcher with rule-based validation Group dispatcher now follows enhanced validation rules for group assignments. In the Groups > Migrations panel, group suggestions are limited to valid options within the selected domain, helping prevent misconfigurations. Improved domain handling in task creation Domain selection in the task editor now follows updated validation rules to prevent invalid configurations when using task templates. These changes ensure better consistency and control when managing tasks across different domains. Improved validation for device and group assignments Illegal domain or group assignments for devices now trigger improved error messages instead of being automatically corrected. This change ensures stricter validation, better transparency, and easier debugging when trying to save invalid data.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.6.0/#bug-fixes","text":"Fixed missing option to delete multiple devices Restored the ability to delete multiple devices at once from the Device Inventory for users with the correct permissions. The option was previously available only to superusers due to a permission misconfiguration. Fixed group assignment after expression-based search Resolved an issue where devices filtered using expressions couldn\u2019t be added to a group. The action now works correctly for all search types. Fixed removal of outdated group task reports Group task reports are now removed according to the retention policy. This ensures outdated reports don't linger in the system, keeping task results clean and relevant. Fixed duplicate entries in Device logs Resolved an issue where retransmitted CoAP requests were logged multiple times, even though only one request was actually sent. Logs now correctly reflect a single entry per request. Fixed FOTA timeout at resetting state machine step Resolved an issue where pull FOTA tasks could hang due to missing observation refresh, causing timeouts during the reset phase. The update now forces an observation reset and includes a fallback Read to ensure the process can be completed. Fixed missing /3 object in data model Devices now correctly display the Device object (/3) in the data model even when the refresh-data-model task is disabled. The fix ensures data from the initial Read is stored and shown in the UI. Fixed incorrect integer values in Data model view Resolved an issue where large integer values were displayed incorrectly in the Data model . These values are now represented accurately.","title":"Bug Fixes"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.7.0/","text":"v2025.7.0 # Previous version: v2025.6.0 Features # Canceling FOTA via API Added the ability to cancel an ongoing FOTA update using the API. This feature mirrors the cancellation flow available in the GUI and improves automation support. Enhancements # Improved tracking of data updates in Data model Introduced a new metric to help track device-reported values, offering clearer insight into when updates are based on recent or historical data. This makes it easier to monitor device behavior and ensure accurate data visibility. Domain validation for task creation and reports Updated task creation rules to prevent assigning tasks to domains lower than the device or group's domain, ensuring stricter and more predictable domain visibility. The domain picker dynamically adjusts based on the selected target, and REST API enforces these constraints. Task reports also retain their original domain when a device is moved across domains. Automatic removal of domain-inaccessible tasks The system now automatically removes tasks that no longer have access to the device due to domain changes. This enhancement helps maintain data relevance by leveraging the existing task retention mechanism. Improved visibility in FOTA campaign statistics Enhanced the FOTA campaign Overview tab by including in the statistics the devices marked as \"Retrying\" and displaying them in a new card. Bug Fixes # Fixed validation for FOTA API parameters Fixed a small issue where invalid values in FOTA configurations and campaigns were not always properly validated. The API now correctly returns errors when unsupported values are provided.","title":"v2025.7.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.7.0/#v202570","text":"Previous version: v2025.6.0","title":"v2025.7.0"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.7.0/#features","text":"Canceling FOTA via API Added the ability to cancel an ongoing FOTA update using the API. This feature mirrors the cancellation flow available in the GUI and improves automation support.","title":"Features"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.7.0/#enhancements","text":"Improved tracking of data updates in Data model Introduced a new metric to help track device-reported values, offering clearer insight into when updates are based on recent or historical data. This makes it easier to monitor device behavior and ensure accurate data visibility. Domain validation for task creation and reports Updated task creation rules to prevent assigning tasks to domains lower than the device or group's domain, ensuring stricter and more predictable domain visibility. The domain picker dynamically adjusts based on the selected target, and REST API enforces these constraints. Task reports also retain their original domain when a device is moved across domains. Automatic removal of domain-inaccessible tasks The system now automatically removes tasks that no longer have access to the device due to domain changes. This enhancement helps maintain data relevance by leveraging the existing task retention mechanism. Improved visibility in FOTA campaign statistics Enhanced the FOTA campaign Overview tab by including in the statistics the devices marked as \"Retrying\" and displaying them in a new card.","title":"Enhancements"},{"location":"Coiote_IoT_DM/Release_Notes/v2025.7.0/#bug-fixes","text":"Fixed validation for FOTA API parameters Fixed a small issue where invalid values in FOTA configurations and campaigns were not always properly validated. The API now correctly returns errors when unsupported values are provided.","title":"Bug Fixes"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/","text":"Air quality monitoring using Azure IoT Hub and Power BI # The Coiote IoT DM and Azure IoT Hub integration lets you create custom use cases with data visualization. See the video and have a sneak peek at the possibilities that the Coiote IoT DM - Azure IoT Hub integration offers you. In the tutorial, you will see how to leverage the integration to create an air quality monitoring in just a few steps. The text version of the tutorial, complete with the necessary steps and code snippets, is available below: Prerequisites # An active Azure subscription. An active Coiote IoT DM account. Please refer to Coiote IoT DM home page for details on how to get it. An active Microsoft Power BI account. An OpenWeatherMap account with a free API token. An active and configured Azure CLI - please refer to the Azure CLI installation guide for details. Creating and configuring an Azure IoT hub and storage account # First you need to add a new IoT hub and a storage account in Azure. Here's how to do it: Creating an IoT hub # In your Azure portal home view, go to IoT Hub and select Add . In the Basics tab: select your subscription and resource group, pick your region, provide a name for your IoT hub. In the Management tab: in Pricing and scale tier select, optionally, turn off Defender for IoT . In the Review + create tab, click Create . Creating a storage account # While your new IoT hub is deploying, you can add a new storage account: In the Azure portal, go to Storage accounts and select Add . In the Basics tab: select your subscription and resource group, provide a name for your storage account, pick your location. In the Review + create tab, click Create . Configuring the Azure IoT Hub integration extension # Once the deployments are complete, go to Coiote IoT DM to set up the Azure IoT Hub extension. If you haven't done this yet, please follow the instruction for the Azure IoT Hub integration configuration . Adding and connecting LwM2M air quality meter simulators to Coiote IoT DM and Azure IoT Hub # Go to your Azure IoT Hub and add new devices: Under Device management , select Devices and click + Add Device . Provide the name for your first device: air-quality-meter-example-0 . Click Save . Repeat the procedure for the other 5 devices (increase the number included in the device name). Go to Coiote IoT DM and sync the previously added devices: In Device inventory , select Sync with IoT platform -> Azure IoT Hub . In the pop-up, click Sync devices . Devices should then be visible in Device inventory Go to your command line and register the device simulators: Paste and run the following command to create a container group: az container create -g coiote-dm-experiments --name air-quality-meter-example-0 --image avsystemcom/air-quality-meter-example --environment-variables DEVICEID=air-quality-meter-example-0 SERVER_ADDRESS=eu.iot.avsystem.cloud OPEN_WEATHER_API_TOKEN=exampletoken Note Remember to change the command parameters accordingly so that they are in line with your naming and credentials. once the command is executed, you should see a JSON payload that describes the content of the container instance. Go back to Coiote IoT DM and in Device inventory , check if the devices have registered to the platform and if their data model has been updated. Click the Refresh data icon if needed. Click on a device and in the Device Management Center , select the Actions panel. Select the Refresh data model from device link and confirm by clicking Yes, execute task now . Go to the Objects panel to see if the data model for the device has been updated. You should be able to see objects such as 3 Device (along with the Model number resource which shows the name of the city of the temperature reading), 3303 Temperature , and 3428 Air quality . Bidirectional communication using Device Twin # From Coiote IoT DM to Azure IoT Hub # In your Coiote IoT DM account, go to Device inventory , select a device. In the Device Management Center , go to the Objects panel. In the 1 LwM2M Server object, find the Lifetime resource. Click the pen icon next to it, change the lifetime value and click the Apply link. Go to your Azure IoT hub, select IoT devices , click your device and select the Device Twin panel. Click Refresh and check in the JSON payload if the reported property for the 1/0/1 (Lifetime) resource has changed. From Azure IoT Hub to Coiote IoT DM # Note To read more about how the Device Twins work in the Coiote IoT DM - Azure IoT Hub integration, please refer to the LwM2M Mappings section . In your Azure IoT hub, select IoT devices , click one of your added devices and select the Device Twin panel. To change the Lifetime resource in Coiote IoT DM, you need to modify the relevant Device Twin desired property. under the properties tag in the Device Twin JSON payload, paste the following nested structure: \"reported\": { \"lwm2m\": { \"1\": { \"0\": { \"0\": {}, \"1\": { \"value\": 45 } } } } }, - Click Save and Refresh . The value of the resource should now be changed in the Device Twin reported properties as well as in the Coiote IoT DM Objects panel, in the Lifetime resource of the 1 LwM2M Server object. Passing telemetry to Azure IoT Hub # Setting group value tracking on resources in Coiote IoT DM # In Coiote IoT DM, go to Device inventory and use the search option to display your air quality meter devices. Then, click the Add to group icon. In the pop-up, click Add to new group , provide a name for your group (following the pattern root.iothubexample.airqualitymeter), click Confirm and Yes . Go to the Group management panel, select your group and click Devices to see if all of your devices are added to the group. Go to the Value tracking panel and click Add new . In the pop-up: Add value tracking for the Temperature resource: Provide the resource path: Temperature.1.Sensor Value . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Add value tracking for the Air quality PM10 resource: Provide the resource path: Air quality.1.PM10 . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Add value tracking for the Air quality PM2.5 resource: Provide the resource path: Air quality.1.PM2_5 . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Go back to Device inventory and select a device of your group. In the Dashboard view , you should be able to see the value tracking parameters as in the picture below: Configuring message routing for sending telemetry data in Azure IoT Hub # Go to your Azure IoT hub and add message routing: Under Hub settings , select Message routing and click + Add . Provide a name for your event, for example EventRoute . From the Endpoint drop-down list, select events . In the Routing query , paste the following: IS_DEFINED($body.lwm2m.3303.1.5700.value) OR IS_DEFINED($body.lwm2m.3428.1.1.value) OR IS_DEFINED($body.lwm2m.3428.1.3.value) Click Save . While in the Message routing panel, go to the Enrich messages tab to set up location tracking: For latitude: Name - type lat Value - copy and paste $twin.properties.reported.lwm2m.6.1.0.value Endpoint(s) - select events For longitude: Name - type lon Value - copy and paste $twin.properties.reported.lwm2m.6.1.1.value Endpoint(s) - select events For longitude: Name - type deviceId Value - copy and paste $twin.properties.reported.lwm2m.3.1.1.value Endpoint(s) - select events Use search to go to Stream analytics jobs and create a job for transferring the gathered data to Power BI. Click + Create and provide the following: Resource group - pick your resource group. Name - e.g. avsystem-iot-hub-to-powerbi . Click Review + Create . Once your deployment is complete, click Go to resource . While in your Stream Analytics job panel, add a stream input and output and write a query: Under Job topology , select Inputs . From the + Add stream input drop-down list, select Iot Hub and provide the following: Input alias - e.g. avsystem-iot-hub-input . Consumer group - pick the $Default group. Click Save . Under Job topology , select Outputs . From the + Add drop-down list, select Power BI and click Authorize . Log in to Power BI using your Azure account. In the Power BI right-hand side panel, provide the following: Output alias - e.g. avsystem-iot-hub-output Dataset name - e.g. AVSystemIoTHubDataSet Table name - e.g. Data Click Save . Under Job topology , select Query . Paste the following query into the query input field (remember to adjust your naming inside the query if needed): SELECT CAST(\"lwm2m\".\"3303.\"1\".\"5700\".value as float) as temperature, CAST(\"lwm2m\".\"3428.\"1\".\"1\".value as float) as pm10, CAST(\"lwm2m\".\"3428.\"1\".\"3\".value as float) as pm25, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User].[lat]') as lat, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User].[lon]') as lon, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User].[deviceId]') as deviceId2, EventProcessedUtcTime as processedTimestamp, IoTHub.EnqueuedTime as iotHubTimestamp, IoTHub.ConnectionDeviceId as deviceId INTO \"avsystem-iot-hub-output\" FROM \"avsystem-iot-hub-input\" Click Save query . In your Stream analytics job, go to Overview and click Start and confirm by clicking Start in the Start job window to run the created query. Data visualization using Power BI # Once the query is finished, you can go to Power BI to create a visualization for the data you have gathered. Go to https://powerbi.microsoft.com/ and sign in to your account. Go to My workspace and find your recently created dataset. Click the more options icon and select Create report From the Visualizations menu, select the table icon and drag and drop it to the work space. From the Fields menu, select the deviceId2 , temperature , pm10 and pm25 parameters. In the Values submenu, expand the drop-down list for the temperature , pm10 and pm25 parameters and select Average for each. Create a map with air quality indicators: From the Visualizations menu, click the get more visuals icon and select Get more visuals . Use search to find the Heatmap and click Add . From the Visualizations menu, click the Heatmap icon. Add the relevant parameters to the map data fields: To the Latitude data field, drag and drop the lat parameter from the Fields menu. To the Longitude data field, drag and drop the lon parameter from the Fields menu. To the Value data field, drag and drop the pm10 parameter from the Fields menu. In the Value data field, expand the drop-down list and select Average . To refresh the displayed data, click the Refresh button located in the upper navigation bar.","title":"Air quality monitoring using Azure IoT Hub and Power BI"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#air-quality-monitoring-using-azure-iot-hub-and-power-bi","text":"The Coiote IoT DM and Azure IoT Hub integration lets you create custom use cases with data visualization. See the video and have a sneak peek at the possibilities that the Coiote IoT DM - Azure IoT Hub integration offers you. In the tutorial, you will see how to leverage the integration to create an air quality monitoring in just a few steps. The text version of the tutorial, complete with the necessary steps and code snippets, is available below:","title":"Air quality monitoring using Azure IoT Hub and Power BI"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#prerequisites","text":"An active Azure subscription. An active Coiote IoT DM account. Please refer to Coiote IoT DM home page for details on how to get it. An active Microsoft Power BI account. An OpenWeatherMap account with a free API token. An active and configured Azure CLI - please refer to the Azure CLI installation guide for details.","title":"Prerequisites"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#creating-and-configuring-an-azure-iot-hub-and-storage-account","text":"First you need to add a new IoT hub and a storage account in Azure. Here's how to do it:","title":"Creating and configuring an Azure IoT hub and storage account"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#creating-an-iot-hub","text":"In your Azure portal home view, go to IoT Hub and select Add . In the Basics tab: select your subscription and resource group, pick your region, provide a name for your IoT hub. In the Management tab: in Pricing and scale tier select, optionally, turn off Defender for IoT . In the Review + create tab, click Create .","title":"Creating an IoT hub"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#creating-a-storage-account","text":"While your new IoT hub is deploying, you can add a new storage account: In the Azure portal, go to Storage accounts and select Add . In the Basics tab: select your subscription and resource group, provide a name for your storage account, pick your location. In the Review + create tab, click Create .","title":"Creating a storage account"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#configuring-the-azure-iot-hub-integration-extension","text":"Once the deployments are complete, go to Coiote IoT DM to set up the Azure IoT Hub extension. If you haven't done this yet, please follow the instruction for the Azure IoT Hub integration configuration .","title":"Configuring the Azure IoT Hub integration extension"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#adding-and-connecting-lwm2m-air-quality-meter-simulators-to-coiote-iot-dm-and-azure-iot-hub","text":"Go to your Azure IoT Hub and add new devices: Under Device management , select Devices and click + Add Device . Provide the name for your first device: air-quality-meter-example-0 . Click Save . Repeat the procedure for the other 5 devices (increase the number included in the device name). Go to Coiote IoT DM and sync the previously added devices: In Device inventory , select Sync with IoT platform -> Azure IoT Hub . In the pop-up, click Sync devices . Devices should then be visible in Device inventory Go to your command line and register the device simulators: Paste and run the following command to create a container group: az container create -g coiote-dm-experiments --name air-quality-meter-example-0 --image avsystemcom/air-quality-meter-example --environment-variables DEVICEID=air-quality-meter-example-0 SERVER_ADDRESS=eu.iot.avsystem.cloud OPEN_WEATHER_API_TOKEN=exampletoken Note Remember to change the command parameters accordingly so that they are in line with your naming and credentials. once the command is executed, you should see a JSON payload that describes the content of the container instance. Go back to Coiote IoT DM and in Device inventory , check if the devices have registered to the platform and if their data model has been updated. Click the Refresh data icon if needed. Click on a device and in the Device Management Center , select the Actions panel. Select the Refresh data model from device link and confirm by clicking Yes, execute task now . Go to the Objects panel to see if the data model for the device has been updated. You should be able to see objects such as 3 Device (along with the Model number resource which shows the name of the city of the temperature reading), 3303 Temperature , and 3428 Air quality .","title":"Adding and connecting LwM2M air quality meter simulators to Coiote IoT DM and Azure IoT Hub"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#bidirectional-communication-using-device-twin","text":"","title":"Bidirectional communication using Device Twin"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#from-coiote-iot-dm-to-azure-iot-hub","text":"In your Coiote IoT DM account, go to Device inventory , select a device. In the Device Management Center , go to the Objects panel. In the 1 LwM2M Server object, find the Lifetime resource. Click the pen icon next to it, change the lifetime value and click the Apply link. Go to your Azure IoT hub, select IoT devices , click your device and select the Device Twin panel. Click Refresh and check in the JSON payload if the reported property for the 1/0/1 (Lifetime) resource has changed.","title":"From Coiote IoT DM to Azure IoT Hub"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#from-azure-iot-hub-to-coiote-iot-dm","text":"Note To read more about how the Device Twins work in the Coiote IoT DM - Azure IoT Hub integration, please refer to the LwM2M Mappings section . In your Azure IoT hub, select IoT devices , click one of your added devices and select the Device Twin panel. To change the Lifetime resource in Coiote IoT DM, you need to modify the relevant Device Twin desired property. under the properties tag in the Device Twin JSON payload, paste the following nested structure: \"reported\": { \"lwm2m\": { \"1\": { \"0\": { \"0\": {}, \"1\": { \"value\": 45 } } } } }, - Click Save and Refresh . The value of the resource should now be changed in the Device Twin reported properties as well as in the Coiote IoT DM Objects panel, in the Lifetime resource of the 1 LwM2M Server object.","title":"From Azure IoT Hub to Coiote IoT DM"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#passing-telemetry-to-azure-iot-hub","text":"","title":"Passing telemetry to Azure IoT Hub"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#setting-group-value-tracking-on-resources-in-coiote-iot-dm","text":"In Coiote IoT DM, go to Device inventory and use the search option to display your air quality meter devices. Then, click the Add to group icon. In the pop-up, click Add to new group , provide a name for your group (following the pattern root.iothubexample.airqualitymeter), click Confirm and Yes . Go to the Group management panel, select your group and click Devices to see if all of your devices are added to the group. Go to the Value tracking panel and click Add new . In the pop-up: Add value tracking for the Temperature resource: Provide the resource path: Temperature.1.Sensor Value . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Add value tracking for the Air quality PM10 resource: Provide the resource path: Air quality.1.PM10 . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Add value tracking for the Air quality PM2.5 resource: Provide the resource path: Air quality.1.PM2_5 . In the Notification frequency section, provide the following values: At least once every - set it to 10 seconds. Not more often than once every - set it to 5 seconds. Click Add new . Go back to Device inventory and select a device of your group. In the Dashboard view , you should be able to see the value tracking parameters as in the picture below:","title":"Setting group value tracking on resources in Coiote IoT DM"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#configuring-message-routing-for-sending-telemetry-data-in-azure-iot-hub","text":"Go to your Azure IoT hub and add message routing: Under Hub settings , select Message routing and click + Add . Provide a name for your event, for example EventRoute . From the Endpoint drop-down list, select events . In the Routing query , paste the following: IS_DEFINED($body.lwm2m.3303.1.5700.value) OR IS_DEFINED($body.lwm2m.3428.1.1.value) OR IS_DEFINED($body.lwm2m.3428.1.3.value) Click Save . While in the Message routing panel, go to the Enrich messages tab to set up location tracking: For latitude: Name - type lat Value - copy and paste $twin.properties.reported.lwm2m.6.1.0.value Endpoint(s) - select events For longitude: Name - type lon Value - copy and paste $twin.properties.reported.lwm2m.6.1.1.value Endpoint(s) - select events For longitude: Name - type deviceId Value - copy and paste $twin.properties.reported.lwm2m.3.1.1.value Endpoint(s) - select events Use search to go to Stream analytics jobs and create a job for transferring the gathered data to Power BI. Click + Create and provide the following: Resource group - pick your resource group. Name - e.g. avsystem-iot-hub-to-powerbi . Click Review + Create . Once your deployment is complete, click Go to resource . While in your Stream Analytics job panel, add a stream input and output and write a query: Under Job topology , select Inputs . From the + Add stream input drop-down list, select Iot Hub and provide the following: Input alias - e.g. avsystem-iot-hub-input . Consumer group - pick the $Default group. Click Save . Under Job topology , select Outputs . From the + Add drop-down list, select Power BI and click Authorize . Log in to Power BI using your Azure account. In the Power BI right-hand side panel, provide the following: Output alias - e.g. avsystem-iot-hub-output Dataset name - e.g. AVSystemIoTHubDataSet Table name - e.g. Data Click Save . Under Job topology , select Query . Paste the following query into the query input field (remember to adjust your naming inside the query if needed): SELECT CAST(\"lwm2m\".\"3303.\"1\".\"5700\".value as float) as temperature, CAST(\"lwm2m\".\"3428.\"1\".\"1\".value as float) as pm10, CAST(\"lwm2m\".\"3428.\"1\".\"3\".value as float) as pm25, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User].[lat]') as lat, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User].[lon]') as lon, GetMetadataPropertyValue(\"avsystem-iot-hub-input\", '[User].[deviceId]') as deviceId2, EventProcessedUtcTime as processedTimestamp, IoTHub.EnqueuedTime as iotHubTimestamp, IoTHub.ConnectionDeviceId as deviceId INTO \"avsystem-iot-hub-output\" FROM \"avsystem-iot-hub-input\" Click Save query . In your Stream analytics job, go to Overview and click Start and confirm by clicking Start in the Start job window to run the created query.","title":"Configuring message routing for sending telemetry data in Azure IoT Hub"},{"location":"Demo_Projects/Air_quality_monitoring_tutorial/#data-visualization-using-power-bi","text":"Once the query is finished, you can go to Power BI to create a visualization for the data you have gathered. Go to https://powerbi.microsoft.com/ and sign in to your account. Go to My workspace and find your recently created dataset. Click the more options icon and select Create report From the Visualizations menu, select the table icon and drag and drop it to the work space. From the Fields menu, select the deviceId2 , temperature , pm10 and pm25 parameters. In the Values submenu, expand the drop-down list for the temperature , pm10 and pm25 parameters and select Average for each. Create a map with air quality indicators: From the Visualizations menu, click the get more visuals icon and select Get more visuals . Use search to find the Heatmap and click Add . From the Visualizations menu, click the Heatmap icon. Add the relevant parameters to the map data fields: To the Latitude data field, drag and drop the lat parameter from the Fields menu. To the Longitude data field, drag and drop the lon parameter from the Fields menu. To the Value data field, drag and drop the pm10 parameter from the Fields menu. In the Value data field, expand the drop-down list and select Average . To refresh the displayed data, click the Refresh button located in the upper navigation bar.","title":"Data visualization using Power BI"},{"location":"Demo_Projects/Edge_Impulse_demo/","text":"Motion detection using Edge Impulse and Thingy:91 # Introduction # This example runs a motion detection model using the accelerometer of the Thingy:91 development kit, built with Edge Impulse . It streams the detected motion patterns to a LwM2M server. Detecting the motion patterns: \"idle\" and \"snake\" LwM2M Objects used: Security: /0 Server: /1 Device: /3 Pattern Detector: /33650 (custom object) Prerequisites # Thingy:91 Coiote IoT DM account Installed Zephyr dependencies Serial communication program e.g. minicom or RealTerm (for Linux or Mac) or PuTTy (for Windows) Warning This tutorial uses the Arm Embedded Toolchain, which is not compatible with the Apple M1 chipset. Compilation # Clone the Anjay Zephyr repository # Open the command line interface on your machine and clone the Anjay Zephyr repository using Git : git clone https : //github.com/AVSystem/Anjay-zephyr-client Set West manifest path to Anjay-zephyr-client/ei_demo , and manifest file to west-nrf.yml and run west update : west config manifest . path Anjay - zephyr - client / ei_demo west config manifest . file west - nrf . yml west update Update the endpoint name and PSK (optional) # Info The default credentials are : Endpoint name: Anjay-zephyr-client PSK (Pre-Shared Key): test The Endpoint Name and PSK can be configured using menuconfig . To open menuconfig , run the following command: west build -b thingy91/nrf9160/ns -p -t menuconfig Open up the folder anjay-zephyr-client ---> Create a new Endpoint Name and PSK Key : After making the changes, press Q to close the config menu and Y to save. Compile the project # Go to the ei_demo directory and compile the project for the Thingy:91: west build - b thingy91 / nrf9160 / ns Write the firmware to the Thingy:91 # Find the build file in the directory /build/zephyr , named: app_signed.hex . Connect the Thingy:91 to a USB port of your machine. Flash the file using the Programmer application in nRF Cloud for Desktop via MCUboot . Find more information on flashing the Thingy:91 using MCU Boot here . Connect the Thingy:91 to Coiote IoT Device Management platform # To connect to Coiote IoT Device Management platform, please register at eu.iot.avsystem.cloud . To connect the board: Log in to Coiote IoT DM and select Device Inventory from the left side menu. In Device Inventory , select Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: Add the Endpoint name , the default endpoint name is: Anjay-zephyr-client Key Identity is the same as the endpoint name Add the Key , the default key is: test Click Add device and then Confirm in the confirmation pop-up Add the Pattern Detection Object to Coiote IoT DM # Object ID /33650 refers to the pattern detection model and indicates which pattern has been detected. To add this custom object, go to the device overview page in Coiote IoT DM and click the top-right button: Go to previous version . In the left-side menu, click Objects . Click the button at the top right corner: Add new LwM2M object definition . To add a new object definition, copy-paste the following XML file and click Import . <?xml version=\"1.0\" encoding=\"UTF-8\"?> <LWM2M xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://openmobilealliance.org/tech/profiles/LWM2M.xsd\"> <Object ObjectType=\"MODefinition\"> <Name>Pattern detector</Name> <Description1><![CDATA[This object is used to report the pattern detected by the ML-based classification algorithms and to count the number of times it has been detected.]]></Description1> <ObjectID>33650</ObjectID> <ObjectURN>urn:oma:lwm2m:ext:33650</ObjectURN> <LWM2MVersion>1.0</LWM2MVersion> <ObjectVersion>1.0</ObjectVersion> <MultipleInstances>Multiple</MultipleInstances> <Mandatory>Optional</Mandatory> <Resources> <Item ID=\"2000\"> <Name>Detector State</Name> <Operations>R</Operations> <MultipleInstances>Single</MultipleInstances> <Mandatory>Mandatory</Mandatory> <Type>Boolean</Type> <RangeEnumeration></RangeEnumeration> <Units></Units> <Description><![CDATA[The current state of a detector.]]></Description> </Item> <Item ID=\"2001\"> <Name>Detector Counter</Name> <Operations>R</Operations> <MultipleInstances>Single</MultipleInstances> <Mandatory>Mandatory</Mandatory> <Type>Integer</Type> <RangeEnumeration></RangeEnumeration> <Units></Units> <Description><![CDATA[The cumulative value of patterns detected.]]></Description> </Item><Item ID=\"2002\"> <Name>Pattern Name</Name> <Operations>R</Operations> <MultipleInstances>Single</MultipleInstances> <Mandatory>Mandatory</Mandatory> <Type>String</Type> <RangeEnumeration></RangeEnumeration> <Units></Units> <Description><![CDATA[Name of the pattern being detected.]]></Description> </Item> </Resources> <Description2></Description2> </Object> </LWM2M> After importing the object definition, go back to the New Device Center by clicking the button in the top-right corner: Go to new Device Center . If the import was successful, you will find the object: /33650 Pattern detector under Data model . Pattern detection # The object: /33650 can distinguish three patterns: Idle Circle Snake Each pattern is defined as an Object Instance . The number of times the pattern has been recognized is shown as the Detector Counter . To see the Detector Counter for each pattern, select the corresponding Object Instance by clicking the down-arrow: \u25bc. Now start moving the Thingy:91 around to detect all three patterns. When a new motion pattern is detected, the Detector Counter increases and the LED color on the device will change. Set observations # The LwM2M standard allows you to instruct the device about the minimum and maximum allowed intervals between two updates. The intervals can be set from 1 second to multiple days. To instruct the device, an OBSERVE operation can be sent from the LwM2M Server to the LwM2M Client. For more information, see how to set observations","title":"Motion detection using Edge Impulse and Thingy:91"},{"location":"Demo_Projects/Edge_Impulse_demo/#motion-detection-using-edge-impulse-and-thingy91","text":"","title":"Motion detection using Edge Impulse and Thingy:91"},{"location":"Demo_Projects/Edge_Impulse_demo/#introduction","text":"This example runs a motion detection model using the accelerometer of the Thingy:91 development kit, built with Edge Impulse . It streams the detected motion patterns to a LwM2M server. Detecting the motion patterns: \"idle\" and \"snake\" LwM2M Objects used: Security: /0 Server: /1 Device: /3 Pattern Detector: /33650 (custom object)","title":"Introduction"},{"location":"Demo_Projects/Edge_Impulse_demo/#prerequisites","text":"Thingy:91 Coiote IoT DM account Installed Zephyr dependencies Serial communication program e.g. minicom or RealTerm (for Linux or Mac) or PuTTy (for Windows) Warning This tutorial uses the Arm Embedded Toolchain, which is not compatible with the Apple M1 chipset.","title":"Prerequisites"},{"location":"Demo_Projects/Edge_Impulse_demo/#compilation","text":"","title":"Compilation"},{"location":"Demo_Projects/Edge_Impulse_demo/#clone-the-anjay-zephyr-repository","text":"Open the command line interface on your machine and clone the Anjay Zephyr repository using Git : git clone https : //github.com/AVSystem/Anjay-zephyr-client Set West manifest path to Anjay-zephyr-client/ei_demo , and manifest file to west-nrf.yml and run west update : west config manifest . path Anjay - zephyr - client / ei_demo west config manifest . file west - nrf . yml west update","title":"Clone the Anjay Zephyr repository"},{"location":"Demo_Projects/Edge_Impulse_demo/#update-the-endpoint-name-and-psk-optional","text":"Info The default credentials are : Endpoint name: Anjay-zephyr-client PSK (Pre-Shared Key): test The Endpoint Name and PSK can be configured using menuconfig . To open menuconfig , run the following command: west build -b thingy91/nrf9160/ns -p -t menuconfig Open up the folder anjay-zephyr-client ---> Create a new Endpoint Name and PSK Key : After making the changes, press Q to close the config menu and Y to save.","title":"Update the endpoint name and PSK (optional)"},{"location":"Demo_Projects/Edge_Impulse_demo/#compile-the-project","text":"Go to the ei_demo directory and compile the project for the Thingy:91: west build - b thingy91 / nrf9160 / ns","title":"Compile the project"},{"location":"Demo_Projects/Edge_Impulse_demo/#write-the-firmware-to-the-thingy91","text":"Find the build file in the directory /build/zephyr , named: app_signed.hex . Connect the Thingy:91 to a USB port of your machine. Flash the file using the Programmer application in nRF Cloud for Desktop via MCUboot . Find more information on flashing the Thingy:91 using MCU Boot here .","title":"Write the firmware to the Thingy:91"},{"location":"Demo_Projects/Edge_Impulse_demo/#connect-the-thingy91-to-coiote-iot-device-management-platform","text":"To connect to Coiote IoT Device Management platform, please register at eu.iot.avsystem.cloud . To connect the board: Log in to Coiote IoT DM and select Device Inventory from the left side menu. In Device Inventory , select Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: Add the Endpoint name , the default endpoint name is: Anjay-zephyr-client Key Identity is the same as the endpoint name Add the Key , the default key is: test Click Add device and then Confirm in the confirmation pop-up","title":"Connect the Thingy:91 to Coiote IoT Device Management platform"},{"location":"Demo_Projects/Edge_Impulse_demo/#add-the-pattern-detection-object-to-coiote-iot-dm","text":"Object ID /33650 refers to the pattern detection model and indicates which pattern has been detected. To add this custom object, go to the device overview page in Coiote IoT DM and click the top-right button: Go to previous version . In the left-side menu, click Objects . Click the button at the top right corner: Add new LwM2M object definition . To add a new object definition, copy-paste the following XML file and click Import . <?xml version=\"1.0\" encoding=\"UTF-8\"?> <LWM2M xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://openmobilealliance.org/tech/profiles/LWM2M.xsd\"> <Object ObjectType=\"MODefinition\"> <Name>Pattern detector</Name> <Description1><![CDATA[This object is used to report the pattern detected by the ML-based classification algorithms and to count the number of times it has been detected.]]></Description1> <ObjectID>33650</ObjectID> <ObjectURN>urn:oma:lwm2m:ext:33650</ObjectURN> <LWM2MVersion>1.0</LWM2MVersion> <ObjectVersion>1.0</ObjectVersion> <MultipleInstances>Multiple</MultipleInstances> <Mandatory>Optional</Mandatory> <Resources> <Item ID=\"2000\"> <Name>Detector State</Name> <Operations>R</Operations> <MultipleInstances>Single</MultipleInstances> <Mandatory>Mandatory</Mandatory> <Type>Boolean</Type> <RangeEnumeration></RangeEnumeration> <Units></Units> <Description><![CDATA[The current state of a detector.]]></Description> </Item> <Item ID=\"2001\"> <Name>Detector Counter</Name> <Operations>R</Operations> <MultipleInstances>Single</MultipleInstances> <Mandatory>Mandatory</Mandatory> <Type>Integer</Type> <RangeEnumeration></RangeEnumeration> <Units></Units> <Description><![CDATA[The cumulative value of patterns detected.]]></Description> </Item><Item ID=\"2002\"> <Name>Pattern Name</Name> <Operations>R</Operations> <MultipleInstances>Single</MultipleInstances> <Mandatory>Mandatory</Mandatory> <Type>String</Type> <RangeEnumeration></RangeEnumeration> <Units></Units> <Description><![CDATA[Name of the pattern being detected.]]></Description> </Item> </Resources> <Description2></Description2> </Object> </LWM2M> After importing the object definition, go back to the New Device Center by clicking the button in the top-right corner: Go to new Device Center . If the import was successful, you will find the object: /33650 Pattern detector under Data model .","title":"Add the Pattern Detection Object to Coiote IoT DM"},{"location":"Demo_Projects/Edge_Impulse_demo/#pattern-detection","text":"The object: /33650 can distinguish three patterns: Idle Circle Snake Each pattern is defined as an Object Instance . The number of times the pattern has been recognized is shown as the Detector Counter . To see the Detector Counter for each pattern, select the corresponding Object Instance by clicking the down-arrow: \u25bc. Now start moving the Thingy:91 around to detect all three patterns. When a new motion pattern is detected, the Detector Counter increases and the LED color on the device will change.","title":"Pattern detection"},{"location":"Demo_Projects/Edge_Impulse_demo/#set-observations","text":"The LwM2M standard allows you to instruct the device about the minimum and maximum allowed intervals between two updates. The intervals can be set from 1 second to multiple days. To instruct the device, an OBSERVE operation can be sent from the LwM2M Server to the LwM2M Client. For more information, see how to set observations","title":"Set observations"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/","text":"Implementing LwM2M objects on Raspberry Pi # Introduction # Svetovid is a LwM2M client that gives you tools to implement selected LwM2M objects for RaspberryPi-based IoT devices using Python programming language. Svetovid is based on a state-of-the-art Anjay LwM2M client developed by AVSystem. It features the FSDM (File System Data Model) in which LwM2M objects are mapped to folders that follow a particular schema, and executables behave as expected by the LwM2M client that loads and manages them. This tutorial will show you how to implement a temperature LwM2M object on your device and a push button using Svetovid. This will enable live readings of their resources (temperature, push button state and counter) in Coiote IoT DM. Prerequisites # Raspberry Pi 3 or 4 with a configured operating system and a set-up WiFi connection. A Sense HAT or a GrovePi with a temperature sensor ( DHT11 or similar) and a push button ( Grove-button or similar). A user with access to the Coiote IoT Device Management platform. Step 1: Prepare your Sense HAT/GrovePi # Sense HAT # Install the Sense HAT packages: sudo apt-get install sense-hat Check if Sense HAT is working correctly: Create a hello_world.py file: from sense_hat import SenseHat sense = SenseHat() sense.show_message(\"Hello World!\") Run the program: python hello_world.py If a Hello World! message is displayed, you're good to proceed. Note If you're new to Sense HAT, follow the getting started tutorial . GrovePi # To install the GrovePi repository, paste and execute the following commands: mkdir ~/Dexter cd ~/Dexter git clone https://github.com/DexterInd/GrovePi cd ~/Dexter/GrovePi/Script bash ./update_grovepi.sh Check if the GrovePi libraries are working correctly: Connect a LED module to GrovePi port D4. In the terminal, type: cd ~/Dexter/GrovePi/Software/Python && python grove_led_blink.py The LED should start blinking. Step 2: Install Svetovid # To install Svetovid, paste and execute the following commands into your command-line terminal: mkdir ~/AVSystem cd ~/AVSystem git clone https://github.com/AVSystem/Svetovid-raspberry-client.git cd Svetovid-raspberry-client sudo dpkg -i svetovid_20.11-raspberry_armhf.deb sudo dpkg -i svetovid-plugin-fsdm_20.11-raspberry_armhf.deb sudo dpkg -i avsystem_svetovid-20.11-raspberry-Linux-fsdmtool-runtime-python.deb In file /usr/local/share/svetovid/bin/fsdm/lwm2m_object_registry.py , find the https://raw.githubusercontent.com/OpenMobileAlliance/lwm2m-registry/test entry and replace it with https://raw.githubusercontent.com/OpenMobileAlliance/lwm2m-registry/prod . Step 3: Register your device in Coiote IoT DM # Disable the Svetovid service: sudo systemctl disable svetovid.service --now Set the server connection details: in /etc/svetovid/config/security.json : { \"1\": { \"ssid\": \"1\", \"server_uri\": \"coaps://eu.iot.avsystem.cloud:5684\", \"is_bootstrap\": \"0\", \"security_mode\": \"psk\", \"pubkey_or_identity_hex\": \"XXXX\", \"privkey_or_psk_hex\": \"XXXX\", \"server_pubkey_hex\": \"\", \"holdoff_s\": \"0\", \"bs_timeout_s\": \"0\" } } in /etc/svetovid/config/svd.json : { \"device\": { \"endpoint_name\": \"YYYY\", \"udp_listen_port\": 1234 }, \"logging\": { \"default_log_level\": \"trace\", \"log_level\": { \"svd\": \"trace\" } }, \"lwm2m_version_config\": { \"min\": \"1.0\", \"max\": \"1.1\" }, \"in_buffer_size_b\": 1024, \"out_buffer_size_b\": 1024, \"msg_cache_size_b\": 65536 } Note XXXX and YYYY should be replaced by the chosen values of endpoint name, PSK identity and PSK key. Tip XXXX values are in hex. To convert your plain text, use the following: echo -n '<your-text-value>' | xxd -p Restart the Svetovid service: sudo systemctl start svetovid.service --now Step 4: Connecting to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote IoT DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. raspberry_pi_test . In the Security mode section, select the security mode you've choosen in Compile the application step: Note If you choose Pre-Shared Key mode then type: In the Key identity field, the same name as in the Endpoint name field. In the Key field, the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. Analyze the objects exposed by the device. Note Your RaspberryPi-based device will feature a number of default LwM2M objects provided by Svetovid, for instance the Light Control /3311 . Step 5: Implement the LwM2M temperature object /3303 (only for GrovePi) # Disable the Svetovid service: sudo systemctl disable svetovid.service --now Generate a stub object in your dm (data model) Svetovid folder by pasting and executing the following command in the terminal: $ sudo svetovid-fsdmtool generate --object 3303 --output-dir /etc/svetovid/dm --generator python Tip You can analyze the resource implementation in the /etc/svetovid/dm/3303 folder. For more details, see the Svetovid page on GitHub . Modify the python script in the /etc/svetovid/dm/3303/Sensor_Value.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore import grovepi import math # Connect the Grove Temperature & Humidity Sensor Pro to digital port D4 # This example uses the blue colored sensor. # SIG,NC,VCC,GND sensor = 4 # The Sensor goes on digital port 4. # temp_humidity_sensor_type # Grove Base Kit comes with the blue sensor. blue = 0 # The Blue colored sensor. white = 1 # The White colored sensor. class ResourceHandler_3303_5700(ResourceHandler): NAME = \"Sensor Value\" DESCRIPTION = '''\\ Last or Current Measured Value from the Sensor.''' DATATYPE = DataType.FLOAT EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise # TODO: print value to stdout # print(0.0) [temp,humidity] = grovepi.dht(sensor,blue) print(\"%.02f\"%(temp)) if __name__ == '__main__': ResourceHandler_3303_5700().main() Modify the python script in the /etc/svetovid/dm/3303/resources/5700.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore import grovepi import math # Connect the Grove Temperature & Humidity Sensor Pro to digital port D4 # This example uses the blue colored sensor. # SIG,NC,VCC,GND sensor = 4 # The Sensor goes on digital port 4. # temp_humidity_sensor_type # Grove Base Kit comes with the blue sensor. blue = 0 # The Blue colored sensor. white = 1 # The White colored sensor. class ResourceHandler_3303_5700(ResourceHandler): NAME = \"Sensor Value\" DESCRIPTION = '''\\ Last or Current Measured Value from the Sensor.''' DATATYPE = DataType.FLOAT EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise # TODO: print value to stdout # print(0.0) [temp,humidity] = grovepi.dht(sensor,blue) print(\"%.02f\"%(temp)) if __name__ == '__main__': ResourceHandler_3303_5700().main() Plug in the temperature sensor to digital port D4 of the GrovePi. Restart the Svetovid service: sudo systemctl restart svetovid.service --now Refresh device state in Coiote IoT DM and see if the Temperature object /3303 has appeared in the Objects tab and values are reported for the Sensor Value 5700 resource: Step 6: Implement the LwM2M push button based on the Multiple Axis Joystick object /3345 # Now you can implement the Push Button module based on the OMA DM Multiple Axis Joystick object /3345. Type in the terminal: $ sudo svetovid-fsdmtool generate --object 3345 --output-dir /etc/svetovid/dm --generator python Tip You can analyze the resource implementation in the /etc/svetovid/dm/3345 folder. For more details, see the Svetovid page on GitHub . Type in the terminal: cd /etc/svetovid/dm/3345/resources && ./5550 read . You should be able to see a default value reported in the command-line terminal. In home directory, create the file ~/button_object_forwarder.py and paste the following into it: SenseHat from sense_hat import SenseHat from time import sleep from fsdm import KvStore sense = SenseHat() sense.clear() #KvStore(namespace=3345).set('counter', 0) #KvStore(namespace=3345).set('state', False) released_before = False counter = 0 while True: for event in sense.stick.get_events(): if event.action == \"pressed\": if event.direction == \"middle\": sense.show_letter(\"M\") KvStore(namespace=3345).set('state', True) if released_before: counter = counter + 1 KvStore(namespace=3345).set('counter', counter) released_before = False elif event.action == \"released\": if event.direction == \"middle\": sense.show_letter(\"m\") KvStore(namespace=3345).set('state', False) released_before = True else: sense.clear() # Wait and clear the screen sleep(0.5) sense.clear() GrovePi from time import sleep import grovepi from fsdm import KvStore button = 3 KvStore(namespace=3345).set('counter', 0) KvStore(namespace=3345).set('state', False) released_before = False counter = 0 grovepi.pinMode(button, \"INPUT\") while True: try: state = grovepi.digitalRead(button) KvStore(namespace=3345).set('state', True) print(\"State:{}\".format(state)) if state == 1: if released_before: counter = counter + 1 print(\"Counter:{}\".format(counter)) KvStore(namespace=3345).set('counter', counter+1) released_before = False KvStore(namespace=3345).set('state', True) else: released_before = True KvStore(namespace=3345).set('state', False) sleep(.2) except IOError: print(\"Error\") Modify the python script in the /etc/svetovid/dm/3345/Digital_Input_Counter.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5501(ResourceHandler): NAME = \"Digital Input Counter\" DESCRIPTION = '''\\ The cumulative value of active state detected.''' DATATYPE = DataType.INTEGER EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise value = KvStore(namespace=3345).get('counter') if value is None: # The value was not set, so it's not found. # raise CoapError.NOT_FOUND value = 0 print(value) # TODO: print value to stdout # print(0) if __name__ == '__main__': ResourceHandler_3345_5501().main() Modify the python script in the /etc/svetovid/dm/3345/Digital_Input_State.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5500(ResourceHandler): NAME = \"Digital Input State\" DESCRIPTION = '''\\ The current state of a digital input.''' DATATYPE = DataType.BOOLEAN EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise state = KvStore(namespace=3345).get('state') if state is None: # The value was not set, so it's not found. raise CoapError.NOT_FOUND #state = False print(state) # TODO: print value to stdout #print(0) if __name__ == '__main__': ResourceHandler_3345_5500().main() Modify the /etc/svetovid/dm/3345/resources/5500 file: #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5500(ResourceHandler): NAME = \"Digital Input State\" DESCRIPTION = '''\\ The current state of a digital input.''' DATATYPE = DataType.BOOLEAN EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise state = KvStore(namespace=3345).get('state') if state is None: # The value was not set, so it's not found. raise CoapError.NOT_FOUND #state = False print(state) # TODO: print value to stdout #print(0) if __name__ == '__main__': ResourceHandler_3345_5500().main() Modify the /etc/svetovid/dm/3345/resources/5501 file: #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5501(ResourceHandler): NAME = \"Digital Input Counter\" DESCRIPTION = '''\\ The cumulative value of active state detected.''' DATATYPE = DataType.INTEGER EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise value = KvStore(namespace=3345).get('counter') if value is None: # The value was not set, so it's not found. # raise CoapError.NOT_FOUND value = 0 print(value) # TODO: print value to stdout # print(0) if __name__ == '__main__': ResourceHandler_3345_5501().main() Plug in the push button to digital port D3 of the GrovePi/Sense HAT. Restart Svetovid: sudo systemctl restart svetovid.service --now Refresh device state in Coiote IoT DM and see if the Multiple Axis Joystick object /3345 has appeared in the Objects tab and values are reported for the Digital Input State 5500 and Digital Input Counter 5501 resources:","title":"LwM2M on a Raspberry Pi"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#implementing-lwm2m-objects-on-raspberry-pi","text":"","title":"Implementing LwM2M objects on Raspberry Pi"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#introduction","text":"Svetovid is a LwM2M client that gives you tools to implement selected LwM2M objects for RaspberryPi-based IoT devices using Python programming language. Svetovid is based on a state-of-the-art Anjay LwM2M client developed by AVSystem. It features the FSDM (File System Data Model) in which LwM2M objects are mapped to folders that follow a particular schema, and executables behave as expected by the LwM2M client that loads and manages them. This tutorial will show you how to implement a temperature LwM2M object on your device and a push button using Svetovid. This will enable live readings of their resources (temperature, push button state and counter) in Coiote IoT DM.","title":"Introduction"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#prerequisites","text":"Raspberry Pi 3 or 4 with a configured operating system and a set-up WiFi connection. A Sense HAT or a GrovePi with a temperature sensor ( DHT11 or similar) and a push button ( Grove-button or similar). A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#step-1-prepare-your-sense-hatgrovepi","text":"","title":"Step 1: Prepare your Sense HAT/GrovePi"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#sense-hat","text":"Install the Sense HAT packages: sudo apt-get install sense-hat Check if Sense HAT is working correctly: Create a hello_world.py file: from sense_hat import SenseHat sense = SenseHat() sense.show_message(\"Hello World!\") Run the program: python hello_world.py If a Hello World! message is displayed, you're good to proceed. Note If you're new to Sense HAT, follow the getting started tutorial .","title":"Sense HAT"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#grovepi","text":"To install the GrovePi repository, paste and execute the following commands: mkdir ~/Dexter cd ~/Dexter git clone https://github.com/DexterInd/GrovePi cd ~/Dexter/GrovePi/Script bash ./update_grovepi.sh Check if the GrovePi libraries are working correctly: Connect a LED module to GrovePi port D4. In the terminal, type: cd ~/Dexter/GrovePi/Software/Python && python grove_led_blink.py The LED should start blinking.","title":"GrovePi"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#step-2-install-svetovid","text":"To install Svetovid, paste and execute the following commands into your command-line terminal: mkdir ~/AVSystem cd ~/AVSystem git clone https://github.com/AVSystem/Svetovid-raspberry-client.git cd Svetovid-raspberry-client sudo dpkg -i svetovid_20.11-raspberry_armhf.deb sudo dpkg -i svetovid-plugin-fsdm_20.11-raspberry_armhf.deb sudo dpkg -i avsystem_svetovid-20.11-raspberry-Linux-fsdmtool-runtime-python.deb In file /usr/local/share/svetovid/bin/fsdm/lwm2m_object_registry.py , find the https://raw.githubusercontent.com/OpenMobileAlliance/lwm2m-registry/test entry and replace it with https://raw.githubusercontent.com/OpenMobileAlliance/lwm2m-registry/prod .","title":"Step 2: Install Svetovid"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#step-3-register-your-device-in-coiote-iot-dm","text":"Disable the Svetovid service: sudo systemctl disable svetovid.service --now Set the server connection details: in /etc/svetovid/config/security.json : { \"1\": { \"ssid\": \"1\", \"server_uri\": \"coaps://eu.iot.avsystem.cloud:5684\", \"is_bootstrap\": \"0\", \"security_mode\": \"psk\", \"pubkey_or_identity_hex\": \"XXXX\", \"privkey_or_psk_hex\": \"XXXX\", \"server_pubkey_hex\": \"\", \"holdoff_s\": \"0\", \"bs_timeout_s\": \"0\" } } in /etc/svetovid/config/svd.json : { \"device\": { \"endpoint_name\": \"YYYY\", \"udp_listen_port\": 1234 }, \"logging\": { \"default_log_level\": \"trace\", \"log_level\": { \"svd\": \"trace\" } }, \"lwm2m_version_config\": { \"min\": \"1.0\", \"max\": \"1.1\" }, \"in_buffer_size_b\": 1024, \"out_buffer_size_b\": 1024, \"msg_cache_size_b\": 65536 } Note XXXX and YYYY should be replaced by the chosen values of endpoint name, PSK identity and PSK key. Tip XXXX values are in hex. To convert your plain text, use the following: echo -n '<your-text-value>' | xxd -p Restart the Svetovid service: sudo systemctl start svetovid.service --now","title":"Step 3: Register your device in Coiote IoT DM"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#step-4-connecting-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board: Log in to Coiote IoT DM and from the left side menu, select Device Inventory . In Device Inventory , click Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Device ID enter your board endpoint name, e.g. raspberry_pi_test . In the Security mode section, select the security mode you've choosen in Compile the application step: Note If you choose Pre-Shared Key mode then type: In the Key identity field, the same name as in the Endpoint name field. In the Key field, the shared secret used in the device-server authentication. Click the Add device button and Confirm in the confirmation pop-up. Analyze the objects exposed by the device. Note Your RaspberryPi-based device will feature a number of default LwM2M objects provided by Svetovid, for instance the Light Control /3311 .","title":"Step 4: Connecting to the LwM2M Server"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#step-5-implement-the-lwm2m-temperature-object-3303-only-for-grovepi","text":"Disable the Svetovid service: sudo systemctl disable svetovid.service --now Generate a stub object in your dm (data model) Svetovid folder by pasting and executing the following command in the terminal: $ sudo svetovid-fsdmtool generate --object 3303 --output-dir /etc/svetovid/dm --generator python Tip You can analyze the resource implementation in the /etc/svetovid/dm/3303 folder. For more details, see the Svetovid page on GitHub . Modify the python script in the /etc/svetovid/dm/3303/Sensor_Value.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore import grovepi import math # Connect the Grove Temperature & Humidity Sensor Pro to digital port D4 # This example uses the blue colored sensor. # SIG,NC,VCC,GND sensor = 4 # The Sensor goes on digital port 4. # temp_humidity_sensor_type # Grove Base Kit comes with the blue sensor. blue = 0 # The Blue colored sensor. white = 1 # The White colored sensor. class ResourceHandler_3303_5700(ResourceHandler): NAME = \"Sensor Value\" DESCRIPTION = '''\\ Last or Current Measured Value from the Sensor.''' DATATYPE = DataType.FLOAT EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise # TODO: print value to stdout # print(0.0) [temp,humidity] = grovepi.dht(sensor,blue) print(\"%.02f\"%(temp)) if __name__ == '__main__': ResourceHandler_3303_5700().main() Modify the python script in the /etc/svetovid/dm/3303/resources/5700.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore import grovepi import math # Connect the Grove Temperature & Humidity Sensor Pro to digital port D4 # This example uses the blue colored sensor. # SIG,NC,VCC,GND sensor = 4 # The Sensor goes on digital port 4. # temp_humidity_sensor_type # Grove Base Kit comes with the blue sensor. blue = 0 # The Blue colored sensor. white = 1 # The White colored sensor. class ResourceHandler_3303_5700(ResourceHandler): NAME = \"Sensor Value\" DESCRIPTION = '''\\ Last or Current Measured Value from the Sensor.''' DATATYPE = DataType.FLOAT EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise # TODO: print value to stdout # print(0.0) [temp,humidity] = grovepi.dht(sensor,blue) print(\"%.02f\"%(temp)) if __name__ == '__main__': ResourceHandler_3303_5700().main() Plug in the temperature sensor to digital port D4 of the GrovePi. Restart the Svetovid service: sudo systemctl restart svetovid.service --now Refresh device state in Coiote IoT DM and see if the Temperature object /3303 has appeared in the Objects tab and values are reported for the Sensor Value 5700 resource:","title":"Step 5: Implement the LwM2M temperature object /3303 (only for GrovePi)"},{"location":"Demo_Projects/Implementing_LwM2M_objects_on_RaspberryPi/#step-6-implement-the-lwm2m-push-button-based-on-the-multiple-axis-joystick-object-3345","text":"Now you can implement the Push Button module based on the OMA DM Multiple Axis Joystick object /3345. Type in the terminal: $ sudo svetovid-fsdmtool generate --object 3345 --output-dir /etc/svetovid/dm --generator python Tip You can analyze the resource implementation in the /etc/svetovid/dm/3345 folder. For more details, see the Svetovid page on GitHub . Type in the terminal: cd /etc/svetovid/dm/3345/resources && ./5550 read . You should be able to see a default value reported in the command-line terminal. In home directory, create the file ~/button_object_forwarder.py and paste the following into it: SenseHat from sense_hat import SenseHat from time import sleep from fsdm import KvStore sense = SenseHat() sense.clear() #KvStore(namespace=3345).set('counter', 0) #KvStore(namespace=3345).set('state', False) released_before = False counter = 0 while True: for event in sense.stick.get_events(): if event.action == \"pressed\": if event.direction == \"middle\": sense.show_letter(\"M\") KvStore(namespace=3345).set('state', True) if released_before: counter = counter + 1 KvStore(namespace=3345).set('counter', counter) released_before = False elif event.action == \"released\": if event.direction == \"middle\": sense.show_letter(\"m\") KvStore(namespace=3345).set('state', False) released_before = True else: sense.clear() # Wait and clear the screen sleep(0.5) sense.clear() GrovePi from time import sleep import grovepi from fsdm import KvStore button = 3 KvStore(namespace=3345).set('counter', 0) KvStore(namespace=3345).set('state', False) released_before = False counter = 0 grovepi.pinMode(button, \"INPUT\") while True: try: state = grovepi.digitalRead(button) KvStore(namespace=3345).set('state', True) print(\"State:{}\".format(state)) if state == 1: if released_before: counter = counter + 1 print(\"Counter:{}\".format(counter)) KvStore(namespace=3345).set('counter', counter+1) released_before = False KvStore(namespace=3345).set('state', True) else: released_before = True KvStore(namespace=3345).set('state', False) sleep(.2) except IOError: print(\"Error\") Modify the python script in the /etc/svetovid/dm/3345/Digital_Input_Counter.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5501(ResourceHandler): NAME = \"Digital Input Counter\" DESCRIPTION = '''\\ The cumulative value of active state detected.''' DATATYPE = DataType.INTEGER EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise value = KvStore(namespace=3345).get('counter') if value is None: # The value was not set, so it's not found. # raise CoapError.NOT_FOUND value = 0 print(value) # TODO: print value to stdout # print(0) if __name__ == '__main__': ResourceHandler_3345_5501().main() Modify the python script in the /etc/svetovid/dm/3345/Digital_Input_State.py file. Open the file, replace the contents with the following script and click Save : #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5500(ResourceHandler): NAME = \"Digital Input State\" DESCRIPTION = '''\\ The current state of a digital input.''' DATATYPE = DataType.BOOLEAN EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise state = KvStore(namespace=3345).get('state') if state is None: # The value was not set, so it's not found. raise CoapError.NOT_FOUND #state = False print(state) # TODO: print value to stdout #print(0) if __name__ == '__main__': ResourceHandler_3345_5500().main() Modify the /etc/svetovid/dm/3345/resources/5500 file: #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5500(ResourceHandler): NAME = \"Digital Input State\" DESCRIPTION = '''\\ The current state of a digital input.''' DATATYPE = DataType.BOOLEAN EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise state = KvStore(namespace=3345).get('state') if state is None: # The value was not set, so it's not found. raise CoapError.NOT_FOUND #state = False print(state) # TODO: print value to stdout #print(0) if __name__ == '__main__': ResourceHandler_3345_5500().main() Modify the /etc/svetovid/dm/3345/resources/5501 file: #!/usr/bin/env python # -*- encoding: utf-8 -*- from fsdm import ResourceHandler, CoapError, DataType, KvStore class ResourceHandler_3345_5501(ResourceHandler): NAME = \"Digital Input Counter\" DESCRIPTION = '''\\ The cumulative value of active state detected.''' DATATYPE = DataType.INTEGER EXTERNAL_NOTIFY = False def read(self, instance_id, # int resource_instance_id): # int for multiple resources, None otherwise value = KvStore(namespace=3345).get('counter') if value is None: # The value was not set, so it's not found. # raise CoapError.NOT_FOUND value = 0 print(value) # TODO: print value to stdout # print(0) if __name__ == '__main__': ResourceHandler_3345_5501().main() Plug in the push button to digital port D3 of the GrovePi/Sense HAT. Restart Svetovid: sudo systemctl restart svetovid.service --now Refresh device state in Coiote IoT DM and see if the Multiple Axis Joystick object /3345 has appeared in the Objects tab and values are reported for the Digital Input State 5500 and Digital Input Counter 5501 resources:","title":"Step 6: Implement the LwM2M push button based on the Multiple Axis Joystick object /3345"},{"location":"Demo_Projects/Tracking_tutorial/","text":"Building a tracking application using the Thingy:91, Azure IoT Hub and Power BI # Introduction # Build a tracking application using the Thingy:91 devkit, while leveraging the benefits of the LwM2M protocol and visualizing its data on Microsoft Power BI . Prerequisites # Thingy:91 with SIM with access to LTE-M or NB-IoT networks Coiote IoT DM account (premium) nRF Cloud account nRF Connect for Desktop Microsoft Azure account Microsoft Power BI account Serial communication program e.g. minicom or RealTerm (for Linux or Mac) or PuTTy (for Windows) Architecture # This tutorial uses the Thingy:91 prototyping platform in combination with the Coiote IoT Device Management platform to build a cellular-connected tracking application. The integration with nRF Cloud Locator enables cell-based localization and optimizes the usage of the onboard GNSS. The location data, in combination with additional telemetry data is sent to Azure IoT Hub and visualized using Microsoft Power BI . See also a tutorial on how to Connect Coiote IoT DM to Azure IoT Hub and visualize data on Power Bi on our YouTube channel. Part 1 - Connect the Thingy:91 to Coiote IoT DM using the LwM2M Anjay client # Set up the Anjay Zephyr Client # Get Zephyr and Python dependencies # To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project . Select and update OS Install dependencies Get Zephyr and install Python dependencies Install Zephyr SDK Clone the Anjay Zephyr repository # Open the command line interface on your machine and clone the Anjay Zephyr repository using Git : git clone https://github.com/AVSystem/Anjay-zephyr-client Compile the demo project # Connect the Thingy:91 board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and run west update using the following commands: west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update For more information about the west build commands, see the Zephyr Project documentation . Go to the directory Anjay-zephyr-client/demo and configure the client using menuconfig . Menuconfig allows for, among others, enabling the GPS and cell-based location services . To open the configuration menu, run the command: west build -b thingy91/nrf9160/ns -p -t menuconfig In the config screen: Open the folder: anjay-zephyr-client ---> Select: Enable manual requests for cell-based location Open the folder: Enable GPS on nRF9160-based devices ---> Select Enable A-GPS using Nordic Location Services over LwM2M After making the configuration changes, close the config menu by pressing Q and save it by pressing Y . Build the project using the updated configuration by running: west build Find the app_signed.hex file under the build/zephyr directory in the project folder. Write the firmware to the Thingy:91 # When using the Thingy:91, use the app_signed.hex file which you can find in the build/zephyr directory. Flash it using Programmer application in nRF Cloud for Desktop via MCUboot . For more information on flashing the Thingy:91 using MCU Boot, see link Powercycle the Thingy:91 to activate the application. Connect the Thingy:91 to Coiote IoT Device Management platform # To connect the board: Log in to Coiote IoT DM and from the left side menu, select Device Inventory . In Device Inventory , select Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: Think of a unique Endpoint name . Key Identity is the same as the Endpoint name. Create a Key and store it somewhere to retrieve later when configuring your device. Click the Add device button and click Confirm in the confirmation pop-up. Configure the Client # With the Thingy:91 still connected to a serial port interface, connect to your device using a serial communication program (e.g. Minicom, RealTerm or PuTTY). Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, press Tab . Check your default credentials by following the instructions in the program: anjay config show Update your device credentials by running the following commands: To make any changes to the configuration, stop the client: anjay stop To update the endpoint name , enter the endpoint name you created in Coiote IoT DM: anjay config set endpoint <endpoint name> To update the Pre-Shared Key , enter the key you created in Coiote IoT DM: anjay config set psk <key> Start the client using the new configurations: anjay start Go to the Coiote IoT DM. If your device is connected successfully its status will change to Registered . Part 2 - Enable nRF Cloud integration # Follow the instructions listed here to enable the nRF Location Service integration. If the connection to nRF Cloud Locator was successful, you will see the device location as a widget in the Coiote IoT DM Device Center. Part 3 - Connect Coiote IoT DM to Microsoft Azure # Start by logging into your Azure account. Create a new IoT Hub and a new storage account . Get the IoT Hub connection string and Azure Blob storage string from your Azure account. For information on how to retrieve these details, see Get the IoT hub connection string . In Coiote IoT DM, click Integrations from the left-side menu and select Hyperscaler Integration Center . Go to the Azure IoT Hub section and click Connect . In the dialog window, paste the IoT Hub connection string and Azure Blob storage string into the relevant fields. Create a new LwM2M template # In Coiote IoT DM, go to Integrations , open the tab Templates and create a new template by clicking the green button + Add new . Name your template and click the button + Add missing objects Select all of the following objects: 0 - LwM2M Security 1 - LwM2M Server 3 - Device 4 - Connectivity Monitoring 5 - Firmware Update 6 - Location 3303 - Temperature 3304 - Humidity 3313 - Accelerometer 3315 - Barometer 3347 - Push button 3420 - LED color light 10256 - ECID-Signal Measurement information 50001 - Location Assistance Set the CAPABILITY TYPE to Telemetry for the resources: 3303 - Temperature /5601 - Min Measured Value /5602 - Max Measured Value /5700 - Sensor Value 3304 - Humidity /5601 - Min Measured Value /5602 - Max Measured Value /5700 - Sensor Value 3313 - Accelerometer /5702 - X Value /5703 - Y Value /5704 - Z Value 3315 - Barometer /5601 - Min Measured Value /5602 - Max Measured Value /5700 - Sensor Value 3347 - LED color light /5500 - Digital Input State /5501 - Digital Input Counter Note Although the Location object 6 sends telemetry data, all location resources need to be configured as Property . Connect your device to Azure # In Coiote IoT DM, visit your Device inventory . Find the device you want to connect to Azure, click the three dots icon and select Connect to Azure . If the connection was successful, your device is now added to your Azure IoT Hub . You can find your device under: Device management > Devices . Set group value tracking on resources in Coiote IoT DM # In Coiote IoT DM, go to Device Groups . Open up the folder hyperscalercenter and open the subfolder which contains your device which is connected to Azure. Go to the Value tracking panel and click Add new . In the pop-up: Provide the resource path: Temperature.0.Sensor Value . In the Notification frequency section, provide the following values: At least once every - set it to 1 hour. Not more often than once every - set it to 10 minutes. Click Add new . Go through the same process for the resources: Humidity.0.Sensor Value , Barometer.0.Sensor Value , Location.0.Latitude and Location.0.Longitude . Part 4 - Connect Microsoft Azure to Power BI # Configuring message routing for sending telemetry data in Azure IoT Hub # Set up message routing # Go to your Azure IoT hub and add message routing: In the left-side menu, under Hub settings , select Message routing and click + Add . Provide a name for your event, e.g. EventRoute . From the Endpoint drop-down list, select events . From the Data source drop-down list, select Device Telemetry Messages . In the Routing query , paste the following: IS_DEFINED($body.lwm2m.6.0.0.value) OR IS_DEFINED($body.lwm2m.6.0.1.value) OR IS_DEFINED($body.lwm2m.3303.0.5700.value) OR IS_DEFINED($body.lwm2m.3304.0.5700.value) OR IS_DEFINED($body.lwm2m.3315.0.5700.value) Click Save . While in the Message routing panel, go to the Enrich messages tab to set up location tracking: For latitude: Name - type lat Value - copy and paste $twin.properties.reported.lwm2m.6.0.0.value Endpoint(s) - select events For longitude: Name - type lon Value - copy and paste $twin.properties.reported.lwm2m.6.0.1.value Endpoint(s) - select events Set up a Stream Analytics Job # Use search to go to Stream analytics jobs and create a job for transferring the gathered data to Power BI. Click + Create and provide the following: Resource group - pick your resource group. Instance Name - e.g. lwm2m-to-powerbi . Region - select the region closest to your device\u2019s location Click Review + Create . Once your deployment is complete, click Go to resource . While in your Stream Analytics job panel, add a stream input and output and write a query : Under Job topology , select Inputs . From the + Add stream input drop-down list, select IoT Hub and provide the following: Input alias - e.g. thingy91-input . Consumer group - pick the $Default group. Click Save . Under Job topology , select Outputs . From the + Add drop-down list, select Power BI In the Power BI right-hand side panel, provide the following: Output alias - e.g. thingy91-output Select - Provide Power BI settings manually Group workspace - The ID can be found in the powerBI URL for the workspace. Authentication mode - User token Dataset name - e.g. AVSystemIoTHubDataSet Table name - e.g. Data Click the button Authorize and login to your Power BI account Click Save . Under Job topology , select Query . Paste the following query into the query input field (remember to adjust your naming inside the query if needed): SELECT CAST(\"lwm2m\".\"3303\".\"0\".\"5700\".value as float) as temperature, CAST(\"lwm2m\".\"3304\".\"0\".\"5700\".value as float) as humidity, CAST(\"lwm2m\".\"3315\".\"0\".\"5700\".value as float) as barometer, CAST(\"lwm2m\".\"3313\".\"0\".\"5702\".value as float) as xValue, CAST(\"lwm2m\".\"3313\".\"0\".\"5703\".value as float) as yValue, CAST(\"lwm2m\".\"3313\".\"0\".\"5704\".value as float) as zValue, GetMetadataPropertyValue(\"thingy91-input\", '[User].[lat]') as lat, GetMetadataPropertyValue(\"thingy91-input\", '[User].[lon]') as lon, EventProcessedUtcTime as processedTimestamp, IoTHub.EnqueuedTime as iotHubTimestamp, IoTHub.ConnectionDeviceId as deviceId INTO \"thingy91-output\" FROM \"thingy91-input\" Click Save query . Click Test query to validate if the query works as expected. In your Stream analytics job, go to Overview and click Start . Confirm by clicking Start again in the right-wide window to run the created query. Data visualization using Power BI # Once the query is finished, you can go to Power BI to create a visualization for the data you have gathered. Go to https://powerbi.microsoft.com/ and sign in to your account. Go to the workspace you connected via Stream Analytics Jobs and find your recently created dataset. Click the more options icon and select Create report . Now start building some nice visualizations, such as a map for your location and line charts for your temperature, humidity and barometer values. Eventually, it may look something like this: Info Did you manage to setup the integration and display data in Power BI? Congratulations! If not, don't worry, there are many engineers ready to support you. Join our AVSystem Discord to get in touch with our experts.","title":"Asset Tracking using Thingy:91 and Power BI"},{"location":"Demo_Projects/Tracking_tutorial/#building-a-tracking-application-using-the-thingy91-azure-iot-hub-and-power-bi","text":"","title":"Building a tracking application using the Thingy:91, Azure IoT Hub and Power BI"},{"location":"Demo_Projects/Tracking_tutorial/#introduction","text":"Build a tracking application using the Thingy:91 devkit, while leveraging the benefits of the LwM2M protocol and visualizing its data on Microsoft Power BI .","title":"Introduction"},{"location":"Demo_Projects/Tracking_tutorial/#prerequisites","text":"Thingy:91 with SIM with access to LTE-M or NB-IoT networks Coiote IoT DM account (premium) nRF Cloud account nRF Connect for Desktop Microsoft Azure account Microsoft Power BI account Serial communication program e.g. minicom or RealTerm (for Linux or Mac) or PuTTy (for Windows)","title":"Prerequisites"},{"location":"Demo_Projects/Tracking_tutorial/#architecture","text":"This tutorial uses the Thingy:91 prototyping platform in combination with the Coiote IoT Device Management platform to build a cellular-connected tracking application. The integration with nRF Cloud Locator enables cell-based localization and optimizes the usage of the onboard GNSS. The location data, in combination with additional telemetry data is sent to Azure IoT Hub and visualized using Microsoft Power BI . See also a tutorial on how to Connect Coiote IoT DM to Azure IoT Hub and visualize data on Power Bi on our YouTube channel.","title":"Architecture"},{"location":"Demo_Projects/Tracking_tutorial/#part-1-connect-the-thingy91-to-coiote-iot-dm-using-the-lwm2m-anjay-client","text":"","title":"Part 1 - Connect the Thingy:91 to Coiote IoT DM using the LwM2M Anjay client"},{"location":"Demo_Projects/Tracking_tutorial/#set-up-the-anjay-zephyr-client","text":"","title":"Set up the Anjay Zephyr Client"},{"location":"Demo_Projects/Tracking_tutorial/#get-zephyr-and-python-dependencies","text":"To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project . Select and update OS Install dependencies Get Zephyr and install Python dependencies Install Zephyr SDK","title":"Get Zephyr and Python dependencies"},{"location":"Demo_Projects/Tracking_tutorial/#clone-the-anjay-zephyr-repository","text":"Open the command line interface on your machine and clone the Anjay Zephyr repository using Git : git clone https://github.com/AVSystem/Anjay-zephyr-client","title":"Clone the Anjay Zephyr repository"},{"location":"Demo_Projects/Tracking_tutorial/#compile-the-demo-project","text":"Connect the Thingy:91 board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and run west update using the following commands: west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update For more information about the west build commands, see the Zephyr Project documentation . Go to the directory Anjay-zephyr-client/demo and configure the client using menuconfig . Menuconfig allows for, among others, enabling the GPS and cell-based location services . To open the configuration menu, run the command: west build -b thingy91/nrf9160/ns -p -t menuconfig In the config screen: Open the folder: anjay-zephyr-client ---> Select: Enable manual requests for cell-based location Open the folder: Enable GPS on nRF9160-based devices ---> Select Enable A-GPS using Nordic Location Services over LwM2M After making the configuration changes, close the config menu by pressing Q and save it by pressing Y . Build the project using the updated configuration by running: west build Find the app_signed.hex file under the build/zephyr directory in the project folder.","title":"Compile the demo project"},{"location":"Demo_Projects/Tracking_tutorial/#write-the-firmware-to-the-thingy91","text":"When using the Thingy:91, use the app_signed.hex file which you can find in the build/zephyr directory. Flash it using Programmer application in nRF Cloud for Desktop via MCUboot . For more information on flashing the Thingy:91 using MCU Boot, see link Powercycle the Thingy:91 to activate the application.","title":"Write the firmware to the Thingy:91"},{"location":"Demo_Projects/Tracking_tutorial/#connect-the-thingy91-to-coiote-iot-device-management-platform","text":"To connect the board: Log in to Coiote IoT DM and from the left side menu, select Device Inventory . In Device Inventory , select Add device . Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: Think of a unique Endpoint name . Key Identity is the same as the Endpoint name. Create a Key and store it somewhere to retrieve later when configuring your device. Click the Add device button and click Confirm in the confirmation pop-up.","title":"Connect the Thingy:91 to Coiote IoT Device Management platform"},{"location":"Demo_Projects/Tracking_tutorial/#configure-the-client","text":"With the Thingy:91 still connected to a serial port interface, connect to your device using a serial communication program (e.g. Minicom, RealTerm or PuTTY). Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, press Tab . Check your default credentials by following the instructions in the program: anjay config show Update your device credentials by running the following commands: To make any changes to the configuration, stop the client: anjay stop To update the endpoint name , enter the endpoint name you created in Coiote IoT DM: anjay config set endpoint <endpoint name> To update the Pre-Shared Key , enter the key you created in Coiote IoT DM: anjay config set psk <key> Start the client using the new configurations: anjay start Go to the Coiote IoT DM. If your device is connected successfully its status will change to Registered .","title":"Configure the Client"},{"location":"Demo_Projects/Tracking_tutorial/#part-2-enable-nrf-cloud-integration","text":"Follow the instructions listed here to enable the nRF Location Service integration. If the connection to nRF Cloud Locator was successful, you will see the device location as a widget in the Coiote IoT DM Device Center.","title":"Part 2 - Enable nRF Cloud integration"},{"location":"Demo_Projects/Tracking_tutorial/#part-3-connect-coiote-iot-dm-to-microsoft-azure","text":"Start by logging into your Azure account. Create a new IoT Hub and a new storage account . Get the IoT Hub connection string and Azure Blob storage string from your Azure account. For information on how to retrieve these details, see Get the IoT hub connection string . In Coiote IoT DM, click Integrations from the left-side menu and select Hyperscaler Integration Center . Go to the Azure IoT Hub section and click Connect . In the dialog window, paste the IoT Hub connection string and Azure Blob storage string into the relevant fields.","title":"Part 3 - Connect Coiote IoT DM to Microsoft Azure"},{"location":"Demo_Projects/Tracking_tutorial/#create-a-new-lwm2m-template","text":"In Coiote IoT DM, go to Integrations , open the tab Templates and create a new template by clicking the green button + Add new . Name your template and click the button + Add missing objects Select all of the following objects: 0 - LwM2M Security 1 - LwM2M Server 3 - Device 4 - Connectivity Monitoring 5 - Firmware Update 6 - Location 3303 - Temperature 3304 - Humidity 3313 - Accelerometer 3315 - Barometer 3347 - Push button 3420 - LED color light 10256 - ECID-Signal Measurement information 50001 - Location Assistance Set the CAPABILITY TYPE to Telemetry for the resources: 3303 - Temperature /5601 - Min Measured Value /5602 - Max Measured Value /5700 - Sensor Value 3304 - Humidity /5601 - Min Measured Value /5602 - Max Measured Value /5700 - Sensor Value 3313 - Accelerometer /5702 - X Value /5703 - Y Value /5704 - Z Value 3315 - Barometer /5601 - Min Measured Value /5602 - Max Measured Value /5700 - Sensor Value 3347 - LED color light /5500 - Digital Input State /5501 - Digital Input Counter Note Although the Location object 6 sends telemetry data, all location resources need to be configured as Property .","title":"Create a new LwM2M template"},{"location":"Demo_Projects/Tracking_tutorial/#connect-your-device-to-azure","text":"In Coiote IoT DM, visit your Device inventory . Find the device you want to connect to Azure, click the three dots icon and select Connect to Azure . If the connection was successful, your device is now added to your Azure IoT Hub . You can find your device under: Device management > Devices .","title":"Connect your device to Azure"},{"location":"Demo_Projects/Tracking_tutorial/#set-group-value-tracking-on-resources-in-coiote-iot-dm","text":"In Coiote IoT DM, go to Device Groups . Open up the folder hyperscalercenter and open the subfolder which contains your device which is connected to Azure. Go to the Value tracking panel and click Add new . In the pop-up: Provide the resource path: Temperature.0.Sensor Value . In the Notification frequency section, provide the following values: At least once every - set it to 1 hour. Not more often than once every - set it to 10 minutes. Click Add new . Go through the same process for the resources: Humidity.0.Sensor Value , Barometer.0.Sensor Value , Location.0.Latitude and Location.0.Longitude .","title":"Set group value tracking on resources in Coiote IoT DM"},{"location":"Demo_Projects/Tracking_tutorial/#part-4-connect-microsoft-azure-to-power-bi","text":"","title":"Part 4 - Connect Microsoft Azure to Power BI"},{"location":"Demo_Projects/Tracking_tutorial/#configuring-message-routing-for-sending-telemetry-data-in-azure-iot-hub","text":"","title":"Configuring message routing for sending telemetry data in Azure IoT Hub"},{"location":"Demo_Projects/Tracking_tutorial/#set-up-message-routing","text":"Go to your Azure IoT hub and add message routing: In the left-side menu, under Hub settings , select Message routing and click + Add . Provide a name for your event, e.g. EventRoute . From the Endpoint drop-down list, select events . From the Data source drop-down list, select Device Telemetry Messages . In the Routing query , paste the following: IS_DEFINED($body.lwm2m.6.0.0.value) OR IS_DEFINED($body.lwm2m.6.0.1.value) OR IS_DEFINED($body.lwm2m.3303.0.5700.value) OR IS_DEFINED($body.lwm2m.3304.0.5700.value) OR IS_DEFINED($body.lwm2m.3315.0.5700.value) Click Save . While in the Message routing panel, go to the Enrich messages tab to set up location tracking: For latitude: Name - type lat Value - copy and paste $twin.properties.reported.lwm2m.6.0.0.value Endpoint(s) - select events For longitude: Name - type lon Value - copy and paste $twin.properties.reported.lwm2m.6.0.1.value Endpoint(s) - select events","title":"Set up message routing"},{"location":"Demo_Projects/Tracking_tutorial/#set-up-a-stream-analytics-job","text":"Use search to go to Stream analytics jobs and create a job for transferring the gathered data to Power BI. Click + Create and provide the following: Resource group - pick your resource group. Instance Name - e.g. lwm2m-to-powerbi . Region - select the region closest to your device\u2019s location Click Review + Create . Once your deployment is complete, click Go to resource . While in your Stream Analytics job panel, add a stream input and output and write a query : Under Job topology , select Inputs . From the + Add stream input drop-down list, select IoT Hub and provide the following: Input alias - e.g. thingy91-input . Consumer group - pick the $Default group. Click Save . Under Job topology , select Outputs . From the + Add drop-down list, select Power BI In the Power BI right-hand side panel, provide the following: Output alias - e.g. thingy91-output Select - Provide Power BI settings manually Group workspace - The ID can be found in the powerBI URL for the workspace. Authentication mode - User token Dataset name - e.g. AVSystemIoTHubDataSet Table name - e.g. Data Click the button Authorize and login to your Power BI account Click Save . Under Job topology , select Query . Paste the following query into the query input field (remember to adjust your naming inside the query if needed): SELECT CAST(\"lwm2m\".\"3303\".\"0\".\"5700\".value as float) as temperature, CAST(\"lwm2m\".\"3304\".\"0\".\"5700\".value as float) as humidity, CAST(\"lwm2m\".\"3315\".\"0\".\"5700\".value as float) as barometer, CAST(\"lwm2m\".\"3313\".\"0\".\"5702\".value as float) as xValue, CAST(\"lwm2m\".\"3313\".\"0\".\"5703\".value as float) as yValue, CAST(\"lwm2m\".\"3313\".\"0\".\"5704\".value as float) as zValue, GetMetadataPropertyValue(\"thingy91-input\", '[User].[lat]') as lat, GetMetadataPropertyValue(\"thingy91-input\", '[User].[lon]') as lon, EventProcessedUtcTime as processedTimestamp, IoTHub.EnqueuedTime as iotHubTimestamp, IoTHub.ConnectionDeviceId as deviceId INTO \"thingy91-output\" FROM \"thingy91-input\" Click Save query . Click Test query to validate if the query works as expected. In your Stream analytics job, go to Overview and click Start . Confirm by clicking Start again in the right-wide window to run the created query.","title":"Set up a Stream Analytics Job"},{"location":"Demo_Projects/Tracking_tutorial/#data-visualization-using-power-bi","text":"Once the query is finished, you can go to Power BI to create a visualization for the data you have gathered. Go to https://powerbi.microsoft.com/ and sign in to your account. Go to the workspace you connected via Stream Analytics Jobs and find your recently created dataset. Click the more options icon and select Create report . Now start building some nice visualizations, such as a map for your location and line charts for your temperature, humidity and barometer values. Eventually, it may look something like this: Info Did you manage to setup the integration and display data in Power BI? Congratulations! If not, don't worry, there are many engineers ready to support you. Join our AVSystem Discord to get in touch with our experts.","title":"Data visualization using Power BI"},{"location":"LwM2M_Client/Getting_started/","text":"Getting started # Start developing LwM2M applications on your boards and IoT devices in just a few clicks using our Anjay LwM2M Client. Espressif ESP32 # M5StickC # Start integration M5StickC/BG96 # Start integration ESP32-DevKitC/BG96 # Start integration STMicroelectronics # Build a LwM2M application for your ST board using I-Cube Anjay from scratch by following our I-CUBE-Anjay guide . STM32L496G-DISCO/BG96 # Integrate your P-L496G-CELL02 Discovery kit board along with the default-provided Quectel BG96 modem using our Anjay LwM2M Client based on freeRTOS. Start integration B-L462E-CELL1/TYPE1SC # Integrate your B-L462E-CELL1 Discovery kit board along with the TYPE 1SE module with built-in eSIM (ST4SIM-200M) using our Anjay LwM2M Client based on freeRTOS. Start integration B-L475E-IOT01A # Integrate your B-L475E-IOT01A Discovery kit board using our Anjay LwM2M Client based on Zephyr OS. Start integration B-U585I-IOT02A/BG96 # Integrate your B-U585I-IOT02A/BG96 Discovery kit board using our Anjay LwM2M Client based on Zephyr OS. Start integration Nordic Semiconductor # Thingy:91 # Integrate your Thingy:91 board using our Anjay LwM2M Client based on Zephyr OS. Start integration nRF9151 DK # Integrate your nRF9151 DK board using our Anjay LwM2M Client based on Zephyr OS. Start integration nRF9160 DK # Integrate your nRF9160 DK board using our Anjay LwM2M Client based on Zephyr OS. Start integration nRF7002 DK # Integrate your nRF7002 DK board using our Anjay LwM2M Client based on Zephyr OS and connect to Coiote through Wi-Fi network. Start integration OpenThread # Connect nRF52840 DK # Integrate your nRF52840 DK board using our Anjay LwM2M Client based on Zephyr OS and OpenThread. Start integration Manage your OpenThread Border Router # Integrate your Linux-based device using our Svetovid LwM2M Client to manage OpenThread Border Router. Start integration","title":"Getting started"},{"location":"LwM2M_Client/Getting_started/#getting-started","text":"Start developing LwM2M applications on your boards and IoT devices in just a few clicks using our Anjay LwM2M Client.","title":"Getting started"},{"location":"LwM2M_Client/Getting_started/#espressif-esp32","text":"","title":"Espressif ESP32"},{"location":"LwM2M_Client/Getting_started/#m5stickc","text":"Start integration","title":"M5StickC"},{"location":"LwM2M_Client/Getting_started/#m5stickcbg96","text":"Start integration","title":"M5StickC/BG96"},{"location":"LwM2M_Client/Getting_started/#esp32-devkitcbg96","text":"Start integration","title":"ESP32-DevKitC/BG96"},{"location":"LwM2M_Client/Getting_started/#stmicroelectronics","text":"Build a LwM2M application for your ST board using I-Cube Anjay from scratch by following our I-CUBE-Anjay guide .","title":"STMicroelectronics"},{"location":"LwM2M_Client/Getting_started/#stm32l496g-discobg96","text":"Integrate your P-L496G-CELL02 Discovery kit board along with the default-provided Quectel BG96 modem using our Anjay LwM2M Client based on freeRTOS. Start integration","title":"STM32L496G-DISCO/BG96"},{"location":"LwM2M_Client/Getting_started/#b-l462e-cell1type1sc","text":"Integrate your B-L462E-CELL1 Discovery kit board along with the TYPE 1SE module with built-in eSIM (ST4SIM-200M) using our Anjay LwM2M Client based on freeRTOS. Start integration","title":"B-L462E-CELL1/TYPE1SC"},{"location":"LwM2M_Client/Getting_started/#b-l475e-iot01a","text":"Integrate your B-L475E-IOT01A Discovery kit board using our Anjay LwM2M Client based on Zephyr OS. Start integration","title":"B-L475E-IOT01A"},{"location":"LwM2M_Client/Getting_started/#b-u585i-iot02abg96","text":"Integrate your B-U585I-IOT02A/BG96 Discovery kit board using our Anjay LwM2M Client based on Zephyr OS. Start integration","title":"B-U585I-IOT02A/BG96"},{"location":"LwM2M_Client/Getting_started/#nordic-semiconductor","text":"","title":"Nordic Semiconductor"},{"location":"LwM2M_Client/Getting_started/#thingy91","text":"Integrate your Thingy:91 board using our Anjay LwM2M Client based on Zephyr OS. Start integration","title":"Thingy:91"},{"location":"LwM2M_Client/Getting_started/#nrf9151-dk","text":"Integrate your nRF9151 DK board using our Anjay LwM2M Client based on Zephyr OS. Start integration","title":"nRF9151 DK"},{"location":"LwM2M_Client/Getting_started/#nrf9160-dk","text":"Integrate your nRF9160 DK board using our Anjay LwM2M Client based on Zephyr OS. Start integration","title":"nRF9160 DK"},{"location":"LwM2M_Client/Getting_started/#nrf7002-dk","text":"Integrate your nRF7002 DK board using our Anjay LwM2M Client based on Zephyr OS and connect to Coiote through Wi-Fi network. Start integration","title":"nRF7002 DK"},{"location":"LwM2M_Client/Getting_started/#openthread","text":"","title":"OpenThread"},{"location":"LwM2M_Client/Getting_started/#connect-nrf52840-dk","text":"Integrate your nRF52840 DK board using our Anjay LwM2M Client based on Zephyr OS and OpenThread. Start integration","title":"Connect nRF52840 DK"},{"location":"LwM2M_Client/Getting_started/#manage-your-openthread-border-router","text":"Integrate your Linux-based device using our Svetovid LwM2M Client to manage OpenThread Border Router. Start integration","title":"Manage your OpenThread Border Router"},{"location":"LwM2M_Client/ESP32/ESP32-DevKitCBG96/","text":"ESP32-DevKitC with BG96 # Integrate your ESP32-based device with Quectel BG96 module to manage it via Coiote IoT DM. Prerequisites # An ESP32 device. A BG96 module with internet connection (it is strongly recommended to have a BG96 with firmware version BG96MAR03A06M1G). Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform . Step 1: Prepare project # Create a project directory for the integration. Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client --recursive . Run . $HOME/esp/esp-idf/export.sh and idf.py set-target esp32 . Open the menuconfig with the idf.py menuconfig command, navigate to Component config -> anjay-esp32-client . In Choose targeted development board , select ESP32-DevKitC and derivatives from the list of supported boards. In Choose an interface , select External BG96 module . In BG96 module configuration , specify the UART port, Tx pin and Rx pin for the BG96 module. Example port and pin numbers are provided in the screenshot below. In Client options , provide device credentials and Server URI: Endpoint name - your device endpoint name Server URI - the address and port of your Coiote IoT DM installation, e.g. coaps://eu.iot.avsystem.cloud:5684 Security mode - the PSK security mode PSK configuration - the PSK identity and PSK key In the Connection configuration , set APN name to internet for the sake of this tutorial. However, APN name depends on your SIM card operator. Press s on the keyboard to Save the configuration. Step 2: Connect BG96 module to a ESP32-DevKitC # Connect the Tx, Rx and GND pins, respectively, to the ESP32-DevKitC pins selected in the previous step. Step 3: Add device to Coiote IoT DM # To connect your ESP32-DevKitC to the Coiote IoT Device Management platform, use your access to a Coiote IoT DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board, log in to the platform and follow onboarding guide . Step 4: Flash ESP32-DevKitC # Open the command line interface, go to your project directory, and run idf.py flash monitor . Next steps # If you want to develop your own LwM2M-enabled application based on ESP32, check Anjay-esp32-client and start prototyping!","title":"ESP32-DevKitC with BG96"},{"location":"LwM2M_Client/ESP32/ESP32-DevKitCBG96/#esp32-devkitc-with-bg96","text":"Integrate your ESP32-based device with Quectel BG96 module to manage it via Coiote IoT DM.","title":"ESP32-DevKitC with BG96"},{"location":"LwM2M_Client/ESP32/ESP32-DevKitCBG96/#prerequisites","text":"An ESP32 device. A BG96 module with internet connection (it is strongly recommended to have a BG96 with firmware version BG96MAR03A06M1G). Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform .","title":"Prerequisites"},{"location":"LwM2M_Client/ESP32/ESP32-DevKitCBG96/#step-1-prepare-project","text":"Create a project directory for the integration. Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client --recursive . Run . $HOME/esp/esp-idf/export.sh and idf.py set-target esp32 . Open the menuconfig with the idf.py menuconfig command, navigate to Component config -> anjay-esp32-client . In Choose targeted development board , select ESP32-DevKitC and derivatives from the list of supported boards. In Choose an interface , select External BG96 module . In BG96 module configuration , specify the UART port, Tx pin and Rx pin for the BG96 module. Example port and pin numbers are provided in the screenshot below. In Client options , provide device credentials and Server URI: Endpoint name - your device endpoint name Server URI - the address and port of your Coiote IoT DM installation, e.g. coaps://eu.iot.avsystem.cloud:5684 Security mode - the PSK security mode PSK configuration - the PSK identity and PSK key In the Connection configuration , set APN name to internet for the sake of this tutorial. However, APN name depends on your SIM card operator. Press s on the keyboard to Save the configuration.","title":"Step 1: Prepare project"},{"location":"LwM2M_Client/ESP32/ESP32-DevKitCBG96/#step-2-connect-bg96-module-to-a-esp32-devkitc","text":"Connect the Tx, Rx and GND pins, respectively, to the ESP32-DevKitC pins selected in the previous step.","title":"Step 2: Connect BG96 module to a ESP32-DevKitC"},{"location":"LwM2M_Client/ESP32/ESP32-DevKitCBG96/#step-3-add-device-to-coiote-iot-dm","text":"To connect your ESP32-DevKitC to the Coiote IoT Device Management platform, use your access to a Coiote IoT DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board, log in to the platform and follow onboarding guide .","title":"Step 3: Add device to Coiote IoT DM"},{"location":"LwM2M_Client/ESP32/ESP32-DevKitCBG96/#step-4-flash-esp32-devkitc","text":"Open the command line interface, go to your project directory, and run idf.py flash monitor .","title":"Step 4: Flash ESP32-DevKitC"},{"location":"LwM2M_Client/ESP32/ESP32-DevKitCBG96/#next-steps","text":"If you want to develop your own LwM2M-enabled application based on ESP32, check Anjay-esp32-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/ESP32/M5Stick/","text":"M5StickC # Integrate your ESP32-based device to manage it via Coiote IoT DM. Prerequisites # An M5StickC device. Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform. Step 1: Download the Anjay ESP32 client files # Create a project directory for the integration. Go to https://github.com/AVSystem/Anjay-esp32-client/releases and download m5stickc-plus.bin and nvs_partition_gen.py to your project directory. Step 2: Configure the client using an NVS partition # Create a nvs_config.csv file and save it in your project directory. In the file, provide your credentials in [wifi_ssid], [wifi_password], [endpoint_name], [identity], [psk], [lwm2m_server_uri] (without the [] brackets). Use the following snippet as a template: key,type,encoding,value config,namespace,, wifi_ssid,data,string,[wifi_ssid] wifi_pswd,data,string,[wifi_password] wifi_inter_en,data,u8,1 endpoint_name,data,string,[endpoint_name] identity,data,string,[identity] psk,data,string,[psk] uri,data,string,[lwm2m_server_uri] writable_wifi,namespace,, wifi_ssid,data,string,[wifi_ssid] wifi_pswd,data,string,[wifi_password] wifi_inter_en,data,u8,0 Note The additional parameters under the writable_wifi namespace are used to provide a secondary Wi-Fi configuration (it is not obligatory). This allows for switching between Wi-Fi configurations while the device is running. Note The nvs_config.csv file can also be downloaded from https://github.com/AVSystem/Anjay-esp32-client/releases Open a command line interface, go to your project directory, and generate the NVS partition: Linux pip3 install future cryptography python3 nvs_partition_gen.py generate nvs_config.csv nvs_config.bin 0x4000 Windows pip3 install future cryptography python nvs_partition_gen.py generate nvs_config.csv nvs_config.bin 0x4000 Step 3: Add device to Coiote IoT DM # To connect your M5StickC to the Coiote IoT Device Management platform, use your access to a Coiote IoT DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board, log in to the platform and follow onboarding guide . Step 4: Flash the board and run device # Connect the M5Stick board to a USB port of your machine and open ESP-IDF command line application. Use pre-built binaries to flash the board and provide credentials by flashing the NVS partition binary. Install the esptool.py : pip install esptool Flash the board: Tip Before flashing the device you should erase the flash first to make sure you have correct settings: Linux esptool.py erase_flash Windows esptool erase_flash Linux esptool.py -b 750000 --chip esp32 write_flash 0x0000 m5stickc-plus.bin Windows esptool -b 750000 --chip esp32 write_flash 0x0000 m5stickc-plus.bin Flash the NVS partition binary: Linux esptool.py -b 750000 --chip esp32 write_flash 0x9000 nvs_config.bin Windows esptool -b 750000 --chip esp32 write_flash 0x9000 nvs_config.bin Once executed, the device will be reset and run with the configuration you provided. M5StickC LwM2M objects # After successful connection to Coiote IoT DM, you can explore the available device objects. Target Objects ESP32 common Security (/0) Server (/1) Device (/3) Firmware Update (/5) WLAN connectivity (/12) M5StickC-Plus Push button (/3347) Light control (/3311) Temperature sensor (/3303) Accelerometer (/3313) Gyroscope (/3343) Upgrade device firmware over the air # To perform a FOTA upgrade, you need an established connection between the M5StickC and Coiote IoT DM (see instructions above). Build new firmware version # Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client . Go to the directory of the cloned repository and run idf.py set-target esp32 . Run git submodule update --recursive --init . Run idf.py menuconfig , navigate to Component config/anjay-esp32-client , and from the supported boards, select M5StickC . Press s and enter to save. Run idf.py build . Once executed, check if the binary file has been built in the following path $PROJECT_DIR/build/anjay-esp32-client/build . Schedule upgrade in Coiote IoT DM # In your Coiote IoT DM account, select your device in Device inventory and click the LwM2M Firmware tab. Click Schedule new firmware upgrade . Click Upload to select the binary file from your local drive, select COAP in the Image delivery protocol , and click Upgrade . Tip The COAPS option is also supported. To use it, you may need to additionally provide the Base URI parameter (depending on your server settings). The FOTA upgrade is now scheduled. Note that it might take a few minutes to complete. Once the upgrade is finished, you can check the new version of the firmware under Current firmware . Next steps # If you want to develop your own LwM2M-enabled application based on M5Stick, check Anjay-esp32-client and start prototyping!","title":"M5StickC"},{"location":"LwM2M_Client/ESP32/M5Stick/#m5stickc","text":"Integrate your ESP32-based device to manage it via Coiote IoT DM.","title":"M5StickC"},{"location":"LwM2M_Client/ESP32/M5Stick/#prerequisites","text":"An M5StickC device. Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"LwM2M_Client/ESP32/M5Stick/#step-1-download-the-anjay-esp32-client-files","text":"Create a project directory for the integration. Go to https://github.com/AVSystem/Anjay-esp32-client/releases and download m5stickc-plus.bin and nvs_partition_gen.py to your project directory.","title":"Step 1: Download the Anjay ESP32 client files"},{"location":"LwM2M_Client/ESP32/M5Stick/#step-2-configure-the-client-using-an-nvs-partition","text":"Create a nvs_config.csv file and save it in your project directory. In the file, provide your credentials in [wifi_ssid], [wifi_password], [endpoint_name], [identity], [psk], [lwm2m_server_uri] (without the [] brackets). Use the following snippet as a template: key,type,encoding,value config,namespace,, wifi_ssid,data,string,[wifi_ssid] wifi_pswd,data,string,[wifi_password] wifi_inter_en,data,u8,1 endpoint_name,data,string,[endpoint_name] identity,data,string,[identity] psk,data,string,[psk] uri,data,string,[lwm2m_server_uri] writable_wifi,namespace,, wifi_ssid,data,string,[wifi_ssid] wifi_pswd,data,string,[wifi_password] wifi_inter_en,data,u8,0 Note The additional parameters under the writable_wifi namespace are used to provide a secondary Wi-Fi configuration (it is not obligatory). This allows for switching between Wi-Fi configurations while the device is running. Note The nvs_config.csv file can also be downloaded from https://github.com/AVSystem/Anjay-esp32-client/releases Open a command line interface, go to your project directory, and generate the NVS partition: Linux pip3 install future cryptography python3 nvs_partition_gen.py generate nvs_config.csv nvs_config.bin 0x4000 Windows pip3 install future cryptography python nvs_partition_gen.py generate nvs_config.csv nvs_config.bin 0x4000","title":"Step 2: Configure the client using an NVS partition"},{"location":"LwM2M_Client/ESP32/M5Stick/#step-3-add-device-to-coiote-iot-dm","text":"To connect your M5StickC to the Coiote IoT Device Management platform, use your access to a Coiote IoT DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board, log in to the platform and follow onboarding guide .","title":"Step 3: Add device to Coiote IoT DM"},{"location":"LwM2M_Client/ESP32/M5Stick/#step-4-flash-the-board-and-run-device","text":"Connect the M5Stick board to a USB port of your machine and open ESP-IDF command line application. Use pre-built binaries to flash the board and provide credentials by flashing the NVS partition binary. Install the esptool.py : pip install esptool Flash the board: Tip Before flashing the device you should erase the flash first to make sure you have correct settings: Linux esptool.py erase_flash Windows esptool erase_flash Linux esptool.py -b 750000 --chip esp32 write_flash 0x0000 m5stickc-plus.bin Windows esptool -b 750000 --chip esp32 write_flash 0x0000 m5stickc-plus.bin Flash the NVS partition binary: Linux esptool.py -b 750000 --chip esp32 write_flash 0x9000 nvs_config.bin Windows esptool -b 750000 --chip esp32 write_flash 0x9000 nvs_config.bin Once executed, the device will be reset and run with the configuration you provided.","title":"Step 4: Flash the board and run device"},{"location":"LwM2M_Client/ESP32/M5Stick/#m5stickc-lwm2m-objects","text":"After successful connection to Coiote IoT DM, you can explore the available device objects. Target Objects ESP32 common Security (/0) Server (/1) Device (/3) Firmware Update (/5) WLAN connectivity (/12) M5StickC-Plus Push button (/3347) Light control (/3311) Temperature sensor (/3303) Accelerometer (/3313) Gyroscope (/3343)","title":"M5StickC LwM2M objects"},{"location":"LwM2M_Client/ESP32/M5Stick/#upgrade-device-firmware-over-the-air","text":"To perform a FOTA upgrade, you need an established connection between the M5StickC and Coiote IoT DM (see instructions above).","title":"Upgrade device firmware over the air"},{"location":"LwM2M_Client/ESP32/M5Stick/#build-new-firmware-version","text":"Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client . Go to the directory of the cloned repository and run idf.py set-target esp32 . Run git submodule update --recursive --init . Run idf.py menuconfig , navigate to Component config/anjay-esp32-client , and from the supported boards, select M5StickC . Press s and enter to save. Run idf.py build . Once executed, check if the binary file has been built in the following path $PROJECT_DIR/build/anjay-esp32-client/build .","title":"Build new firmware version"},{"location":"LwM2M_Client/ESP32/M5Stick/#schedule-upgrade-in-coiote-iot-dm","text":"In your Coiote IoT DM account, select your device in Device inventory and click the LwM2M Firmware tab. Click Schedule new firmware upgrade . Click Upload to select the binary file from your local drive, select COAP in the Image delivery protocol , and click Upgrade . Tip The COAPS option is also supported. To use it, you may need to additionally provide the Base URI parameter (depending on your server settings). The FOTA upgrade is now scheduled. Note that it might take a few minutes to complete. Once the upgrade is finished, you can check the new version of the firmware under Current firmware .","title":"Schedule upgrade in Coiote IoT DM"},{"location":"LwM2M_Client/ESP32/M5Stick/#next-steps","text":"If you want to develop your own LwM2M-enabled application based on M5Stick, check Anjay-esp32-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/ESP32/M5StickBG96/","text":"M5StickC with BG96 # Integrate your ESP32-based device with Quectel BG96 module to manage it via Coiote IoT DM. Prerequisites # An M5StickC device. A BG96 module with internet connection (it is strongly recommended to have a BG96 with firmware version BG96MAR03A06M1G). Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform . Step 1: Prepare project # Create a project directory for the integration. Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client --recursive . Run . $HOME/esp/esp-idf/export.sh and idf.py set-target esp32 . Open the menuconfig with the idf.py menuconfig command, navigate to Component config -> anjay-esp32-client . In Choose targeted development board , select M5StickC from the list of supported boards. In Choose an interface , select External BG96 module . In BG96 module configuration , specify the UART port, Tx pin and Rx pin for the BG96 module. Example port and pin numbers are provided in the screenshot below. In Client options , provide device credentials and Server URI: Endpoint name - your device endpoint name Server URI - the address and port of your Coiote IoT DM installation, e.g. coaps://eu.iot.avsystem.cloud:5684 Security mode - the PSK security mode PSK configuration - the PSK identity and PSK key In the Connection configuration , set APN name to internet for the sake of this tutorial. However, APN name depends on your SIM card operator. Press s on the keyboard to Save the configuration. Step 2: Connect BG96 module to a M5StickC # Connect the Tx, Rx and GND pins, respectively, to the M5StickC pins selected in the previous step on the basis of the following example connection: M5Stick GND > BG96 6 GND M5Stick G26 > BG96 10 UART Rx M5Stick G0 > BG96 8 UART Tx Step 3: Add device to Coiote IoT DM # To connect your M5StickC to the Coiote IoT Device Management platform, use your access to a Coiote IoT DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board, log in to the platform and follow onboarding guide . Step 4: Flash M5StickC # Connect the M5Stick board to a USB port of your machine. Open the command line interface, go to your project directory, and run idf.py -b 750000 flash monitor . Next steps # If you want to develop your own LwM2M-enabled application based on M5Stick, check Anjay-esp32-client and start prototyping!","title":"M5StickC with BG96"},{"location":"LwM2M_Client/ESP32/M5StickBG96/#m5stickc-with-bg96","text":"Integrate your ESP32-based device with Quectel BG96 module to manage it via Coiote IoT DM.","title":"M5StickC with BG96"},{"location":"LwM2M_Client/ESP32/M5StickBG96/#prerequisites","text":"An M5StickC device. A BG96 module with internet connection (it is strongly recommended to have a BG96 with firmware version BG96MAR03A06M1G). Installed ESP-IDF and dependencies (installation steps 1-4 from ESP32 official documentation ). Supported ESP-IDF version is v4.4. A user with access to the Coiote IoT Device Management platform .","title":"Prerequisites"},{"location":"LwM2M_Client/ESP32/M5StickBG96/#step-1-prepare-project","text":"Create a project directory for the integration. Open a command line interface and run git clone https://github.com/AVSystem/Anjay-esp32-client --recursive . Run . $HOME/esp/esp-idf/export.sh and idf.py set-target esp32 . Open the menuconfig with the idf.py menuconfig command, navigate to Component config -> anjay-esp32-client . In Choose targeted development board , select M5StickC from the list of supported boards. In Choose an interface , select External BG96 module . In BG96 module configuration , specify the UART port, Tx pin and Rx pin for the BG96 module. Example port and pin numbers are provided in the screenshot below. In Client options , provide device credentials and Server URI: Endpoint name - your device endpoint name Server URI - the address and port of your Coiote IoT DM installation, e.g. coaps://eu.iot.avsystem.cloud:5684 Security mode - the PSK security mode PSK configuration - the PSK identity and PSK key In the Connection configuration , set APN name to internet for the sake of this tutorial. However, APN name depends on your SIM card operator. Press s on the keyboard to Save the configuration.","title":"Step 1: Prepare project"},{"location":"LwM2M_Client/ESP32/M5StickBG96/#step-2-connect-bg96-module-to-a-m5stickc","text":"Connect the Tx, Rx and GND pins, respectively, to the M5StickC pins selected in the previous step on the basis of the following example connection: M5Stick GND > BG96 6 GND M5Stick G26 > BG96 10 UART Rx M5Stick G0 > BG96 8 UART Tx","title":"Step 2: Connect BG96 module to a M5StickC"},{"location":"LwM2M_Client/ESP32/M5StickBG96/#step-3-add-device-to-coiote-iot-dm","text":"To connect your M5StickC to the Coiote IoT Device Management platform, use your access to a Coiote IoT DM installation, or register at https://eu.iot.avsystem.cloud/ to get access. To connect the board, log in to the platform and follow onboarding guide .","title":"Step 3: Add device to Coiote IoT DM"},{"location":"LwM2M_Client/ESP32/M5StickBG96/#step-4-flash-m5stickc","text":"Connect the M5Stick board to a USB port of your machine. Open the command line interface, go to your project directory, and run idf.py -b 750000 flash monitor .","title":"Step 4: Flash M5StickC"},{"location":"LwM2M_Client/ESP32/M5StickBG96/#next-steps","text":"If you want to develop your own LwM2M-enabled application based on M5Stick, check Anjay-esp32-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/Nordic/Device_Provisioning/","text":"Automated Provisioning for Nordic boards # Introduction # With Factory provisioning for Nordic IoT devices, you can load on-device communication credentials and any cloud-related configuration at the factory level to automate secure device onboarding to Coiote IoT DM cloud. Here\u2019s a tutorial to get you started with device provisioning using a dedicated script to be found in the Anjay Zephyr Client repository . Prerequisites # A Nordic board connected to your computer. Installed Go Programming language . Installed mcumgr command line tool . Zephyr development environment set up. An active Coiote IoT DM cloud account. If you're using Windows: possibility to run Linux scripts/tools either via WSL, Cygwin or other. Important Please verify if the directory to which you installed Go is in your PATH variable. If it's missing please add it. Provision the device using PSK # This section shows how to provision your device using a pre-shared key (PSK). Prepare configuration: Before running the script some configuration should be set. Example configuration can be found in Anjay-zephyr-client/tools/provisioning-tool/configs directory. Edit endpoint_cfg contains LwM2M objects setting that will be uploaded to the device. Set RID.Security.PKOrIdentity and RID.Security.SecretKey . Make sure that RID.Security.Mode is set to 0 . Edit lwm2m_server.json modify domain entry to reflect your domain in Coiote IoT DM server. This file is needed if you wish the script to automatically add the new device to Coiote IoT DM. Get the Coiote IoT DM Access Token The provisioning script can register your device to Coiote IoT DM automatically. You might use this option for the sake of this tutorial, but this is an optional step. Note If you wish to skip device registration to Coiote IoT DM, then call ptool.py without -t and -S options. First an access token needs to be generated. Create get_token.sh file: #!/bin/bash SERVER=\"https://eu.iot.avsystem.cloud\" echo \"Enter your login credentials for $SERVER\" read -p \"Login: \" USER read -p \"Password: \" -s PASS curl -X POST \\ -H \"Content-Type:application/x-www-form-urlencoded\" \\ --data-urlencode \"grant_type=password\" \\ --data-urlencode \"username=$USER\" \\ --data-urlencode \"password=$PASS\" \\ \"$SERVER/api/auth/oauth_password\" If you're using Linux, run chmod u+x get_token.sh to give execute rights. Under Windows you can use the GUI to allow execution of this file. Run ./get_token.sh . The script will ask you for your login and password for eu.iot.avsystem.cloud, please provide them. If a JSON structure containing \"access_token\" appears, you're ready to proceed. Copy your token. Important The token received is valid only for a short period of time. For more informaton how to aquire the access token see REST API authentication . Run provisioning tool Important After creating the correct configuration for provisioning make sure that west configuration is correct and the manifest.path is set to an absolute path. Run: cd Anjay-zephyr-client/demo ./../tools/provisioning-tool/ptool.py -b nrf9160dk/nrf9160/ns -s <SERIAL> \\ -c ../tools/provisioning-tool/configs/endpoint_cfg -t <TOKEN> \\ -S ../tools/provisioning-tool/configs/lwm2m_server.json \\ Important <SERIAL> should be the USB serial number of the connected board. You can check the serial number of your board by running: nrfjprog -i . The <TOKEN> should be the token acquired in previous step. Note To see all of the options available in the script run ./ptool.py -h . If everything went well then your device should be visible in Coiote IoT DM. Provisioning the device using certificates # Now we will show how to provision the device using certificates. This method is very similar to the provisioning the device with PSK and will require just a few additional steps. Note You may need to remove the device from Coiote IoT DM if you finished the steps in previous section and the device is already registered. Coiote IoT DM will not allow registration of the device with the same name. Prepare configuration Like in the PSK example we will modify the configuration found in Anjay-zephyr-client/tools/provisioning-tool/configs directory. Note In this step we will use endpoint_cfg_cert configuration file instead of endpoint_cfg . You may verify that the RID.Security.Mode is set to 2 in this configuration. Edit lwm2m_server.json modify domain entry to reflect your domain in Coiote IoT DM server. Edit cert_info.json . This file contains information for generating a self signed certificate. This configuration is needed only if user don't want to provide certificates generated ealier. Get the certificate for eu.iot.avsystem.cloud . Run: openssl s_client -showcerts eu.iot.avsystem.cloud:5684 > /tmp/server.pem to download server certificate and then openssl x509 -outform der -in /tmp/server.pem -out /tmp/server.der to convert it to DER format. Note The above two commands assumes you use a Linux OS and writes the certificate in the /tmp directory. If using Windows modify the commands by changing \"/tmp\" with some other valid directory. Getting Coiote IoT DM Access Token Repeat this step from previous section to acquire a new token. Run provisioning tool Similar to the example with PSK run: cd Anjay-zephyr-client/demo ./../tools/provisioning-tool/ptool.py -b nrf9160dk/nrf9160/ns -s <SERIAL> \\ -c ../tools/provisioning-tool/configs/endpoint_cfg_cert -t <TOKEN> \\ -S ../tools/provisioning-tool/configs/lwm2m_server.json \\ -C ../tools/provisioning-tool/configs/cert_info.json -p /tmp/server.der Note If you prefer using your own certificates then letting the script create a self signed cert then you can use option -k for providing endpoint private key -r to provide endpoint public cert. Also please remove option -C while running ptool.py . Important Parameters -p , -k and -r should use absoute paths. Important By default the script generates certificates for the device using P-384 elliptic curve. Connect device to Coiote IoT DM The certificates for the device need to be uploaded by hand. To do this fallow those steps: Log in Coiote IoT DM On the left side choose Administration -> DTLS/TLS certificates Click Add File , in a popup window enter a name and upload the public certificate. The self signed certificate generated by the script should be in Anjay-zephyr-client/demo/cert directory. If everyting went well you should see your new certificate and the device should be ready to connect to Coiote IoT DM.","title":"Automated Provisioning for Nordic boards"},{"location":"LwM2M_Client/Nordic/Device_Provisioning/#automated-provisioning-for-nordic-boards","text":"","title":"Automated Provisioning for Nordic boards"},{"location":"LwM2M_Client/Nordic/Device_Provisioning/#introduction","text":"With Factory provisioning for Nordic IoT devices, you can load on-device communication credentials and any cloud-related configuration at the factory level to automate secure device onboarding to Coiote IoT DM cloud. Here\u2019s a tutorial to get you started with device provisioning using a dedicated script to be found in the Anjay Zephyr Client repository .","title":"Introduction"},{"location":"LwM2M_Client/Nordic/Device_Provisioning/#prerequisites","text":"A Nordic board connected to your computer. Installed Go Programming language . Installed mcumgr command line tool . Zephyr development environment set up. An active Coiote IoT DM cloud account. If you're using Windows: possibility to run Linux scripts/tools either via WSL, Cygwin or other. Important Please verify if the directory to which you installed Go is in your PATH variable. If it's missing please add it.","title":"Prerequisites"},{"location":"LwM2M_Client/Nordic/Device_Provisioning/#provision-the-device-using-psk","text":"This section shows how to provision your device using a pre-shared key (PSK). Prepare configuration: Before running the script some configuration should be set. Example configuration can be found in Anjay-zephyr-client/tools/provisioning-tool/configs directory. Edit endpoint_cfg contains LwM2M objects setting that will be uploaded to the device. Set RID.Security.PKOrIdentity and RID.Security.SecretKey . Make sure that RID.Security.Mode is set to 0 . Edit lwm2m_server.json modify domain entry to reflect your domain in Coiote IoT DM server. This file is needed if you wish the script to automatically add the new device to Coiote IoT DM. Get the Coiote IoT DM Access Token The provisioning script can register your device to Coiote IoT DM automatically. You might use this option for the sake of this tutorial, but this is an optional step. Note If you wish to skip device registration to Coiote IoT DM, then call ptool.py without -t and -S options. First an access token needs to be generated. Create get_token.sh file: #!/bin/bash SERVER=\"https://eu.iot.avsystem.cloud\" echo \"Enter your login credentials for $SERVER\" read -p \"Login: \" USER read -p \"Password: \" -s PASS curl -X POST \\ -H \"Content-Type:application/x-www-form-urlencoded\" \\ --data-urlencode \"grant_type=password\" \\ --data-urlencode \"username=$USER\" \\ --data-urlencode \"password=$PASS\" \\ \"$SERVER/api/auth/oauth_password\" If you're using Linux, run chmod u+x get_token.sh to give execute rights. Under Windows you can use the GUI to allow execution of this file. Run ./get_token.sh . The script will ask you for your login and password for eu.iot.avsystem.cloud, please provide them. If a JSON structure containing \"access_token\" appears, you're ready to proceed. Copy your token. Important The token received is valid only for a short period of time. For more informaton how to aquire the access token see REST API authentication . Run provisioning tool Important After creating the correct configuration for provisioning make sure that west configuration is correct and the manifest.path is set to an absolute path. Run: cd Anjay-zephyr-client/demo ./../tools/provisioning-tool/ptool.py -b nrf9160dk/nrf9160/ns -s <SERIAL> \\ -c ../tools/provisioning-tool/configs/endpoint_cfg -t <TOKEN> \\ -S ../tools/provisioning-tool/configs/lwm2m_server.json \\ Important <SERIAL> should be the USB serial number of the connected board. You can check the serial number of your board by running: nrfjprog -i . The <TOKEN> should be the token acquired in previous step. Note To see all of the options available in the script run ./ptool.py -h . If everything went well then your device should be visible in Coiote IoT DM.","title":"Provision the device using PSK"},{"location":"LwM2M_Client/Nordic/Device_Provisioning/#provisioning-the-device-using-certificates","text":"Now we will show how to provision the device using certificates. This method is very similar to the provisioning the device with PSK and will require just a few additional steps. Note You may need to remove the device from Coiote IoT DM if you finished the steps in previous section and the device is already registered. Coiote IoT DM will not allow registration of the device with the same name. Prepare configuration Like in the PSK example we will modify the configuration found in Anjay-zephyr-client/tools/provisioning-tool/configs directory. Note In this step we will use endpoint_cfg_cert configuration file instead of endpoint_cfg . You may verify that the RID.Security.Mode is set to 2 in this configuration. Edit lwm2m_server.json modify domain entry to reflect your domain in Coiote IoT DM server. Edit cert_info.json . This file contains information for generating a self signed certificate. This configuration is needed only if user don't want to provide certificates generated ealier. Get the certificate for eu.iot.avsystem.cloud . Run: openssl s_client -showcerts eu.iot.avsystem.cloud:5684 > /tmp/server.pem to download server certificate and then openssl x509 -outform der -in /tmp/server.pem -out /tmp/server.der to convert it to DER format. Note The above two commands assumes you use a Linux OS and writes the certificate in the /tmp directory. If using Windows modify the commands by changing \"/tmp\" with some other valid directory. Getting Coiote IoT DM Access Token Repeat this step from previous section to acquire a new token. Run provisioning tool Similar to the example with PSK run: cd Anjay-zephyr-client/demo ./../tools/provisioning-tool/ptool.py -b nrf9160dk/nrf9160/ns -s <SERIAL> \\ -c ../tools/provisioning-tool/configs/endpoint_cfg_cert -t <TOKEN> \\ -S ../tools/provisioning-tool/configs/lwm2m_server.json \\ -C ../tools/provisioning-tool/configs/cert_info.json -p /tmp/server.der Note If you prefer using your own certificates then letting the script create a self signed cert then you can use option -k for providing endpoint private key -r to provide endpoint public cert. Also please remove option -C while running ptool.py . Important Parameters -p , -k and -r should use absoute paths. Important By default the script generates certificates for the device using P-384 elliptic curve. Connect device to Coiote IoT DM The certificates for the device need to be uploaded by hand. To do this fallow those steps: Log in Coiote IoT DM On the left side choose Administration -> DTLS/TLS certificates Click Add File , in a popup window enter a name and upload the public certificate. The self signed certificate generated by the script should be in Anjay-zephyr-client/demo/cert directory. If everyting went well you should see your new certificate and the device should be ready to connect to Coiote IoT DM.","title":"Provisioning the device using certificates"},{"location":"LwM2M_Client/Nordic/Runtime_certificate/","text":"Runtime Certificate and Private Key Configuration # Introduction # Anjay library supports secure connection between device and server. Encryption can be achieved with the use of Pre-Shared Key as it was described in nRF9151 DK , nRF9160 DK , nRF7002 DK and Thingy:91 pages or with certificate-based cryptography. In Certificate Mode an asymmetrical algorithm is used to authenticate the connection endpoints and initialize payload encryption. Appropriate certificates need to be generated for both the LwM2M Client and the LwM2M Server. Public certificates of both parties are mutually available, and each party also has access to its corresponding private key. You can read more about secure communication on Anjay's documentation page. Prerequisites # The nRF9160 DK board with a USB cable. Cloned Anjay-zephyr-client repository Note Go through the README's Getting Started part. Installed OpenSSL Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account. Note The runtime certificate and private key configuration do not work with other boards. Build and flash the device # Connect the nRF9160 DK board to a USB port of your machine. Enter the command line interface on your machine and change the directory to the one where you set up the Zephyr project (usually, it's ~/zephyrproject ). Go to your local Anjay-zephyr-client/demo directory Set manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Build a project with a runtime certificate and private key. In order to build application using software cryptography, build using following command: west build -b nrf9160dk/nrf9160/ns -p -- -DEXTRA_CONF_FILE=\"overlay_nrf_mbedtls.conf\" Note This feature works with nRF9160 DK starting from revision v0.14.0, which is used by default for nrf9160dk/nrf9160/ns target, but you can pass revision explicitly in order to protect against further NCS updates. Flash the board with west flash command. Generate certificate # The certificate and private key based on the SECP256R1 curve can be provided through the shell interface in .pem format. To generate To generate a self-signed certificate and key pair open a terminal in the Anjay-zephyr-client/demo directory and use the following commands. openssl ecparam -name secp256r1 -out ecparam.der openssl req -new -x509 -nodes -newkey ec:ecparam.der -keyout demo-cert.key -out cert.pem -days 3650 openssl ec -in demo-cert.key -outform pem -out key.pem Important To use the certificate and private key with Coiote IoT DM you must specify a common name that is the same as the client endpoint name. You will see two files cert.pem and key.pem created in the Anjay-zephyr-client/demo directory. Configure the Client # Provide the generated certificate and private key through the shell in the serial communication program. Note Before setting configurations in Anjay you need to stop running Anjay by anjay stop command. Run these commands and paste the content of the files generated in the previous step. anjay config set public_cert anjay config set private_key Save changes, start Anjay using anjay start command and go to the next step to add a device to Coiote IoT DM. Add device to Coiote IoT DM # Upon logging in to Coiote IoT DM for the first time, you will see the Add your LwM2M device panel. Note If you had previously added a device, in Device inventory , click the Add device button. Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Endpoint name enter your LwM2M device endpoint name, e.g. anjay-zephyr-demo . In the Security mode section, select Certificate mode. Click Upload a new certificate and Browse . In the pop-up, go to the directory where your certificate has been generated, select the cert.pem file and click Open . Click Add device . Note The Endpoint name which you enter to the Coiote IoT DM should be the same as it is in the Client configuration. Click Next , Go to Summary to skip the third step, and Finish to see your Device Center.","title":"Runtime Certificate and Private Key Configuration"},{"location":"LwM2M_Client/Nordic/Runtime_certificate/#runtime-certificate-and-private-key-configuration","text":"","title":"Runtime Certificate and Private Key Configuration"},{"location":"LwM2M_Client/Nordic/Runtime_certificate/#introduction","text":"Anjay library supports secure connection between device and server. Encryption can be achieved with the use of Pre-Shared Key as it was described in nRF9151 DK , nRF9160 DK , nRF7002 DK and Thingy:91 pages or with certificate-based cryptography. In Certificate Mode an asymmetrical algorithm is used to authenticate the connection endpoints and initialize payload encryption. Appropriate certificates need to be generated for both the LwM2M Client and the LwM2M Server. Public certificates of both parties are mutually available, and each party also has access to its corresponding private key. You can read more about secure communication on Anjay's documentation page.","title":"Introduction"},{"location":"LwM2M_Client/Nordic/Runtime_certificate/#prerequisites","text":"The nRF9160 DK board with a USB cable. Cloned Anjay-zephyr-client repository Note Go through the README's Getting Started part. Installed OpenSSL Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account. Note The runtime certificate and private key configuration do not work with other boards.","title":"Prerequisites"},{"location":"LwM2M_Client/Nordic/Runtime_certificate/#build-and-flash-the-device","text":"Connect the nRF9160 DK board to a USB port of your machine. Enter the command line interface on your machine and change the directory to the one where you set up the Zephyr project (usually, it's ~/zephyrproject ). Go to your local Anjay-zephyr-client/demo directory Set manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Build a project with a runtime certificate and private key. In order to build application using software cryptography, build using following command: west build -b nrf9160dk/nrf9160/ns -p -- -DEXTRA_CONF_FILE=\"overlay_nrf_mbedtls.conf\" Note This feature works with nRF9160 DK starting from revision v0.14.0, which is used by default for nrf9160dk/nrf9160/ns target, but you can pass revision explicitly in order to protect against further NCS updates. Flash the board with west flash command.","title":"Build and flash the device"},{"location":"LwM2M_Client/Nordic/Runtime_certificate/#generate-certificate","text":"The certificate and private key based on the SECP256R1 curve can be provided through the shell interface in .pem format. To generate To generate a self-signed certificate and key pair open a terminal in the Anjay-zephyr-client/demo directory and use the following commands. openssl ecparam -name secp256r1 -out ecparam.der openssl req -new -x509 -nodes -newkey ec:ecparam.der -keyout demo-cert.key -out cert.pem -days 3650 openssl ec -in demo-cert.key -outform pem -out key.pem Important To use the certificate and private key with Coiote IoT DM you must specify a common name that is the same as the client endpoint name. You will see two files cert.pem and key.pem created in the Anjay-zephyr-client/demo directory.","title":"Generate certificate"},{"location":"LwM2M_Client/Nordic/Runtime_certificate/#configure-the-client","text":"Provide the generated certificate and private key through the shell in the serial communication program. Note Before setting configurations in Anjay you need to stop running Anjay by anjay stop command. Run these commands and paste the content of the files generated in the previous step. anjay config set public_cert anjay config set private_key Save changes, start Anjay using anjay start command and go to the next step to add a device to Coiote IoT DM.","title":"Configure the Client"},{"location":"LwM2M_Client/Nordic/Runtime_certificate/#add-device-to-coiote-iot-dm","text":"Upon logging in to Coiote IoT DM for the first time, you will see the Add your LwM2M device panel. Note If you had previously added a device, in Device inventory , click the Add device button. Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Endpoint name enter your LwM2M device endpoint name, e.g. anjay-zephyr-demo . In the Security mode section, select Certificate mode. Click Upload a new certificate and Browse . In the pop-up, go to the directory where your certificate has been generated, select the cert.pem file and click Open . Click Add device . Note The Endpoint name which you enter to the Coiote IoT DM should be the same as it is in the Client configuration. Click Next , Go to Summary to skip the third step, and Finish to see your Device Center.","title":"Add device to Coiote IoT DM"},{"location":"LwM2M_Client/Nordic/Thingy91/","text":"Thingy:91 # Integrate your Nordic Thingy:91 board with Coiote IoT DM using the Anjay LwM2M client . Prerequisites # The Thingy:91 board with a USB cable and SIM card. Installed minicom or RealTerm (for Linux or Mac) or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform. Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_thingy91_app_signed.hex file. Jump to the flashing part of the tutorial. Start development using samples # Note If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server . Part 1: Get Zephyr and Python dependencies # To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project . Select and Update OS Install dependencies Get Zephyr and install Python dependencies Install Zephyr SDK Part 2: Clone the Anjay Zephyr repository # Open the command line interface on your machine, then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client Part 3: Compile the demo project # Connect the Thingy:91 board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and run west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Go to the directory Anjay-zephyr-client/demo . Compile the project for Thingy:91 using the command: west build -b thingy91/nrf9160/ns Note [Optional] Configuration of the Anjay client can be done using menuconfig . This allows you, among others, to enable the GPS and cell-based location services . To open the configuration menu, run the command: west build -b thingy91/nrf9160/ns -p -t menuconfig A config screen will open: After making the configuration changes, close the config menu by pressing Q and save it by pressing the key Y . To build the project using the new configuration, run: west build Find the app_signed.hex file under the build/zephyr directory in the project folder. Flash the binaries # To program the board, go through the process of flashing Thingy:91 . Use the nRF Connect Programmer with the downloaded .hex file and follow the program the nRF9160 SiP application section. After successful flashing, reboot the board and go to the next step. Connect to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide . Configure the Client # With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: Tip To show available subcommands, use the Tab key. Check your default credentials by following the instructions in the program: anjay config show Update your device credentials: To make any changes to the configuration, stop the client: anjay stop To update the endpoint name run the command: anjay config set endpoint <endpoint name> To update the Pre-Shared Key , run the command anjay config set psk <key> Start the client using the new configurations: anjay start Go to the Coiote IoT DM to check if your device is connected. Note When Anjay has no connection with the server or network for a long time, warning at_monitor: No heap space for incoming notification: <notification> may appear. It does not affect the operation of the application and will no longer appear after reconnection. Next Steps # After configuring the Anjay Client, you can use the nRF Cloud Location Service to enable cell-based location services, or assisted GPS. Learn how to do it here. Note Thingy:91 uses the same radio for GPS and LTE connectivity. GPS signal is caught between LTE transmissions and in case GPS \"cold\" fix acquisition takes too much time, Anjay turns off LTE transmissions for the time of fix acquisition. It can be seen by the following warning: gps_nrf: GPS was interrupted multiple times by the LTE modem when producing a fix . Anjay is notified by it, enters offline mode and reconnects when the first fix is acquired and LTE is enabled back. Next steps # If you want to develop your own LwM2M-enabled application based on Nordic Thingy:91, check Anjay-zephyr-client and start prototyping!","title":"Thingy:91"},{"location":"LwM2M_Client/Nordic/Thingy91/#thingy91","text":"Integrate your Nordic Thingy:91 board with Coiote IoT DM using the Anjay LwM2M client .","title":"Thingy:91"},{"location":"LwM2M_Client/Nordic/Thingy91/#prerequisites","text":"The Thingy:91 board with a USB cable and SIM card. Installed minicom or RealTerm (for Linux or Mac) or PuTTy (for Windows) or other serial communication program. A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"LwM2M_Client/Nordic/Thingy91/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"LwM2M_Client/Nordic/Thingy91/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_thingy91_app_signed.hex file. Jump to the flashing part of the tutorial.","title":"Use an already built binary"},{"location":"LwM2M_Client/Nordic/Thingy91/#start-development-using-samples","text":"Note If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server .","title":"Start development using samples"},{"location":"LwM2M_Client/Nordic/Thingy91/#part-1-get-zephyr-and-python-dependencies","text":"To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project . Select and Update OS Install dependencies Get Zephyr and install Python dependencies Install Zephyr SDK","title":"Part 1: Get Zephyr and Python dependencies"},{"location":"LwM2M_Client/Nordic/Thingy91/#part-2-clone-the-anjay-zephyr-repository","text":"Open the command line interface on your machine, then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client","title":"Part 2: Clone the Anjay Zephyr repository"},{"location":"LwM2M_Client/Nordic/Thingy91/#part-3-compile-the-demo-project","text":"Connect the Thingy:91 board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and run west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Go to the directory Anjay-zephyr-client/demo . Compile the project for Thingy:91 using the command: west build -b thingy91/nrf9160/ns Note [Optional] Configuration of the Anjay client can be done using menuconfig . This allows you, among others, to enable the GPS and cell-based location services . To open the configuration menu, run the command: west build -b thingy91/nrf9160/ns -p -t menuconfig A config screen will open: After making the configuration changes, close the config menu by pressing Q and save it by pressing the key Y . To build the project using the new configuration, run: west build Find the app_signed.hex file under the build/zephyr directory in the project folder.","title":"Part 3: Compile the demo project"},{"location":"LwM2M_Client/Nordic/Thingy91/#flash-the-binaries","text":"To program the board, go through the process of flashing Thingy:91 . Use the nRF Connect Programmer with the downloaded .hex file and follow the program the nRF9160 SiP application section. After successful flashing, reboot the board and go to the next step.","title":"Flash the binaries"},{"location":"LwM2M_Client/Nordic/Thingy91/#connect-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide .","title":"Connect to the LwM2M Server"},{"location":"LwM2M_Client/Nordic/Thingy91/#configure-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: Tip To show available subcommands, use the Tab key. Check your default credentials by following the instructions in the program: anjay config show Update your device credentials: To make any changes to the configuration, stop the client: anjay stop To update the endpoint name run the command: anjay config set endpoint <endpoint name> To update the Pre-Shared Key , run the command anjay config set psk <key> Start the client using the new configurations: anjay start Go to the Coiote IoT DM to check if your device is connected. Note When Anjay has no connection with the server or network for a long time, warning at_monitor: No heap space for incoming notification: <notification> may appear. It does not affect the operation of the application and will no longer appear after reconnection.","title":"Configure the Client"},{"location":"LwM2M_Client/Nordic/Thingy91/#next-steps","text":"After configuring the Anjay Client, you can use the nRF Cloud Location Service to enable cell-based location services, or assisted GPS. Learn how to do it here. Note Thingy:91 uses the same radio for GPS and LTE connectivity. GPS signal is caught between LTE transmissions and in case GPS \"cold\" fix acquisition takes too much time, Anjay turns off LTE transmissions for the time of fix acquisition. It can be seen by the following warning: gps_nrf: GPS was interrupted multiple times by the LTE modem when producing a fix . Anjay is notified by it, enters offline mode and reconnects when the first fix is acquired and LTE is enabled back.","title":"Next Steps"},{"location":"LwM2M_Client/Nordic/Thingy91/#next-steps_1","text":"If you want to develop your own LwM2M-enabled application based on Nordic Thingy:91, check Anjay-zephyr-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/Nordic/nRF7002DK/","text":"nRF7002 DK # Integrate your Nordic nRF7002 DK board. Prerequisites # The nRF7002 DK board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed nrfjprog from Nordic Semiconductor page . A user with access to the Coiote IoT Device Management platform. Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_nrf7002dk.hex file. Run nrfjprog -f NRF53 --program demo_nrf7002dk.hex --verify --reset Go to the Connect to the LwM2M Server . Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server . Part 1: Getting Zephyr and Python dependencies # To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project (from the set up the OS to installing the Zephyr SDK). Part 2: Cloning the Anjay zephyr repository # Enter the command line interface on your machine and change the directory to the one where you set up the Zephyr project (usually, it's ~/zephyrproject ), then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client Part 3: Compiling the example # Connect the nRF7002 DK board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Compile and flash the project for nRF7002 DK : cd Anjay-zephyr-client/demo west build -b nrf7002dk/nrf5340/cpuapp west flash Connect to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide . Configuring the Client # With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Check your default credentials by following the instructions in the program: Note Use the anjay stop command to stop LwM2M Client if you are going to change credentials. If your default credentials are different from device credentials provided in Coiote IoT DM, change them using the anjay config set <possible_option> <value> command. The nRF7002 DK connects to the Internet via a Wi-Fi network. Remember to set the credentials of your network using anjay config set wifi_ssid <value> and anjay config set wifi_password <value> . Use the anjay start command to run the Client. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You should see your device registered. Next steps # If you want to develop your own LwM2M-enabled application based on Nordic nRF7002 DK, check Anjay-zephyr-client and start prototyping!","title":"nRF7002 DK"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#nrf7002-dk","text":"Integrate your Nordic nRF7002 DK board.","title":"nRF7002 DK"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#prerequisites","text":"The nRF7002 DK board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed nrfjprog from Nordic Semiconductor page . A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_nrf7002dk.hex file. Run nrfjprog -f NRF53 --program demo_nrf7002dk.hex --verify --reset Go to the Connect to the LwM2M Server .","title":"Use an already built binary"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server .","title":"Start development using samples"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#part-1-getting-zephyr-and-python-dependencies","text":"To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project (from the set up the OS to installing the Zephyr SDK).","title":"Part 1: Getting Zephyr and Python dependencies"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#part-2-cloning-the-anjay-zephyr-repository","text":"Enter the command line interface on your machine and change the directory to the one where you set up the Zephyr project (usually, it's ~/zephyrproject ), then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client","title":"Part 2: Cloning the Anjay zephyr repository"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#part-3-compiling-the-example","text":"Connect the nRF7002 DK board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Compile and flash the project for nRF7002 DK : cd Anjay-zephyr-client/demo west build -b nrf7002dk/nrf5340/cpuapp west flash","title":"Part 3: Compiling the example"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#connect-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide .","title":"Connect to the LwM2M Server"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#configuring-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Check your default credentials by following the instructions in the program: Note Use the anjay stop command to stop LwM2M Client if you are going to change credentials. If your default credentials are different from device credentials provided in Coiote IoT DM, change them using the anjay config set <possible_option> <value> command. The nRF7002 DK connects to the Internet via a Wi-Fi network. Remember to set the credentials of your network using anjay config set wifi_ssid <value> and anjay config set wifi_password <value> . Use the anjay start command to run the Client. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You should see your device registered.","title":"Configuring the Client"},{"location":"LwM2M_Client/Nordic/nRF7002DK/#next-steps","text":"If you want to develop your own LwM2M-enabled application based on Nordic nRF7002 DK, check Anjay-zephyr-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/Nordic/nRF9151DK/","text":"nRF9151 DK # Integrate your Nordic nRF9151 DK board. Prerequisites # The nRF9151 DK board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed nRF Connect from Nordic Semiconductor page . A user with access to the Coiote IoT Device Management platform. Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_nrf9151dk_merged.hex file. You may need to update your DK firmware. To do this download new DK firmware from nRF9151 DK Downloads page and follow Updating the modem firmware steps. Use the nRF Connect Programmer and execute steps from the Updating the application firmware section. Skip the point 6 and at the point 7 select already downloaded demo_nrf9151dk_merged.hex file. Go to the Connect to the LwM2M Server . Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server . Part 1: Getting Zephyr and Python dependencies # To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project (from the set up the OS to installing the Zephyr SDK). Part 2: Cloning the Anjay zephyr repository # Enter the command line interface on your machine and change the directory to the one where you set up the Zephyr project (usually, it's ~/zephyrproject ), then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client Part 3: Compiling the example # Connect the nRF9151 DK board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Compile and flash the project for nRF9151 DK : cd Anjay-zephyr-client/demo west build -b nrf9151dk/nrf9151/ns west flash Connect to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide . Configuring the Client # With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Check your default credentials by following the instructions in the program: Note Use the anjay stop command to stop LwM2M Client if you are going to change credentials. If your default credentials are different from device credentials provided in Coiote IoT DM, change them using the anjay config set <possible_option> <value> command. Use the anjay start command to run the Client. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Note nRF9151 DK uses the same radio for GPS and LTE connectivity. GPS signal is caught between LTE transmissions and in case GPS \"cold\" fix acquisition takes too much time, Anjay turns off LTE transmissions for the time of fix acquisition. It can be seen by the following warning: gps_nrf: GPS was interrupted multiple times by the LTE modem when producing a fix . Anjay is notified by it, enters offline mode and reconnects when the first fix is acquired and LTE is enabled back. Next steps # If you want to develop your own LwM2M-enabled application based on Nordic nRF9151 DK, check Anjay-zephyr-client and start prototyping!","title":"nRF9151 DK"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#nrf9151-dk","text":"Integrate your Nordic nRF9151 DK board.","title":"nRF9151 DK"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#prerequisites","text":"The nRF9151 DK board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed nRF Connect from Nordic Semiconductor page . A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_nrf9151dk_merged.hex file. You may need to update your DK firmware. To do this download new DK firmware from nRF9151 DK Downloads page and follow Updating the modem firmware steps. Use the nRF Connect Programmer and execute steps from the Updating the application firmware section. Skip the point 6 and at the point 7 select already downloaded demo_nrf9151dk_merged.hex file. Go to the Connect to the LwM2M Server .","title":"Use an already built binary"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server .","title":"Start development using samples"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#part-1-getting-zephyr-and-python-dependencies","text":"To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project (from the set up the OS to installing the Zephyr SDK).","title":"Part 1: Getting Zephyr and Python dependencies"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#part-2-cloning-the-anjay-zephyr-repository","text":"Enter the command line interface on your machine and change the directory to the one where you set up the Zephyr project (usually, it's ~/zephyrproject ), then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client","title":"Part 2: Cloning the Anjay zephyr repository"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#part-3-compiling-the-example","text":"Connect the nRF9151 DK board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Compile and flash the project for nRF9151 DK : cd Anjay-zephyr-client/demo west build -b nrf9151dk/nrf9151/ns west flash","title":"Part 3: Compiling the example"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#connect-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide .","title":"Connect to the LwM2M Server"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#configuring-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Check your default credentials by following the instructions in the program: Note Use the anjay stop command to stop LwM2M Client if you are going to change credentials. If your default credentials are different from device credentials provided in Coiote IoT DM, change them using the anjay config set <possible_option> <value> command. Use the anjay start command to run the Client. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Note nRF9151 DK uses the same radio for GPS and LTE connectivity. GPS signal is caught between LTE transmissions and in case GPS \"cold\" fix acquisition takes too much time, Anjay turns off LTE transmissions for the time of fix acquisition. It can be seen by the following warning: gps_nrf: GPS was interrupted multiple times by the LTE modem when producing a fix . Anjay is notified by it, enters offline mode and reconnects when the first fix is acquired and LTE is enabled back.","title":"Configuring the Client"},{"location":"LwM2M_Client/Nordic/nRF9151DK/#next-steps","text":"If you want to develop your own LwM2M-enabled application based on Nordic nRF9151 DK, check Anjay-zephyr-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/Nordic/nRF9160DK/","text":"nRF9160 DK # Integrate your Nordic nRF9160 DK board. Prerequisites # The nRF9160 DK board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed nRF Connect from Nordic Semiconductor page . A user with access to the Coiote IoT Device Management platform. Prepare binaries # Use an already built binary # To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_nrf9160dk_merged.hex file. You may need to update your DK firmware. To do this download new DK firmware from nRF9160 DK Downloads page and follow Updating the modem firmware steps. Use the nRF Connect Programmer and execute steps from the Updating the application firmware section. Skip the point 6 and at the point 7 select already downloaded demo_nrf9160dk_merged.hex file. Go to the Connect to the LwM2M Server . Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server . Part 1: Getting Zephyr and Python dependencies # To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project (from the set up the OS to installing the Zephyr SDK). Part 2: Cloning the Anjay zephyr repository # Enter the command line interface on your machine and change the directory to the one where you set up the Zephyr project (usually, it's ~/zephyrproject ), then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client Part 3: Compiling the example # Connect the nRF9160 DK board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Compile and flash the project for nRF9160 DK : cd Anjay-zephyr-client/demo west build -b nrf9160dk/nrf9160/ns west flash Connect to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide . Configuring the Client # With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Check your default credentials by following the instructions in the program: Note Use the anjay stop command to stop LwM2M Client if you are going to change credentials. If your default credentials are different from device credentials provided in Coiote IoT DM, change them using the anjay config set <possible_option> <value> command. Use the anjay start command to run the Client. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Note nRF9160 DK uses the same radio for GPS and LTE connectivity. GPS signal is caught between LTE transmissions and in case GPS \"cold\" fix acquisition takes too much time, Anjay turns off LTE transmissions for the time of fix acquisition. It can be seen by the following warning: gps_nrf: GPS was interrupted multiple times by the LTE modem when producing a fix . Anjay is notified by it, enters offline mode and reconnects when the first fix is acquired and LTE is enabled back. Next steps # If you want to develop your own LwM2M-enabled application based on Nordic nRF9160 DK, check Anjay-zephyr-client and start prototyping!","title":"nRF9160 DK"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#nrf9160-dk","text":"Integrate your Nordic nRF9160 DK board.","title":"nRF9160 DK"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#prerequisites","text":"The nRF9160 DK board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed nRF Connect from Nordic Semiconductor page . A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#use-an-already-built-binary","text":"To get the latest binary file and flash the board: Go to Anjay-zephyr-client . Download the demo_nrf9160dk_merged.hex file. You may need to update your DK firmware. To do this download new DK firmware from nRF9160 DK Downloads page and follow Updating the modem firmware steps. Use the nRF Connect Programmer and execute steps from the Updating the application firmware section. Skip the point 6 and at the point 7 select already downloaded demo_nrf9160dk_merged.hex file. Go to the Connect to the LwM2M Server .","title":"Use an already built binary"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server .","title":"Start development using samples"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#part-1-getting-zephyr-and-python-dependencies","text":"To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project (from the set up the OS to installing the Zephyr SDK).","title":"Part 1: Getting Zephyr and Python dependencies"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#part-2-cloning-the-anjay-zephyr-repository","text":"Enter the command line interface on your machine and change the directory to the one where you set up the Zephyr project (usually, it's ~/zephyrproject ), then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client","title":"Part 2: Cloning the Anjay zephyr repository"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#part-3-compiling-the-example","text":"Connect the nRF9160 DK board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , manifest file to west-nrf.yml , and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Compile and flash the project for nRF9160 DK : cd Anjay-zephyr-client/demo west build -b nrf9160dk/nrf9160/ns west flash","title":"Part 3: Compiling the example"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#connect-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide .","title":"Connect to the LwM2M Server"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#configuring-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Check your default credentials by following the instructions in the program: Note Use the anjay stop command to stop LwM2M Client if you are going to change credentials. If your default credentials are different from device credentials provided in Coiote IoT DM, change them using the anjay config set <possible_option> <value> command. Use the anjay start command to run the Client. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Note nRF9160 DK uses the same radio for GPS and LTE connectivity. GPS signal is caught between LTE transmissions and in case GPS \"cold\" fix acquisition takes too much time, Anjay turns off LTE transmissions for the time of fix acquisition. It can be seen by the following warning: gps_nrf: GPS was interrupted multiple times by the LTE modem when producing a fix . Anjay is notified by it, enters offline mode and reconnects when the first fix is acquired and LTE is enabled back.","title":"Configuring the Client"},{"location":"LwM2M_Client/Nordic/nRF9160DK/#next-steps","text":"If you want to develop your own LwM2M-enabled application based on Nordic nRF9160 DK, check Anjay-zephyr-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/OpenThread/Adding_device/","text":"Adding nRF board to OpenThread # Integrate your Nordic nRF52840 DK board to an active OpenThread Border Router. Prerequisites # An active OpenThread Border Router . The nRF52840 DK board with a USB cable. Installed minicom or RealTerm (for Linux or Mac) or PuTTy (for Windows) or other serial communication program. Installed nrfjprog from Nordic Semiconductor page . A user with access to the Coiote IoT Device Management platform platform and appropriate permissions. Connecting to the OpenThread # Note Check your active Border Router IP address on which your Border Router works (e.g. 192.168.10.3 ) and save it - use your address instead of <OTBR_IP_address> in the next steps. Connecting to the WebUI # You should be in the same network as your OpenThread Border Router. To configure the Border Router open any web browser and connect to the WebUI by typing <OTBR_IP_address>:80 . When you are connected you should see the OpenThread main page: Creating an OpenThread network # On the left side, select the Form option, and a new page will be displayed for the network creation. After providing required credentials, click the FORM button and a message should pop up to let you know about the operation's success. On the left-side menu, click Topology to see the role of Border Router. Commissioning process # To start the commissioning process click Commission on the left-side menu and write down Joiner PSKd password . Important The PSKd needs following: length: 6-32 characters, encoding: base32-thread (0-9, A-Y excluding I, O, Q, and Z for readability). Remember the Joiner PSKd password , you will use it in the next step to configure your device. For more information check here . Click START COMMISSION button, and a message should pop up to inform you about the operation's success. Device configuration # Get Zephyr, SDK and other dependencies, as described in Zephyr's Getting Started Guide (first 4 steps). After navigating to Zephyr workspace ( ~/zephyrproject is default after following Getting Started Guide), clone Anjay Zephyr client repository. git clone https://github.com/AVSystem/Anjay-zephyr-client Connect the nRF52840 board to the USB port of your machine. Because NCS uses a west-nrf.yml file, it is necessary to change our Zephyr workspace, it is handled by using a different manifest file. Set West manifest path to Anjay-zephyr-client/demo , and manifest file to west-nrf.yml and do west update . west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Go to Anjay-zephyr-client/demo/boards directory and find the nrf52840dk_nrf52840.conf file. In this file, you will need to change the joiner PSKd password (the CONFIG_OPENTHREAD_JOINER_PSKD option): # OpenThread CONFIG_OPENTHREAD_JOINER=y CONFIG_OPENTHREAD_JOINER_AUTOSTART=y CONFIG_OPENTHREAD_MANUAL_START=y CONFIG_OPENTHREAD_SLAAC=y CONFIG_OPENTHREAD_JOINER_PSKD=\"00000000001\" CONFIG_OPENTHREAD_FTD=y Note The last config option in the nrf52840dk_nrf52840.conf file ( CONFIG_OPENTHREAD_FTD ) tells about a Full Thread Device (FTD) which always has its radio on and maintains IPv6 address mappings. This option can be changed to CONFIG_OPENTHREAD_MTD , a Minimal Thread Device (MTD) that forwards all messages to its Parent. Now in Anjay-zephyr-client/demo directory you can compile the project. west build -b nrf52840dk/nrf52840 After successful build you can flash the target. west flash Connecting to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide . Configuring the Client # With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Use the anjay stop command to stop LwM2M Client and change credentials. Check your default credentials by following the instructions in the program: Note If your default credentials are different from device credentials provided in Coiote IoT DM, change them using the anjay config set <possible_option> <value> command. Use the anjay start command to run the Client. In logs, you can find information about status of the device. There will be information about success or failure in joining the connection and the current role of your device in the OpenThread network. Go to OpenThread main web page, on the left-side menu click Topology to see connected device. Note The node should join the OTBR Thread network automatically. Within two minutes its state should change to router . Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Note When Anjay has no connection with the server or network for a long time, warning at_monitor: No heap space for incoming notification: <notification> may appear. It does not affect the operation of the application and will no longer appear after reconnection.","title":"Adding nRF board to OpenThread"},{"location":"LwM2M_Client/OpenThread/Adding_device/#adding-nrf-board-to-openthread","text":"Integrate your Nordic nRF52840 DK board to an active OpenThread Border Router.","title":"Adding nRF board to OpenThread"},{"location":"LwM2M_Client/OpenThread/Adding_device/#prerequisites","text":"An active OpenThread Border Router . The nRF52840 DK board with a USB cable. Installed minicom or RealTerm (for Linux or Mac) or PuTTy (for Windows) or other serial communication program. Installed nrfjprog from Nordic Semiconductor page . A user with access to the Coiote IoT Device Management platform platform and appropriate permissions.","title":"Prerequisites"},{"location":"LwM2M_Client/OpenThread/Adding_device/#connecting-to-the-openthread","text":"Note Check your active Border Router IP address on which your Border Router works (e.g. 192.168.10.3 ) and save it - use your address instead of <OTBR_IP_address> in the next steps.","title":"Connecting to the OpenThread"},{"location":"LwM2M_Client/OpenThread/Adding_device/#connecting-to-the-webui","text":"You should be in the same network as your OpenThread Border Router. To configure the Border Router open any web browser and connect to the WebUI by typing <OTBR_IP_address>:80 . When you are connected you should see the OpenThread main page:","title":"Connecting to the WebUI"},{"location":"LwM2M_Client/OpenThread/Adding_device/#creating-an-openthread-network","text":"On the left side, select the Form option, and a new page will be displayed for the network creation. After providing required credentials, click the FORM button and a message should pop up to let you know about the operation's success. On the left-side menu, click Topology to see the role of Border Router.","title":"Creating an OpenThread network"},{"location":"LwM2M_Client/OpenThread/Adding_device/#commissioning-process","text":"To start the commissioning process click Commission on the left-side menu and write down Joiner PSKd password . Important The PSKd needs following: length: 6-32 characters, encoding: base32-thread (0-9, A-Y excluding I, O, Q, and Z for readability). Remember the Joiner PSKd password , you will use it in the next step to configure your device. For more information check here . Click START COMMISSION button, and a message should pop up to inform you about the operation's success.","title":"Commissioning process"},{"location":"LwM2M_Client/OpenThread/Adding_device/#device-configuration","text":"Get Zephyr, SDK and other dependencies, as described in Zephyr's Getting Started Guide (first 4 steps). After navigating to Zephyr workspace ( ~/zephyrproject is default after following Getting Started Guide), clone Anjay Zephyr client repository. git clone https://github.com/AVSystem/Anjay-zephyr-client Connect the nRF52840 board to the USB port of your machine. Because NCS uses a west-nrf.yml file, it is necessary to change our Zephyr workspace, it is handled by using a different manifest file. Set West manifest path to Anjay-zephyr-client/demo , and manifest file to west-nrf.yml and do west update . west config manifest.path Anjay-zephyr-client/demo west config manifest.file west-nrf.yml west update Go to Anjay-zephyr-client/demo/boards directory and find the nrf52840dk_nrf52840.conf file. In this file, you will need to change the joiner PSKd password (the CONFIG_OPENTHREAD_JOINER_PSKD option): # OpenThread CONFIG_OPENTHREAD_JOINER=y CONFIG_OPENTHREAD_JOINER_AUTOSTART=y CONFIG_OPENTHREAD_MANUAL_START=y CONFIG_OPENTHREAD_SLAAC=y CONFIG_OPENTHREAD_JOINER_PSKD=\"00000000001\" CONFIG_OPENTHREAD_FTD=y Note The last config option in the nrf52840dk_nrf52840.conf file ( CONFIG_OPENTHREAD_FTD ) tells about a Full Thread Device (FTD) which always has its radio on and maintains IPv6 address mappings. This option can be changed to CONFIG_OPENTHREAD_MTD , a Minimal Thread Device (MTD) that forwards all messages to its Parent. Now in Anjay-zephyr-client/demo directory you can compile the project. west build -b nrf52840dk/nrf52840 After successful build you can flash the target. west flash","title":"Device configuration"},{"location":"LwM2M_Client/OpenThread/Adding_device/#connecting-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide .","title":"Connecting to the LwM2M Server"},{"location":"LwM2M_Client/OpenThread/Adding_device/#configuring-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Use the anjay stop command to stop LwM2M Client and change credentials. Check your default credentials by following the instructions in the program: Note If your default credentials are different from device credentials provided in Coiote IoT DM, change them using the anjay config set <possible_option> <value> command. Use the anjay start command to run the Client. In logs, you can find information about status of the device. There will be information about success or failure in joining the connection and the current role of your device in the OpenThread network. Go to OpenThread main web page, on the left-side menu click Topology to see connected device. Note The node should join the OTBR Thread network automatically. Within two minutes its state should change to router . Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Note When Anjay has no connection with the server or network for a long time, warning at_monitor: No heap space for incoming notification: <notification> may appear. It does not affect the operation of the application and will no longer appear after reconnection.","title":"Configuring the Client"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/","text":"OpenThread Border Router configurable through LwM2M server # In this tutorial, we will configure OpenThread Border Router with Svetovid which is a LwM2M Client for Linux-based devices based on Anjay . With the help of Svetovid , we will be able to manage the Border Router remotely, through the LwM2M server. Within this guide, we will use the Coiote IoT Device Management platform as the server. Prerequisites # The nRF52840 DK or the nRF52840 Dongle . A Linux-based machine (in this tutorial we will use Raspberry Pi 3 model B with Raspbian) with AMD64 , ARMv7 or ARM64 architecture. Installed Docker Engine . Installed nrfjprog from Nordic Semiconductor page (for nRF52840 DK ) Installed nrfutil from Nordic Semiconductor page (for nRF52840 Dongle ) A user with access to the Coiote IoT Device Management platform. For some commands you will need sudo privileges. Flash Radio Co-Processor # Our Border Router will run on an RCP design, which means that the core of the OpenThread stack will run on the host side and communicate via Spinel protocol with another device with a Thread radio. Now we will build and flash image for Radio Co-Processor. Connect your nRF board to your computer. In case of nRF52840 DK you should choose MCU USB port. Clone the OpenThread repository: git clone --recursive https://github.com/openthread/ot-nrf528xx.git Enter new directory: cd ot-nrf528xx Install required dependencies: script/bootstrap Build the image: nRF52840 DK script/build nrf52840 USB_trans nRF52840 Dongle script/build nrf52840 USB_trans -DOT_BOOTLOADER=USB Note If you have built an image before, don't forget to remove the build directory before the next compilation: rm -rf build Convert the image to the .hex format: arm-none-eabi-objcopy -O ihex build/bin/ot-rcp build/bin/ot-rcp.hex Flash the RCP: nRF52840 DK nrfjprog -f nrf52 --verify --chiperase --program build/bin/ot-rcp.hex --reset After flashing, you must switch the physical USB port called MCU USB to the nRF USB port in order to communicate with the Border Router (although, if you would like to avoid this switching, you can disable the Mass Storage feature on the MCU USB port using J-Link Commander , so that it does not interfere with the core RCP functionalities, but then you will need to change selected transport to UART_trans in the build command). Afterward, set the nRF power source to USB by proper switch on the board. nRF52840 Dongle Install nrf5sdk-tools : nrfutil install nrf5sdk-tools Generate the RCP firmware package: nrfutil pkg generate --hw-version 52 --sd-req=0x00 --application build/bin/ot-rcp.hex --application-version 1 build/bin/ot-rcp.zip Press the reset button to enter the bootloader mode, the onboard LED should start pulsing red. Check the dongle path: ls -l /dev/ttyACM* Flash the dongle (assuming that the dongle path is /dev/ttyACM0 ): nrfutil dfu usb-serial -pkg build/bin/ot-rcp.zip -p /dev/ttyACM0 Connecting to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide . Switch to the target device # If you haven't worked on your target device thus far, it's time to switch to it, in our case it is the Raspberry Pi 3B . Connect the RCP to the target device and continue this tutorial while working on the target device. Downloading Docker image # Download the newest version of svetovid-with-otbr docker image: docker pull avsystemcom/svetovid-with-otbr Shell variables # To make it easier to run the docker container, we will set a bunch of shell variables (note that the variables in the below manner are set for current shell session only, which means that when a new session is opened, the previous variables will not be restored). At first let's check the RCP path: ls -l /dev/ttyACM* And set RCP_PATH variable, for example /dev/ttyACM0 : RCP_PATH='/dev/ttyACM0' Now we will set variables related to LwM2M server and credentials. Server URI (e.g. eu.iot.avsystem.cloud): SERVER_URI='eu.iot.avsystem.cloud' Endpoint name (it will also be used as an DTLS Identity, this is the Key identity field on the server): ENDPOINT_NAME='<your endpoint name>' Pre-shared key: PSK='<your PSK>' Run docker container # Before you run docker container you need to add ip6table_filter module to Linux Kernel: sudo modprobe ip6table_filter After that you can run your image in a new container: docker run --sysctl \"net.ipv6.conf.all.disable_ipv6=0 net.ipv4.conf.all.forwarding=1 net.ipv6.conf.all.forwarding=1\" -p 8080:80 -p 8081:8081 --dns=127.0.0.1 -it --volume $RCP_PATH:$RCP_PATH --privileged -e DNS64_ONLY=1 -e EP=$ENDPOINT_NAME -e PSK=$PSK -e SERVER_HOST=$SERVER_URI avsystemcom/svetovid-with-otbr --radio-url spinel+hdlc+uart://$RCP_PATH Configure your Border Router through Coiote IoT DM # After a while (about 10 minutes) you should see that your Border Router successfully connected to server. Now you can click Next , then Go to Summary , then Finish . You will see your Device Center view. Now you can switch to Data model tab. Here you can find objects related to OpenThread Border Router : /33630 - OTBR Configuration - by using this object you can configure and form a Thread network /33633 - OpenThread Neighbor List - each instance of this object shall correspond to an entry in the local Thread node's neighbor table /33634 - OpenThread Commissioner Joiner Table - each instance of this object shall correspond to a single entry in the commissioner's joiner table /33639 - OpenThread Neighbor Networks - each instance of this object shall correspond to one of the neighboring networks /33640 - OpenThread Join Existing Network - by using this object you can join existing Thread network Form a Thread network # Use the OTBR Configuration object to form a Thread network. Replace all default values from the Network Name , Network Extended PAN ID , PAN ID , Commissioner Credential and Network Key resources to ensure a secure Thread network. Specify the On_Mesh Prefix (e.g. fd11:22::/64 ), select the desired Channel and execute the Form resource to form your Thread network.","title":"OpenThread Border Router configurable through LwM2M server"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/#openthread-border-router-configurable-through-lwm2m-server","text":"In this tutorial, we will configure OpenThread Border Router with Svetovid which is a LwM2M Client for Linux-based devices based on Anjay . With the help of Svetovid , we will be able to manage the Border Router remotely, through the LwM2M server. Within this guide, we will use the Coiote IoT Device Management platform as the server.","title":"OpenThread Border Router configurable through LwM2M server"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/#prerequisites","text":"The nRF52840 DK or the nRF52840 Dongle . A Linux-based machine (in this tutorial we will use Raspberry Pi 3 model B with Raspbian) with AMD64 , ARMv7 or ARM64 architecture. Installed Docker Engine . Installed nrfjprog from Nordic Semiconductor page (for nRF52840 DK ) Installed nrfutil from Nordic Semiconductor page (for nRF52840 Dongle ) A user with access to the Coiote IoT Device Management platform. For some commands you will need sudo privileges.","title":"Prerequisites"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/#flash-radio-co-processor","text":"Our Border Router will run on an RCP design, which means that the core of the OpenThread stack will run on the host side and communicate via Spinel protocol with another device with a Thread radio. Now we will build and flash image for Radio Co-Processor. Connect your nRF board to your computer. In case of nRF52840 DK you should choose MCU USB port. Clone the OpenThread repository: git clone --recursive https://github.com/openthread/ot-nrf528xx.git Enter new directory: cd ot-nrf528xx Install required dependencies: script/bootstrap Build the image: nRF52840 DK script/build nrf52840 USB_trans nRF52840 Dongle script/build nrf52840 USB_trans -DOT_BOOTLOADER=USB Note If you have built an image before, don't forget to remove the build directory before the next compilation: rm -rf build Convert the image to the .hex format: arm-none-eabi-objcopy -O ihex build/bin/ot-rcp build/bin/ot-rcp.hex Flash the RCP: nRF52840 DK nrfjprog -f nrf52 --verify --chiperase --program build/bin/ot-rcp.hex --reset After flashing, you must switch the physical USB port called MCU USB to the nRF USB port in order to communicate with the Border Router (although, if you would like to avoid this switching, you can disable the Mass Storage feature on the MCU USB port using J-Link Commander , so that it does not interfere with the core RCP functionalities, but then you will need to change selected transport to UART_trans in the build command). Afterward, set the nRF power source to USB by proper switch on the board. nRF52840 Dongle Install nrf5sdk-tools : nrfutil install nrf5sdk-tools Generate the RCP firmware package: nrfutil pkg generate --hw-version 52 --sd-req=0x00 --application build/bin/ot-rcp.hex --application-version 1 build/bin/ot-rcp.zip Press the reset button to enter the bootloader mode, the onboard LED should start pulsing red. Check the dongle path: ls -l /dev/ttyACM* Flash the dongle (assuming that the dongle path is /dev/ttyACM0 ): nrfutil dfu usb-serial -pkg build/bin/ot-rcp.zip -p /dev/ttyACM0","title":"Flash Radio Co-Processor"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/#connecting-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide .","title":"Connecting to the LwM2M Server"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/#switch-to-the-target-device","text":"If you haven't worked on your target device thus far, it's time to switch to it, in our case it is the Raspberry Pi 3B . Connect the RCP to the target device and continue this tutorial while working on the target device.","title":"Switch to the target device"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/#downloading-docker-image","text":"Download the newest version of svetovid-with-otbr docker image: docker pull avsystemcom/svetovid-with-otbr","title":"Downloading Docker image"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/#shell-variables","text":"To make it easier to run the docker container, we will set a bunch of shell variables (note that the variables in the below manner are set for current shell session only, which means that when a new session is opened, the previous variables will not be restored). At first let's check the RCP path: ls -l /dev/ttyACM* And set RCP_PATH variable, for example /dev/ttyACM0 : RCP_PATH='/dev/ttyACM0' Now we will set variables related to LwM2M server and credentials. Server URI (e.g. eu.iot.avsystem.cloud): SERVER_URI='eu.iot.avsystem.cloud' Endpoint name (it will also be used as an DTLS Identity, this is the Key identity field on the server): ENDPOINT_NAME='<your endpoint name>' Pre-shared key: PSK='<your PSK>'","title":"Shell variables"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/#run-docker-container","text":"Before you run docker container you need to add ip6table_filter module to Linux Kernel: sudo modprobe ip6table_filter After that you can run your image in a new container: docker run --sysctl \"net.ipv6.conf.all.disable_ipv6=0 net.ipv4.conf.all.forwarding=1 net.ipv6.conf.all.forwarding=1\" -p 8080:80 -p 8081:8081 --dns=127.0.0.1 -it --volume $RCP_PATH:$RCP_PATH --privileged -e DNS64_ONLY=1 -e EP=$ENDPOINT_NAME -e PSK=$PSK -e SERVER_HOST=$SERVER_URI avsystemcom/svetovid-with-otbr --radio-url spinel+hdlc+uart://$RCP_PATH","title":"Run docker container"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/#configure-your-border-router-through-coiote-iot-dm","text":"After a while (about 10 minutes) you should see that your Border Router successfully connected to server. Now you can click Next , then Go to Summary , then Finish . You will see your Device Center view. Now you can switch to Data model tab. Here you can find objects related to OpenThread Border Router : /33630 - OTBR Configuration - by using this object you can configure and form a Thread network /33633 - OpenThread Neighbor List - each instance of this object shall correspond to an entry in the local Thread node's neighbor table /33634 - OpenThread Commissioner Joiner Table - each instance of this object shall correspond to a single entry in the commissioner's joiner table /33639 - OpenThread Neighbor Networks - each instance of this object shall correspond to one of the neighboring networks /33640 - OpenThread Join Existing Network - by using this object you can join existing Thread network","title":"Configure your Border Router through Coiote IoT DM"},{"location":"LwM2M_Client/OpenThread/OTBR_with_svetovid/#form-a-thread-network","text":"Use the OTBR Configuration object to form a Thread network. Replace all default values from the Network Name , Network Extended PAN ID , PAN ID , Commissioner Credential and Network Key resources to ensure a secure Thread network. Specify the On_Mesh Prefix (e.g. fd11:22::/64 ), select the desired Channel and execute the Form resource to form your Thread network.","title":"Form a Thread network"},{"location":"LwM2M_Client/RaspberryPi/RaspberryPi-Pico-W/","text":"Raspberry Pi Pico W # Integrate your Raspberry Pi Pico W board. Prerequisites # A Raspberry Pi Pico W board with a USB cable. A user with access to the Coiote IoT Device Management platform. Prepare binaries # Step 1: Create a workspace # Create a project directory for the integration. Clone the Raspberry Pi Pico SDK and the FreeRTOS kernel into a base directory, parallel to the Anjay-pico-client Github repository: git clone -b 1.5.1 https://github.com/raspberrypi/pico-sdk.git cd pico-sdk/ && git submodule update --init && cd .. git clone -b V10.5.0 https://github.com/FreeRTOS/FreeRTOS-Kernel.git git clone https://github.com/AVSystem/Anjay-pico-client.git Install the required libraries: sudo apt install cmake gcc-arm-none-eabi libnewlib-arm-none-eabi libstdc++-arm-none-eabi-newlib Note If you're using Windows , follow the Installing the ARM Toolchain for Windows instruction on how to install these libraries. If you're using MacOS , run the following command: brew install armmbed/formulae/arm-none-eabi-gcc Compile the application # Go to the Anjay-pico-client repository and update submodules: cd Anjay-pico-client git submodule update --init --recursive mkdir build && cd build Build the project with <ssid> and <pass> replaced with your WIFI name and password respectively. LwM2M Client Endpoint Name is also configured by <endpoint_name> parameter. If you want to use the Pre-Shared Key option, you need to provide <identity> and <psk> : Pre-Shared Key cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. NoSec cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" .. Run the following command to generate the directories named after the examples that contain files with .uf2 and .hex extensions: make -j Note If you're using Windows, add -G \"MinGW Makefiles\" at the end of the cmake command. It will help generate the proper files. Flash the board using bootloader # To program using the bootloader, press and hold the BOOTSEL button while connecting Raspberry Pi Pico W through a USB cable - it should be recognized as a Mass Storage device. Copy the .uf2 file to the open Mass Storage device folder. Depending on the application you want to program, copy the .uf2 file from available directories, e.g. mandatory_objects . Once the Pico has been programmed, disconnect the board and connect it again to make it execute the code. Connect to the LwM2M Server # To connect to a Coiote IoT Device Management platform, register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide .","title":"Raspberry Pi Pico W"},{"location":"LwM2M_Client/RaspberryPi/RaspberryPi-Pico-W/#raspberry-pi-pico-w","text":"Integrate your Raspberry Pi Pico W board.","title":"Raspberry Pi Pico W"},{"location":"LwM2M_Client/RaspberryPi/RaspberryPi-Pico-W/#prerequisites","text":"A Raspberry Pi Pico W board with a USB cable. A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"LwM2M_Client/RaspberryPi/RaspberryPi-Pico-W/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"LwM2M_Client/RaspberryPi/RaspberryPi-Pico-W/#step-1-create-a-workspace","text":"Create a project directory for the integration. Clone the Raspberry Pi Pico SDK and the FreeRTOS kernel into a base directory, parallel to the Anjay-pico-client Github repository: git clone -b 1.5.1 https://github.com/raspberrypi/pico-sdk.git cd pico-sdk/ && git submodule update --init && cd .. git clone -b V10.5.0 https://github.com/FreeRTOS/FreeRTOS-Kernel.git git clone https://github.com/AVSystem/Anjay-pico-client.git Install the required libraries: sudo apt install cmake gcc-arm-none-eabi libnewlib-arm-none-eabi libstdc++-arm-none-eabi-newlib Note If you're using Windows , follow the Installing the ARM Toolchain for Windows instruction on how to install these libraries. If you're using MacOS , run the following command: brew install armmbed/formulae/arm-none-eabi-gcc","title":"Step 1: Create a workspace"},{"location":"LwM2M_Client/RaspberryPi/RaspberryPi-Pico-W/#compile-the-application","text":"Go to the Anjay-pico-client repository and update submodules: cd Anjay-pico-client git submodule update --init --recursive mkdir build && cd build Build the project with <ssid> and <pass> replaced with your WIFI name and password respectively. LwM2M Client Endpoint Name is also configured by <endpoint_name> parameter. If you want to use the Pre-Shared Key option, you need to provide <identity> and <psk> : Pre-Shared Key cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. NoSec cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" .. Run the following command to generate the directories named after the examples that contain files with .uf2 and .hex extensions: make -j Note If you're using Windows, add -G \"MinGW Makefiles\" at the end of the cmake command. It will help generate the proper files.","title":"Compile the application"},{"location":"LwM2M_Client/RaspberryPi/RaspberryPi-Pico-W/#flash-the-board-using-bootloader","text":"To program using the bootloader, press and hold the BOOTSEL button while connecting Raspberry Pi Pico W through a USB cable - it should be recognized as a Mass Storage device. Copy the .uf2 file to the open Mass Storage device folder. Depending on the application you want to program, copy the .uf2 file from available directories, e.g. mandatory_objects . Once the Pico has been programmed, disconnect the board and connect it again to make it execute the code.","title":"Flash the board using bootloader"},{"location":"LwM2M_Client/RaspberryPi/RaspberryPi-Pico-W/#connect-to-the-lwm2m-server","text":"To connect to a Coiote IoT Device Management platform, register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide .","title":"Connect to the LwM2M Server"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/","text":"B-L462E-CELL1/TYPE1SC # Integrate your B-L462E-CELL1 Discovery kit board along with the TYPE 1SE module with built-in eSIM (ST4SIM-200M). Prerequisites # The B-L462E-CELL1/TYPE1SC board with a Micro-USB cable. Installed STM32CubeIDE . The serial communication program, such as minicom (for Linux) or RealTerm or PuTTY (for Windows) installed. A user with access to the Coiote IoT Device Management platform. Prepare Anjay client application # Use an already built binary # To get the latest binary file and flash it to the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L462RE external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can go to Connect to the LwM2M Server right away. Clone the Anjay freeRTOS client repository # Enter the command line interface on your machine and run the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client Build binary and flash the board # Connect the B-L462E-CELL1/TYPE1SC board to a USB port of your machine. Go to the STM32CubeIDE. Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-B-L462E-CELL1-TYPE1SC and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC project: Choose \"Debug\" configuration and build the project by right-clicking on the project name and selecting Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Lauch Configuration Selection , choose the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC option and click OK . After the build and run are complete, the board is flashed with compiled binary. Connect to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide . Configure the Client # With the board still connected to a serial port interface, open your serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented in the program and save it. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use built-in eSIM card Truphone then change APN to iot.truphone.com . Note If you use external SIM card you have to check APN used by SIM card's provider. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab. Anjay-freertos-client with FOTA (Firmware update Over the Air) # Anjay application can be built in basic version (without FOTA) as described in the Build binary and flash the board section. In order to use FOTA, a few additional steps need to be done, e.g. Secure Boot and Secure Firmware Update compilation. The X-CUBE-SBSFU Secure Boot and Secure Firmware Update solution allows the update of the STM32 microcontroller built-in program with new firmware versions, adding new features and correcting issues. The update process is performed in a secure way to prevent unauthorized updates and access to confidential on-device data such as code and firmware encryption key. The Secure Boot (Root of Trust services) is immutable code, always executed after a system reset, that checks STM32 static protections, activates STM32 runtime protections and then verifies the authenticity and integrity of user application code before every execution in order to ensure that invalid or malicious code won't be run. Additional prerequisites # STM32CubeProgrammer installed. Support for shell scripts execution (on Windows for example Git or Cygwin can be used). Python with the following modules: pycryptodomex , ecdsa , numpy , pyelftools . Import B-L462E-CELL1_2_Images_SBSFU and B-L462E-CELL1_2_Images_SECoreBin projects from previously cloned repository to workspace. Prepare binary with SBSFU # Important You need to follow a strict compilation order presented below. Compile SECoreBin application This step is needed to create the Secure Engine core binary including all the trusted code and keys mapped inside the protected environment. The binary is linked with the SBSFU code in step 2. Compile SBSFU application This step compiles the SBSFU source code implementing the state machine and configuring the protections. In addition, it links the code with the SECore binary generated at step 1 in order to generate a single SBSFU binary including the SE trusted code. Compile UserApp application (set Build configuration to Release ) It generates: The user application binary file that is uploaded to the device using the Secure Firmware Update process ( Projects/B-L462E-CELL1/UserApp/Binary/Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.sfb ). A binary file concatenating the SBSFU binary, the user application binary in clear format, and the corresponding FW header ( Projects/B-L462E-CELL1/UserApp/Binary/SBSFU_Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.bin ). Tip You can set a custom firmware version in the Application/Inc/default_config.h file (using FIRMWARE_VERSION define). It will be useful when performing FOTA to distinguish the firmware images from each other. Flash the board with SBSFU binary # Use STM32CubeProgrammer application with SBSFU_Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.bin file to program the board (it is advisable to perform Full chip erase first). You can open serial port to change default credentials in order to connect to Coiote IoT DM. After that, you can use Coiote IoT DM to perform firmware update with Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.sfb file. Important Disable Secure Protection When flashed board with Secure Boot you will need to switch off secure protection to be able to flash the board again. To deactivate secure application please run STM32_Programmer_CLI (Program provided with STM32CubeProgrammer) tool with specific options: ./< path_to_STM32_Programmer_CLI > -c port=SWD mode=UR -ob RDP=0xAA \\ WRP1A_STRT=0xFF WRP1A_END=0x0 WRP1B_STRT=0xFF WRP1B_END=0x0 \\ -ob displ Perform firmware update # In order to perform firmware update: Build the application and flash the board with FIRMWARE_UPDATE define set to the proper version (see Prepare binary with SBSFU step), e.g. #define FIRMWARE_VERSION \"v1.0\" Make changes to the code (optionally), set FIRMWARE_UPDATE define to a different version, e.g. #define FIRMWARE_VERSION \"v2.0\" and build the application with a new firmware. Upload the generated firmware file ( Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.sfb ) to Coiote IoT DM (go to Device management and select Firmware update ) and click Upgrade . After the FOTA finishes, the device will reboot and the following log should appear: Firmware updated from version 'v1.0' to 'v2.0' where v1.0 and v2.0 will be set to firmware versions you set earlier. Next steps # If you want to develop your own LwM2M-enabled application based on STM32 B-L462E-CELL1/TYPE1SC, check Anjay-freertos-client and start prototyping!","title":"B-L462E-CELL1/TYPE1SC"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#b-l462e-cell1type1sc","text":"Integrate your B-L462E-CELL1 Discovery kit board along with the TYPE 1SE module with built-in eSIM (ST4SIM-200M).","title":"B-L462E-CELL1/TYPE1SC"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#prerequisites","text":"The B-L462E-CELL1/TYPE1SC board with a Micro-USB cable. Installed STM32CubeIDE . The serial communication program, such as minicom (for Linux) or RealTerm or PuTTY (for Windows) installed. A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#prepare-anjay-client-application","text":"","title":"Prepare Anjay client application"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#use-an-already-built-binary","text":"To get the latest binary file and flash it to the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L462RE external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished.","title":"Use an already built binary"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can go to Connect to the LwM2M Server right away.","title":"Start development using samples"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#clone-the-anjay-freertos-client-repository","text":"Enter the command line interface on your machine and run the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client","title":"Clone the Anjay freeRTOS client repository"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#build-binary-and-flash-the-board","text":"Connect the B-L462E-CELL1/TYPE1SC board to a USB port of your machine. Go to the STM32CubeIDE. Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-B-L462E-CELL1-TYPE1SC and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC project: Choose \"Debug\" configuration and build the project by right-clicking on the project name and selecting Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Lauch Configuration Selection , choose the Anjay-freertos-client-B-L462E-CELL1-TYPE1SC option and click OK . After the build and run are complete, the board is flashed with compiled binary.","title":"Build binary and flash the board"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#connect-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide .","title":"Connect to the LwM2M Server"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#configure-the-client","text":"With the board still connected to a serial port interface, open your serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented in the program and save it. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use built-in eSIM card Truphone then change APN to iot.truphone.com . Note If you use external SIM card you have to check APN used by SIM card's provider. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"Configure the Client"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#anjay-freertos-client-with-fota-firmware-update-over-the-air","text":"Anjay application can be built in basic version (without FOTA) as described in the Build binary and flash the board section. In order to use FOTA, a few additional steps need to be done, e.g. Secure Boot and Secure Firmware Update compilation. The X-CUBE-SBSFU Secure Boot and Secure Firmware Update solution allows the update of the STM32 microcontroller built-in program with new firmware versions, adding new features and correcting issues. The update process is performed in a secure way to prevent unauthorized updates and access to confidential on-device data such as code and firmware encryption key. The Secure Boot (Root of Trust services) is immutable code, always executed after a system reset, that checks STM32 static protections, activates STM32 runtime protections and then verifies the authenticity and integrity of user application code before every execution in order to ensure that invalid or malicious code won't be run.","title":"Anjay-freertos-client with FOTA (Firmware update Over the Air)"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#additional-prerequisites","text":"STM32CubeProgrammer installed. Support for shell scripts execution (on Windows for example Git or Cygwin can be used). Python with the following modules: pycryptodomex , ecdsa , numpy , pyelftools . Import B-L462E-CELL1_2_Images_SBSFU and B-L462E-CELL1_2_Images_SECoreBin projects from previously cloned repository to workspace.","title":"Additional prerequisites"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#prepare-binary-with-sbsfu","text":"Important You need to follow a strict compilation order presented below. Compile SECoreBin application This step is needed to create the Secure Engine core binary including all the trusted code and keys mapped inside the protected environment. The binary is linked with the SBSFU code in step 2. Compile SBSFU application This step compiles the SBSFU source code implementing the state machine and configuring the protections. In addition, it links the code with the SECore binary generated at step 1 in order to generate a single SBSFU binary including the SE trusted code. Compile UserApp application (set Build configuration to Release ) It generates: The user application binary file that is uploaded to the device using the Secure Firmware Update process ( Projects/B-L462E-CELL1/UserApp/Binary/Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.sfb ). A binary file concatenating the SBSFU binary, the user application binary in clear format, and the corresponding FW header ( Projects/B-L462E-CELL1/UserApp/Binary/SBSFU_Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.bin ). Tip You can set a custom firmware version in the Application/Inc/default_config.h file (using FIRMWARE_VERSION define). It will be useful when performing FOTA to distinguish the firmware images from each other.","title":"Prepare binary with SBSFU"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#flash-the-board-with-sbsfu-binary","text":"Use STM32CubeProgrammer application with SBSFU_Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.bin file to program the board (it is advisable to perform Full chip erase first). You can open serial port to change default credentials in order to connect to Coiote IoT DM. After that, you can use Coiote IoT DM to perform firmware update with Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.sfb file. Important Disable Secure Protection When flashed board with Secure Boot you will need to switch off secure protection to be able to flash the board again. To deactivate secure application please run STM32_Programmer_CLI (Program provided with STM32CubeProgrammer) tool with specific options: ./< path_to_STM32_Programmer_CLI > -c port=SWD mode=UR -ob RDP=0xAA \\ WRP1A_STRT=0xFF WRP1A_END=0x0 WRP1B_STRT=0xFF WRP1B_END=0x0 \\ -ob displ","title":"Flash the board with SBSFU binary"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#perform-firmware-update","text":"In order to perform firmware update: Build the application and flash the board with FIRMWARE_UPDATE define set to the proper version (see Prepare binary with SBSFU step), e.g. #define FIRMWARE_VERSION \"v1.0\" Make changes to the code (optionally), set FIRMWARE_UPDATE define to a different version, e.g. #define FIRMWARE_VERSION \"v2.0\" and build the application with a new firmware. Upload the generated firmware file ( Anjay-freertos-client-B-L462E-CELL1-TYPE1SC.sfb ) to Coiote IoT DM (go to Device management and select Firmware update ) and click Upgrade . After the FOTA finishes, the device will reboot and the following log should appear: Firmware updated from version 'v1.0' to 'v2.0' where v1.0 and v2.0 will be set to firmware versions you set earlier.","title":"Perform firmware update"},{"location":"LwM2M_Client/STMicroelectronics/B-L462E-CELL1-TYPE1SC/#next-steps","text":"If you want to develop your own LwM2M-enabled application based on STM32 B-L462E-CELL1/TYPE1SC, check Anjay-freertos-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/","text":"B-L475E-IOT01A # Integrate your B-L475E-IOT01A Discovery kit board. Prerequisites # The B-L475E-IOT01A board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed ST-Link or OpenOCD debugger. A user with access to the Coiote IoT Device Management platform. Prepare Anjay client application # Use an already built binary # To get the latest binary file and flash it to the board: Go to Anjay-zephyr-client . Download the demo_B-L475E-IOT01A1_merged.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L4IOT external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server . Part 1: Get Zephyr and Python dependencies # To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project . Part 2: Clone the Anjay zephyr repository # Enter the command line interface on your machine, then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client Part 3: Build binary and flash the board # Connect the B-L475E-IOT01A board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , and manifest file to west.yml and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west.yml west update Compile the project for B-L475E-IOT01A using west build -b disco_l475_iot1 --sysbuild in the demo directory. Flash the board using west flash . Connect to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide . Configure the Client # With the board still connected to a serial port interface, open your serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Check your default credentials by following the instructions in the program: Note Use the anjay stop command to stop LwM2M Client and change credentials. If your default credentials are different from device credentials provided in Coiote IoT DM, change them using the anjay config set <possible_option> <value> command. Use the anjay start command to run the Client. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab. Next steps # If you want to develop your own LwM2M-enabled application based on STM32 B-L475E-IOT01A, check Anjay-zephyr-client and start prototyping!","title":"B-L475E-IOT01A"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#b-l475e-iot01a","text":"Integrate your B-L475E-IOT01A Discovery kit board.","title":"B-L475E-IOT01A"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#prerequisites","text":"The B-L475E-IOT01A board with a USB cable. Installed minicom (for Linux) or RealTerm or PuTTy (for Windows) or other serial communication program. Installed ST-Link or OpenOCD debugger. A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#prepare-anjay-client-application","text":"","title":"Prepare Anjay client application"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#use-an-already-built-binary","text":"To get the latest binary file and flash it to the board: Go to Anjay-zephyr-client . Download the demo_B-L475E-IOT01A1_merged.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L4IOT external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished.","title":"Use an already built binary"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server .","title":"Start development using samples"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#part-1-get-zephyr-and-python-dependencies","text":"To get the Zephyr SDK and dependencies follow the first 4 steps of the instruction provided by the Zephyr Project .","title":"Part 1: Get Zephyr and Python dependencies"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#part-2-clone-the-anjay-zephyr-repository","text":"Enter the command line interface on your machine, then paste and run the following command: git clone https://github.com/AVSystem/Anjay-zephyr-client","title":"Part 2: Clone the Anjay zephyr repository"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#part-3-build-binary-and-flash-the-board","text":"Connect the B-L475E-IOT01A board to a USB port of your machine. Set West manifest path to Anjay-zephyr-client/demo , and manifest file to west.yml and do west update : west config manifest.path Anjay-zephyr-client/demo west config manifest.file west.yml west update Compile the project for B-L475E-IOT01A using west build -b disco_l475_iot1 --sysbuild in the demo directory. Flash the board using west flash .","title":"Part 3: Build binary and flash the board"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#connect-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . To connect the board, log in to the platform and follow onboarding guide .","title":"Connect to the LwM2M Server"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#configure-the-client","text":"With the board still connected to a serial port interface, open your serial communication program. Use the anjay command to list possible options: uart:~$ anjay anjay - Anjay commands Subcommands: start :Save config and start Anjay stop :Stop Anjay config :Configure Anjay params Tip To show available subcommands, use the Tab key. Check your default credentials by following the instructions in the program: Note Use the anjay stop command to stop LwM2M Client and change credentials. If your default credentials are different from device credentials provided in Coiote IoT DM, change them using the anjay config set <possible_option> <value> command. Use the anjay start command to run the Client. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"Configure the Client"},{"location":"LwM2M_Client/STMicroelectronics/B-L475E-IOT01A/#next-steps","text":"If you want to develop your own LwM2M-enabled application based on STM32 B-L475E-IOT01A, check Anjay-zephyr-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/","text":"B-U585I-IOT02A/BG96 # Integrate your B-U585I-IOT02A Discovery kit board along with the default-provided Quectel BG96 modem. Prerequisites # The STM32U585I-IOT02A/BG96 board with a Micro-USB cable. The serial communication program, such as minicom (for Linux) or RealTerm or PuTTY (for Windows) installed. A user with access to the Coiote IoT Device Management platform. Optional: installed STM32CubeIDE . Prepare Anjay client application # Use an already built binary # To get the latest binary file and flash it to the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-B-U585I-IOT02A-BG96.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_U585AI external device. You will see a blinking diode on your board. The diode stops blinking as soon as the flashing is finished. Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server . Clone the Anjay freeRTOS client repository # Enter the command line interface on your machine and run the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client Build binary and flash the board # Connect the STM32U585I-IOT02A board to a USB port of your machine. Go to the STM32CubeIDE . Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-B-U585I-IOT02A-BG96 and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-B-U585I-IOT02A-BG96 project: Choose \"Debug\" configuration and build the project by right-clicking on the project name and selecting Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Launch Configuration Selection , choose the Anjay-freertos-client-B-U585I-IOT02A-BG96 option and click OK . After the build and run are complete, the board is flashed with compiled binary. Connect to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register here . Note If you use BG96-based configuration, you must upgrade the firmware of the modem to at least the BG96MAR02A08M1G revision. Older versions may cause unexpected loss of connection. To upgrade this firmware please download the folowing .zip files: - Pack_BG96MAR02A08M1G_01.012.01.012 , - Quectel_LTE_Windows_USB_Driver_V2.0 , - QFlash_V4.10 . In Pack_BG96MAR02A08M1G_01.012.01.012 you will find step-by-step instruction. Step 2 and step 4 in this instruction doesn't work. For that reason you will need to download Quectel_LTE_Windows_USB_Driver_V2.0 file, as a required file for step 2, and QFlash_V4.10 file, as a required file for step 4. To connect the board, log in to the platform and follow onboarding guide . Configure the Client # With the board still connected to a serial port interface, open your serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key, and in the configuration menu, change the default credentials to your data by following the instructions presented in the program, then save it. Tip LwM2M Server URI, endpoint name and other information you can be found in the configuration tab. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use a built-in Truphone eSIM card, change the APN to iot.truphone.com . Note If you use an external SIM card, you need to verify the APN used by your SIM card provider. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Next steps # If you want to develop your own LwM2M-enabled application based on STM32 B-U585I-IOT02A, check Anjay-freertos-client and start prototyping!","title":"B-U585I-IOT02A/BG96"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/#b-u585i-iot02abg96","text":"Integrate your B-U585I-IOT02A Discovery kit board along with the default-provided Quectel BG96 modem.","title":"B-U585I-IOT02A/BG96"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/#prerequisites","text":"The STM32U585I-IOT02A/BG96 board with a Micro-USB cable. The serial communication program, such as minicom (for Linux) or RealTerm or PuTTY (for Windows) installed. A user with access to the Coiote IoT Device Management platform. Optional: installed STM32CubeIDE .","title":"Prerequisites"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/#prepare-anjay-client-application","text":"","title":"Prepare Anjay client application"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/#use-an-already-built-binary","text":"To get the latest binary file and flash it to the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-B-U585I-IOT02A-BG96.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_U585AI external device. You will see a blinking diode on your board. The diode stops blinking as soon as the flashing is finished.","title":"Use an already built binary"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can jump to Connect to the LwM2M Server .","title":"Start development using samples"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/#clone-the-anjay-freertos-client-repository","text":"Enter the command line interface on your machine and run the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client","title":"Clone the Anjay freeRTOS client repository"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/#build-binary-and-flash-the-board","text":"Connect the STM32U585I-IOT02A board to a USB port of your machine. Go to the STM32CubeIDE . Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-B-U585I-IOT02A-BG96 and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-B-U585I-IOT02A-BG96 project: Choose \"Debug\" configuration and build the project by right-clicking on the project name and selecting Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Launch Configuration Selection , choose the Anjay-freertos-client-B-U585I-IOT02A-BG96 option and click OK . After the build and run are complete, the board is flashed with compiled binary.","title":"Build binary and flash the board"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/#connect-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register here . Note If you use BG96-based configuration, you must upgrade the firmware of the modem to at least the BG96MAR02A08M1G revision. Older versions may cause unexpected loss of connection. To upgrade this firmware please download the folowing .zip files: - Pack_BG96MAR02A08M1G_01.012.01.012 , - Quectel_LTE_Windows_USB_Driver_V2.0 , - QFlash_V4.10 . In Pack_BG96MAR02A08M1G_01.012.01.012 you will find step-by-step instruction. Step 2 and step 4 in this instruction doesn't work. For that reason you will need to download Quectel_LTE_Windows_USB_Driver_V2.0 file, as a required file for step 2, and QFlash_V4.10 file, as a required file for step 4. To connect the board, log in to the platform and follow onboarding guide .","title":"Connect to the LwM2M Server"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/#configure-the-client","text":"With the board still connected to a serial port interface, open your serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key, and in the configuration menu, change the default credentials to your data by following the instructions presented in the program, then save it. Tip LwM2M Server URI, endpoint name and other information you can be found in the configuration tab. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use a built-in Truphone eSIM card, change the APN to iot.truphone.com . Note If you use an external SIM card, you need to verify the APN used by your SIM card provider. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view:","title":"Configure the Client"},{"location":"LwM2M_Client/STMicroelectronics/B-U585I-IOT02A-BG96/#next-steps","text":"If you want to develop your own LwM2M-enabled application based on STM32 B-U585I-IOT02A, check Anjay-freertos-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/STMicroelectronics/Runtime_certificate/","text":"Runtime Certificate and Private Key Configuration # Introduction # Anjay library supports secure connection between device and server. Encryption can be achieved with the use of Pre-Shared Key as it was described in STM32L496G-DISCO/BG96 , B-L462E-CELL1/TYPE1SC , B-L475E-IOT01A , and B-U585I-IOT02A/BG96 pages or with certificate-based cryptography. In Certificate Mode an asymmetrical algorithm is used to authenticate the connection endpoints and initialize payload encryption. Appropriate certificates need to be generated for both the LwM2M Client and the LwM2M Server. Public certificates of both parties are mutually available, and each party also has access to its corresponding private key. You can read more about secure communication on Anjay's documentation page. Prerequisites # The STM32L496G-DISCO/BG96 board with a USB cable. Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. Installed OpenSSL An active Coiote IoT DM user account. Note In this tutorial we will use the STM32L496G-DISCO/BG96 board as an example. Flash the device # To get the latest binary file and flash the board: Connect the STM32L496G-DISCO/BG96 board to a USB port of your machine. Go to Anjay-freertos-client . Download the Anjay-freertos-client-STM32L496G-BG96.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L496ZG external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. Generate certificate # The certificate and private key based on the SECP256R1 curve can be provided through the shell interface in PEM format. To generate a self-signed certificate and key pair open a terminal and use the following commands. openssl ecparam -name secp256r1 -out ecparam.der openssl req -new -x509 -nodes -newkey ec:ecparam.der -keyout demo-cert.key -out cert.pem -days 3650 openssl ec -in demo-cert.key -outform pem -out key.pem Important To use the certificate and private key configuration with Coiote IoT DM you must specify a common name that is the same as the client endpoint name. You will see two files cert.pem and key.pem created in the directory. Configure the Client # With the board still connected to a serial port interface, open a serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented below: Set 4. Security (none/psk/cert) to cert . Set 5. Endpoint name to your board endpoint name, e.g. anjay-demo . Set 6. Public cert or PSK identity and paste your generated certificate from cert.pem file. Set 7. Private cert or PSK and paste your generated certificate private key from key.pem file. Set 8. APN , 9. APN username , and 10. APN password to compatibile with your SIM card. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use built-in Truphone SIM card then change APN to iot.truphone.com . Note If you use external SIM card you have to check APN used by SIM card's provider. Save changes by clicking 1. Save & Exit , and go to the next step to add a device to Coiote IoT DM. Add device to Coiote IoT DM # Upon logging in to Coiote IoT DM for the first time, you will see the Add your LwM2M device panel. Note If you had previously added a device, in Device inventory , click the Add device button. Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Endpoint name enter your LwM2M device endpoint name, e.g. anjay-demo . Note The Endpoint name should be the same as it is in the Client configuration. In the Security mode section, select Certificate mode. Click Upload a new certificate and Browse . In the pop-up, go to the directory where your certificate has been generated, select the cert.pem file and click Open . Click Add device . Click Next , Go to Summary to skip the third step, and Finish to see your Device Center.","title":"Runtime Certificate and Private Key Configuration"},{"location":"LwM2M_Client/STMicroelectronics/Runtime_certificate/#runtime-certificate-and-private-key-configuration","text":"","title":"Runtime Certificate and Private Key Configuration"},{"location":"LwM2M_Client/STMicroelectronics/Runtime_certificate/#introduction","text":"Anjay library supports secure connection between device and server. Encryption can be achieved with the use of Pre-Shared Key as it was described in STM32L496G-DISCO/BG96 , B-L462E-CELL1/TYPE1SC , B-L475E-IOT01A , and B-U585I-IOT02A/BG96 pages or with certificate-based cryptography. In Certificate Mode an asymmetrical algorithm is used to authenticate the connection endpoints and initialize payload encryption. Appropriate certificates need to be generated for both the LwM2M Client and the LwM2M Server. Public certificates of both parties are mutually available, and each party also has access to its corresponding private key. You can read more about secure communication on Anjay's documentation page.","title":"Introduction"},{"location":"LwM2M_Client/STMicroelectronics/Runtime_certificate/#prerequisites","text":"The STM32L496G-DISCO/BG96 board with a USB cable. Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. Installed OpenSSL An active Coiote IoT DM user account. Note In this tutorial we will use the STM32L496G-DISCO/BG96 board as an example.","title":"Prerequisites"},{"location":"LwM2M_Client/STMicroelectronics/Runtime_certificate/#flash-the-device","text":"To get the latest binary file and flash the board: Connect the STM32L496G-DISCO/BG96 board to a USB port of your machine. Go to Anjay-freertos-client . Download the Anjay-freertos-client-STM32L496G-BG96.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L496ZG external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished.","title":"Flash the device"},{"location":"LwM2M_Client/STMicroelectronics/Runtime_certificate/#generate-certificate","text":"The certificate and private key based on the SECP256R1 curve can be provided through the shell interface in PEM format. To generate a self-signed certificate and key pair open a terminal and use the following commands. openssl ecparam -name secp256r1 -out ecparam.der openssl req -new -x509 -nodes -newkey ec:ecparam.der -keyout demo-cert.key -out cert.pem -days 3650 openssl ec -in demo-cert.key -outform pem -out key.pem Important To use the certificate and private key configuration with Coiote IoT DM you must specify a common name that is the same as the client endpoint name. You will see two files cert.pem and key.pem created in the directory.","title":"Generate certificate"},{"location":"LwM2M_Client/STMicroelectronics/Runtime_certificate/#configure-the-client","text":"With the board still connected to a serial port interface, open a serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented below: Set 4. Security (none/psk/cert) to cert . Set 5. Endpoint name to your board endpoint name, e.g. anjay-demo . Set 6. Public cert or PSK identity and paste your generated certificate from cert.pem file. Set 7. Private cert or PSK and paste your generated certificate private key from key.pem file. Set 8. APN , 9. APN username , and 10. APN password to compatibile with your SIM card. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use built-in Truphone SIM card then change APN to iot.truphone.com . Note If you use external SIM card you have to check APN used by SIM card's provider. Save changes by clicking 1. Save & Exit , and go to the next step to add a device to Coiote IoT DM.","title":"Configure the Client"},{"location":"LwM2M_Client/STMicroelectronics/Runtime_certificate/#add-device-to-coiote-iot-dm","text":"Upon logging in to Coiote IoT DM for the first time, you will see the Add your LwM2M device panel. Note If you had previously added a device, in Device inventory , click the Add device button. Select the Connect your LwM2M device directly via the Management server tile. In the Device credentials step: In the Endpoint name enter your LwM2M device endpoint name, e.g. anjay-demo . Note The Endpoint name should be the same as it is in the Client configuration. In the Security mode section, select Certificate mode. Click Upload a new certificate and Browse . In the pop-up, go to the directory where your certificate has been generated, select the cert.pem file and click Open . Click Add device . Click Next , Go to Summary to skip the third step, and Finish to see your Device Center.","title":"Add device to Coiote IoT DM"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/","text":"STM32L496G-DISCO/BG96 # Integrate your P-L496G-CELL02 Discovery kit board along with the default-provided Quectel BG96 modem. Prerequisites # The STM32L496G-DISCO/BG96 board with a Micro-USB cable. Installed STM32CubeIDE . The serial communication program, such as minicom (for Linux) or RealTerm or PuTTY (for Windows) installed. A user with access to the Coiote IoT Device Management platform. Prepare Anjay client application # Use an already built binary # To get the latest binary file and flash it to the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-STM32L496G-BG96.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L496ZG external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished. Start development using samples # Note This step is optional. If you've gone through the Use an already built binary step, you can go to Connect to the LwM2M Server right away. Clone the Anjay freeRTOS client repository # Enter the command line interface on your machine and run the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client Build binary and flash the board # Connect the STM32L496G-DISCO board to a USB port of your machine. Go to the STM32CubeIDE. Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-STM32L496G-BG96 and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-STM32L496G-BG96 project: Choose \"Debug\" configuration and build the project by right-clicking on the project name and selecting Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Lauch Configuration Selection , choose the Anjay-freertos-client-STM32L496G-BG96 option and click OK . After the build and run are complete, the board is flashed with compiled binary. Connect to the LwM2M Server # To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . Note If you use the BG96-based configuration, you need to upgrade the modem firmware to at least the BG96MAR02A08M1G revision. Older versions may cause unexpected loss of connection. To upgrade the firmware, download the following .zip files: - Pack_BG96MAR02A08M1G_01.012.01.012 , - Quectel_LTE_Windows_USB_Driver_V2.0 , - QFlash_V4.10 . Then, follow a step-by-step instruction in Pack_BG96MAR02A08M1G_01.012.01.012 . Mind that links from steps 2 and 4 of this instruction don't work correctly. For this reason you will need to use the downloaded Quectel_LTE_Windows_USB_Driver_V2.0 file for step 2 and QFlash_V4.10 file for step 4. To connect the board, log in to the platform and follow onboarding guide . Configure the Client # With the board still connected to a serial port interface, open your serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented in the program and save it. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use a built-in Truphone eSIM card, change the APN to iot.truphone.com . Note If you use external SIM card you have to check APN used by SIM card's provider. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab. Anjay-freertos-client with FOTA (Firmware update Over the Air) # Anjay application can be built in basic version (without FOTA) as described in the Build binary and flash the board section. In order to use FOTA, a few additional steps need to be done, e.g. Secure Boot and Secure Firmware Update compilation. The X-CUBE-SBSFU Secure Boot and Secure Firmware Update solution allows the update of the STM32 microcontroller built-in program with new firmware versions, adding new features and correcting issues. The update process is performed in a secure way to prevent unauthorized updates and access to confidential on-device data such as code and firmware encryption key. The Secure Boot (Root of Trust services) is immutable code, always executed after a system reset, that checks STM32 static protections, activates STM32 runtime protections and then verifies the authenticity and integrity of user application code before every execution in order to ensure that invalid or malicious code won't be run. Additional prerequisites # STM32CubeProgrammer installed. Support for shell scripts execution (on Windows for example Git or Cygwin can be used). Python with the following modules: pycryptodomex , ecdsa , numpy , pyelftools . Import STM32L496G-Discovery_2_Images_SBSFU and STM32L496G-Discovery_2_Images_SECoreBin projects from previously cloned repository to workspace. Prepare binary with SBSFU # Important You need to follow a strict compilation order presented below. Compile SECoreBin application This step is needed to create the Secure Engine core binary including all the trusted code and keys mapped inside the protected environment. The binary is linked with the SBSFU code in step 2. Compile SBSFU application This step compiles the SBSFU source code implementing the state machine and configuring the protections. In addition, it links the code with the SECore binary generated at step 1 in order to generate a single SBSFU binary including the SE trusted code. Compile UserApp application (set Build configuration to Release ) It generates: The user application binary file that is uploaded to the device using the Secure Firmware Update process ( Projects/STM32L496G-DISCO/UserApp/Binary/Anjay-freertos-client-STM32L496G-BG96.sfb ). A binary file concatenating the SBSFU binary, the user application binary in clear format, and the corresponding FW header ( Projects/STM32L496G-DISCO/UserApp/Binary/SBSFU_Anjay-freertos-client-STM32L496G-BG96.bin ). Tip You can set a custom firmware version in the Application/Inc/default_config.h file (using FIRMWARE_VERSION define). It will be useful when performing FOTA to distinguish the firmware images from each other. Flash the board with SBSFU binary # Use STM32CubeProgrammer application with SBSFU_Anjay-freertos-client-STM32L496G-BG96.bin file to program the board (it is advisable to perform Full chip erase first). You can open serial port to change default credentials in order to connect to Coiote IoT DM. After that, you can use Coiote IoT DM to perform firmware update with Anjay-freertos-client-STM32L496G-BG96.sfb file. Important Disable Secure Protection When flashed board with Secure Boot you will need to switch off secure protection to be able to flash the board again. To deactivate secure application please run STM32_Programmer_CLI (Program provided with STM32CubeProgrammer) tool with specific options: ./< path_to_STM32_Programmer_CLI > -c port=SWD mode=UR -ob RDP=0xAA \\ WRP1A_STRT=0xFF WRP1A_END=0x0 WRP1B_STRT=0xFF WRP1B_END=0x0 \\ WRP2A_STRT=0xFF WRP2A_END=0x0 WRP2B_STRT=0xFF WRP2B_END=0x0 \\ BFB2=0x0 \\ -ob displ Perform firmware update # In order to perform firmware update: Build the application and flash the board with FIRMWARE_UPDATE define set to the proper version (see Prepare binary with SBSFU step), e.g. #define FIRMWARE_VERSION \"v1.0\" Make changes to the code (optionally), set FIRMWARE_UPDATE define to a different version, e.g. #define FIRMWARE_VERSION \"v2.0\" and build the application with a new firmware. Upload the generated firmware file ( Anjay-freertos-client-STM32L496G-BG96.sfb ) to Coiote IoT DM (go to Device management and select Firmware update ) and click Upgrade . After the FOTA finishes, the device will reboot and the following log should appear: Firmware updated from version 'v1.0' to 'v2.0' where v1.0 and v2.0 will be set to firmware versions you set earlier. Next steps # If you want to develop your own LwM2M-enabled application based on STM32 L496G-DISCO, check Anjay-freertos-client and start prototyping!","title":"STM32L496G-DISCO/BG96"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#stm32l496g-discobg96","text":"Integrate your P-L496G-CELL02 Discovery kit board along with the default-provided Quectel BG96 modem.","title":"STM32L496G-DISCO/BG96"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#prerequisites","text":"The STM32L496G-DISCO/BG96 board with a Micro-USB cable. Installed STM32CubeIDE . The serial communication program, such as minicom (for Linux) or RealTerm or PuTTY (for Windows) installed. A user with access to the Coiote IoT Device Management platform.","title":"Prerequisites"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#prepare-anjay-client-application","text":"","title":"Prepare Anjay client application"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#use-an-already-built-binary","text":"To get the latest binary file and flash it to the board: Go to Anjay-freertos-client . Download the Anjay-freertos-client-STM32L496G-BG96.bin file. To flash the board, open your File manager and drag the downloaded .bin file to your DIS_L496ZG external device. You will see a blinking diode on your board. The diode will stop blinking as soon as the flashing is finished.","title":"Use an already built binary"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#start-development-using-samples","text":"Note This step is optional. If you've gone through the Use an already built binary step, you can go to Connect to the LwM2M Server right away.","title":"Start development using samples"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#clone-the-anjay-freertos-client-repository","text":"Enter the command line interface on your machine and run the following command: git clone --recursive https://github.com/AVSystem/Anjay-freertos-client","title":"Clone the Anjay freeRTOS client repository"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#build-binary-and-flash-the-board","text":"Connect the STM32L496G-DISCO board to a USB port of your machine. Go to the STM32CubeIDE. Import the project cloned in the previous step to your workspace: From the navigation bar, select File and click Import . From the General list, select Existing Projects into Workspace and click Next . In Select root directory , indicate the catalog containing the cloned Anjay freeRTOS client repository. In the Projects field, select Anjay-freertos-client-STM32L496G-BG96 and click Finish . In the Project Explorer, navigate to the Anjay-freertos-client-STM32L496G-BG96 project: Choose \"Debug\" configuration and build the project by right-clicking on the project name and selecting Build Project . The build should take less than one minute to complete. After the build is finished, right-click on the project name, select Run As and click the 1 STM32 Cortex-M C/C++ Application option. In the Lauch Configuration Selection , choose the Anjay-freertos-client-STM32L496G-BG96 option and click OK . After the build and run are complete, the board is flashed with compiled binary.","title":"Build binary and flash the board"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#connect-to-the-lwm2m-server","text":"To connect to Coiote IoT Device Management platform, please register at https://eu.iot.avsystem.cloud . Note If you use the BG96-based configuration, you need to upgrade the modem firmware to at least the BG96MAR02A08M1G revision. Older versions may cause unexpected loss of connection. To upgrade the firmware, download the following .zip files: - Pack_BG96MAR02A08M1G_01.012.01.012 , - Quectel_LTE_Windows_USB_Driver_V2.0 , - QFlash_V4.10 . Then, follow a step-by-step instruction in Pack_BG96MAR02A08M1G_01.012.01.012 . Mind that links from steps 2 and 4 of this instruction don't work correctly. For this reason you will need to use the downloaded Quectel_LTE_Windows_USB_Driver_V2.0 file for step 2 and QFlash_V4.10 file for step 4. To connect the board, log in to the platform and follow onboarding guide .","title":"Connect to the LwM2M Server"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#configure-the-client","text":"With the board still connected to a serial port interface, open your serial communication program. Press the reset button located on the board. This should trigger the following prompt: Press any key in 3 seconds to enter config menu... Press any key and in the configuration menu, change the default credentials to your data by following the instructions presented in the program and save it. Important APN (Access Point Name) is the name of a gateway between a GSM, GPRS, 3G and 4G mobile network and another computer network. If you use a built-in Truphone eSIM card, change the APN to iot.truphone.com . Note If you use external SIM card you have to check APN used by SIM card's provider. Go to Coiote IoT DM to check if your device is connected. Click Next , then Go to Summary , then Finish . You will see your Device Center view: Tip LwM2M Server URI, endpoint name and other information can be found in the Configuration tab.","title":"Configure the Client"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#anjay-freertos-client-with-fota-firmware-update-over-the-air","text":"Anjay application can be built in basic version (without FOTA) as described in the Build binary and flash the board section. In order to use FOTA, a few additional steps need to be done, e.g. Secure Boot and Secure Firmware Update compilation. The X-CUBE-SBSFU Secure Boot and Secure Firmware Update solution allows the update of the STM32 microcontroller built-in program with new firmware versions, adding new features and correcting issues. The update process is performed in a secure way to prevent unauthorized updates and access to confidential on-device data such as code and firmware encryption key. The Secure Boot (Root of Trust services) is immutable code, always executed after a system reset, that checks STM32 static protections, activates STM32 runtime protections and then verifies the authenticity and integrity of user application code before every execution in order to ensure that invalid or malicious code won't be run.","title":"Anjay-freertos-client with FOTA (Firmware update Over the Air)"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#additional-prerequisites","text":"STM32CubeProgrammer installed. Support for shell scripts execution (on Windows for example Git or Cygwin can be used). Python with the following modules: pycryptodomex , ecdsa , numpy , pyelftools . Import STM32L496G-Discovery_2_Images_SBSFU and STM32L496G-Discovery_2_Images_SECoreBin projects from previously cloned repository to workspace.","title":"Additional prerequisites"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#prepare-binary-with-sbsfu","text":"Important You need to follow a strict compilation order presented below. Compile SECoreBin application This step is needed to create the Secure Engine core binary including all the trusted code and keys mapped inside the protected environment. The binary is linked with the SBSFU code in step 2. Compile SBSFU application This step compiles the SBSFU source code implementing the state machine and configuring the protections. In addition, it links the code with the SECore binary generated at step 1 in order to generate a single SBSFU binary including the SE trusted code. Compile UserApp application (set Build configuration to Release ) It generates: The user application binary file that is uploaded to the device using the Secure Firmware Update process ( Projects/STM32L496G-DISCO/UserApp/Binary/Anjay-freertos-client-STM32L496G-BG96.sfb ). A binary file concatenating the SBSFU binary, the user application binary in clear format, and the corresponding FW header ( Projects/STM32L496G-DISCO/UserApp/Binary/SBSFU_Anjay-freertos-client-STM32L496G-BG96.bin ). Tip You can set a custom firmware version in the Application/Inc/default_config.h file (using FIRMWARE_VERSION define). It will be useful when performing FOTA to distinguish the firmware images from each other.","title":"Prepare binary with SBSFU"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#flash-the-board-with-sbsfu-binary","text":"Use STM32CubeProgrammer application with SBSFU_Anjay-freertos-client-STM32L496G-BG96.bin file to program the board (it is advisable to perform Full chip erase first). You can open serial port to change default credentials in order to connect to Coiote IoT DM. After that, you can use Coiote IoT DM to perform firmware update with Anjay-freertos-client-STM32L496G-BG96.sfb file. Important Disable Secure Protection When flashed board with Secure Boot you will need to switch off secure protection to be able to flash the board again. To deactivate secure application please run STM32_Programmer_CLI (Program provided with STM32CubeProgrammer) tool with specific options: ./< path_to_STM32_Programmer_CLI > -c port=SWD mode=UR -ob RDP=0xAA \\ WRP1A_STRT=0xFF WRP1A_END=0x0 WRP1B_STRT=0xFF WRP1B_END=0x0 \\ WRP2A_STRT=0xFF WRP2A_END=0x0 WRP2B_STRT=0xFF WRP2B_END=0x0 \\ BFB2=0x0 \\ -ob displ","title":"Flash the board with SBSFU binary"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#perform-firmware-update","text":"In order to perform firmware update: Build the application and flash the board with FIRMWARE_UPDATE define set to the proper version (see Prepare binary with SBSFU step), e.g. #define FIRMWARE_VERSION \"v1.0\" Make changes to the code (optionally), set FIRMWARE_UPDATE define to a different version, e.g. #define FIRMWARE_VERSION \"v2.0\" and build the application with a new firmware. Upload the generated firmware file ( Anjay-freertos-client-STM32L496G-BG96.sfb ) to Coiote IoT DM (go to Device management and select Firmware update ) and click Upgrade . After the FOTA finishes, the device will reboot and the following log should appear: Firmware updated from version 'v1.0' to 'v2.0' where v1.0 and v2.0 will be set to firmware versions you set earlier.","title":"Perform firmware update"},{"location":"LwM2M_Client/STMicroelectronics/STM32L496G-DISCOBG96/#next-steps","text":"If you want to develop your own LwM2M-enabled application based on STM32 L496G-DISCO, check Anjay-freertos-client and start prototyping!","title":"Next steps"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/","text":"Building LwM2M applications for STM boards with I-CUBE-Anjay # Start prototyping custom LwM2M applications on your STMicroelectronics board with I-CUBE-Anjay using STM32CubeMX. Prerequisites # An STM board with a USB cable. Installed STM32CubeMX . Downloaded Anjay I-CUBE pack file . Step 1: Installing the Anjay I-CUBE software pack # Open STM32CUBEMX and in the New project section, select ACCESS TO BOARD SELECTOR . From the list of STM boards, select your board, click Start project and click No in the Initialize all peripherals with their default mode pop-up that appears. In the Pinout & Configuration tab, click Software Packs and select Manage Software Packs . Click From local and select your Anjay I-Cube pack from your local disk. After reading the license agreement, check the license agreement checkbox and click Finish . The pack will be installed in a few seconds. Back in the Pinout & Configuration tab, click Software Packs and select Select Components . From the list of packs, click AVSystem.I-CUBE-Anjay to expand a list of bundles and components. Configure options according to the specific instruction for your board in the Specific CubeMX settings . Step 2: Configuring the Anjay I-CUBE application # Before you generate code for your application, you need to configure it as per the specific requirements for your board: Back in the Pinout & Configuration tab, expand the Software Packs tab that has appeared in the side menu and click AVSystem.I-CUBE-Anjay.x.xx.x : In the Mode window that appears, check all the boxes next to the LwM2M Stack, Device LwM2M Client example, Board Support LwM2M, Board Support X STMOD PLUS MODEMS, Cellular Middleware STM32 Cellular options. In the Configuration window: Go to the Parameter Settings tab and configure your Anjay Library. For a detailed description of all Anjay library configuration options, see here . Go to the Client Settings tab and configure your LwM2M Client parameters like Endpoint name, PSK, PSK identity, server URI and others. In the Pinout & Configuration tab: Expand the Connectivity , Middleware , Security and System Core tabs: Configure options according to the specific instruction for your board in the Specific CubeMX settings . Step 3: Generating application code # Back in your project overview, select the Project Manager tab: In the Project tab: In the Project Name field, provide a name for your project. From the Toolchain/IDE expandable list, select STM32CubeIDE . In linker settings adjust Minimum Heap Size to 0x5000 and Minimum Stack Size to 0xC00. In the Code Generator tab: Check the Generate peripheral initialization as a pair of '.c/.h' files per peripheral . Click GENERATE CODE and confirm by clicking Yes in the pop-up. After the project is generated, you can use it further in the CubeIDE to develop, flash and debug your application. Specific CubeMX settings # B-L462E-CELL1 # Start from board selector with B-L462E-CELL1 board, do not initialize all peripherals with their default mode. Through Select Components menu choose desired components from the pack, in this example select: LwM2M Stack Anjay LwIP mbedtls Device Application - FullExample Board Support LwM2M LwM2M Objects: B-L462E-CELL1 B-L462E-CELL1 BSP Board Support X_STMOD_PLUS_MODEMS - TYPE1SC STM32_Cellular Core Platform config: B-L462E-CELL1 Apply the following settings: Connectivity tab: I2C1 - Enable I2C1 USART1 - Enable Asynchronous, enable global interrupts USART2 - Enable Asynchronous, enable global interrupts USART3 - Enable Asynchronous, enable global interrupts Middleware tab: FreeRTOS Interface - CMSIS_V1 TOTAL_HEAP_SIZE - 32768 Bytes USE_COUNTING_SEMAPHORES - Enabled Project Manager: Code Generator - Enable Generate peripheral initialization as a pair of '.c/.h' files per peripheral. Software Packs: I-CUBE-Anjay - select all enabled components and modify Client Settings with connection parameters. Parameter settings can be modified to alter Anjay LwM2M Library configuration. Generate the project and open it in STM32CubeIDE . Right click on the project Build Configurations -> Set Active -> Release . Select generated project and modify Properties -> C/C++ Build -> Settings -> MCU Settings Change Runtime library to Standard C . Flash the project using Run As -> STM32 Cortex-M C/C++ Application . P-L496G-CELL02 # Start from board selector with STM32L496G-DISCO board, do not initialize all peripherals with their default mode. Through Select Components menu choose desired components from the pack, in this example select: LwM2M Stack Anjay LwIP mbedtls Device Application - FullExample Board Support LwM2M LwM2M Objects: P-L496G-CELL02 P-L496G-CELL02 BSP Board Support X_STMOD_PLUS_MODEMS - BG96 or MONARCH (depending on your setup) STM32_Cellular Core Platform config: P-L496G-CELL02 Apply the following settings: Connectivity tab: I2C1 - Enable I2C USART1 - Enable Asynchronous, enable global interrupts USART2 - Enable Asynchronous, enable global interrupts Security tab: RNG - Enable Middleware tab: FreeRTOS Interface - CMSIS_V1 TOTAL_HEAP_SIZE - 32768 Bytes USE_COUNTING_SEMAPHORES - Enabled USE_TIMERS - Enabled vTaskDelayUntil - Enabled uxTaskGetStackHighWaterMark - Enabled System Core SYS Timebase Source - TIM1 Project Manager: Code Generator - Enable Generate peripheral initialization as a pair of '.c/.h' files per peripheral. Software Packs: I-CUBE-Anjay - select all enabled components and modify Client Settings with connection parameters. Parameter settings can be modified to alter Anjay LwM2M Library configuration. Generate the project and open it in STM32CubeIDE . Select generated project and modify Properties -> C/C++ Build -> Settings -> MCU Settings Change Runtime library to Standard C . Flash the project using Run As -> STM32 Cortex-M C/C++ Application . Compiler-dependent options # When generating code, CubeMX might warn you that USE_NEWLIB_REENTRANT option must be set. However, not all the IDEs have newlib in their toolchain libraries and checking this option can make your project uncompilable. For IAR and Keil simply press Yes to skip it. Depending on the Compiler Toolchain, redirecting standard output into the console via UART and serial port might require additional options in IDE and compiler-specific code. Solutions can be found below as well as in the Pack's demonstration projects. IAR Embedded Workbench # IAR Embedded Workbench for ARM version 9.20.2 or higher is required to compile the project. To compile client application example, navigate to Project -> Options ... -> C/C++ Compiler -> C dialect and set Allow VLA . To allow and handle serial output with application flashed on board and not attached to IAR, Semihosting has to be disabled. Navigate to Project -> Options ... -> General Options -> Library low-level interface implementation and set it to None . In main.c add the following lines of code: #include \"plf_hw_config.h\" #include <stdio.h> #include \"trace_interface.h\" #include <LowLevelIOInterface.h> // ... int iar_fputc(int ch); #define PUTCHAR_PROTOTYPE int iar_fputc(int ch) // ... size_t __write(int file, unsigned char const *ptr, size_t len) { size_t idx; unsigned char const *pdata = ptr; for (idx = 0; idx < len; idx++) { iar_fputc((int)*pdata); pdata++; } return len; } PUTCHAR_PROTOTYPE { /* Place your implementation of putchar here */ /* e.g. write a character to the USART3 and Loop until the end of transmission */ HAL_UART_Transmit(&TRACE_INTERFACE_UART_HANDLE, (uint8_t *)&ch, 1, 0xFFFF); return ch; } Keil uVision # The newest Keil MDK distribution no longer contains Arm Compiler 5, which is a target compiler when generating a project with STM32CubeMX. You have to either install Keil MDK version older than 5.37 or install the missing compiler manually - more information here . Keil's errno defines conflict with LwIP's errno and it must be resolved by adding LwIP's include folder to the list of the system includes. To do so, navigate to Project -> Options for Target (...) -> C/C++ -> Misc Controls and add a following command control option (ensure proper path; incorrect path will not generate an error): -J ../Middlewares/Third_Party/AVSystem_LwM2M_Stack/LwIP/src/include/compat/stdc -J \"$J\" To ensure proper handling of serial output with application flashed on board and not attached to uVision, navigate to Project -> Manage -> Run-Time Environment... -> Compiler -> I/O , select checkboxes and choose User variant for STRERR , STDIN and STDOUT . In main.c add the following lines of code: #include \"plf_hw_config.h\" #include <stdio.h> // ... #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) // ... PUTCHAR_PROTOTYPE { /* Place your implementation of putchar here */ /* e.g. write a character to the USART3 and Loop until the end of transmission */ HAL_UART_Transmit(&TRACE_INTERFACE_UART_HANDLE, (uint8_t *)&ch, 1, 0xFFFF); return ch; }","title":"Building LwM2M applications for STM boards with I-CUBE-Anjay"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#building-lwm2m-applications-for-stm-boards-with-i-cube-anjay","text":"Start prototyping custom LwM2M applications on your STMicroelectronics board with I-CUBE-Anjay using STM32CubeMX.","title":"Building LwM2M applications for STM boards with I-CUBE-Anjay"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#prerequisites","text":"An STM board with a USB cable. Installed STM32CubeMX . Downloaded Anjay I-CUBE pack file .","title":"Prerequisites"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#step-1-installing-the-anjay-i-cube-software-pack","text":"Open STM32CUBEMX and in the New project section, select ACCESS TO BOARD SELECTOR . From the list of STM boards, select your board, click Start project and click No in the Initialize all peripherals with their default mode pop-up that appears. In the Pinout & Configuration tab, click Software Packs and select Manage Software Packs . Click From local and select your Anjay I-Cube pack from your local disk. After reading the license agreement, check the license agreement checkbox and click Finish . The pack will be installed in a few seconds. Back in the Pinout & Configuration tab, click Software Packs and select Select Components . From the list of packs, click AVSystem.I-CUBE-Anjay to expand a list of bundles and components. Configure options according to the specific instruction for your board in the Specific CubeMX settings .","title":"Step 1: Installing the Anjay I-CUBE software pack"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#step-2-configuring-the-anjay-i-cube-application","text":"Before you generate code for your application, you need to configure it as per the specific requirements for your board: Back in the Pinout & Configuration tab, expand the Software Packs tab that has appeared in the side menu and click AVSystem.I-CUBE-Anjay.x.xx.x : In the Mode window that appears, check all the boxes next to the LwM2M Stack, Device LwM2M Client example, Board Support LwM2M, Board Support X STMOD PLUS MODEMS, Cellular Middleware STM32 Cellular options. In the Configuration window: Go to the Parameter Settings tab and configure your Anjay Library. For a detailed description of all Anjay library configuration options, see here . Go to the Client Settings tab and configure your LwM2M Client parameters like Endpoint name, PSK, PSK identity, server URI and others. In the Pinout & Configuration tab: Expand the Connectivity , Middleware , Security and System Core tabs: Configure options according to the specific instruction for your board in the Specific CubeMX settings .","title":"Step 2: Configuring the Anjay I-CUBE application"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#step-3-generating-application-code","text":"Back in your project overview, select the Project Manager tab: In the Project tab: In the Project Name field, provide a name for your project. From the Toolchain/IDE expandable list, select STM32CubeIDE . In linker settings adjust Minimum Heap Size to 0x5000 and Minimum Stack Size to 0xC00. In the Code Generator tab: Check the Generate peripheral initialization as a pair of '.c/.h' files per peripheral . Click GENERATE CODE and confirm by clicking Yes in the pop-up. After the project is generated, you can use it further in the CubeIDE to develop, flash and debug your application.","title":"Step 3: Generating application code"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#specific-cubemx-settings","text":"","title":"Specific CubeMX settings"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#b-l462e-cell1","text":"Start from board selector with B-L462E-CELL1 board, do not initialize all peripherals with their default mode. Through Select Components menu choose desired components from the pack, in this example select: LwM2M Stack Anjay LwIP mbedtls Device Application - FullExample Board Support LwM2M LwM2M Objects: B-L462E-CELL1 B-L462E-CELL1 BSP Board Support X_STMOD_PLUS_MODEMS - TYPE1SC STM32_Cellular Core Platform config: B-L462E-CELL1 Apply the following settings: Connectivity tab: I2C1 - Enable I2C1 USART1 - Enable Asynchronous, enable global interrupts USART2 - Enable Asynchronous, enable global interrupts USART3 - Enable Asynchronous, enable global interrupts Middleware tab: FreeRTOS Interface - CMSIS_V1 TOTAL_HEAP_SIZE - 32768 Bytes USE_COUNTING_SEMAPHORES - Enabled Project Manager: Code Generator - Enable Generate peripheral initialization as a pair of '.c/.h' files per peripheral. Software Packs: I-CUBE-Anjay - select all enabled components and modify Client Settings with connection parameters. Parameter settings can be modified to alter Anjay LwM2M Library configuration. Generate the project and open it in STM32CubeIDE . Right click on the project Build Configurations -> Set Active -> Release . Select generated project and modify Properties -> C/C++ Build -> Settings -> MCU Settings Change Runtime library to Standard C . Flash the project using Run As -> STM32 Cortex-M C/C++ Application .","title":"B-L462E-CELL1"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#p-l496g-cell02","text":"Start from board selector with STM32L496G-DISCO board, do not initialize all peripherals with their default mode. Through Select Components menu choose desired components from the pack, in this example select: LwM2M Stack Anjay LwIP mbedtls Device Application - FullExample Board Support LwM2M LwM2M Objects: P-L496G-CELL02 P-L496G-CELL02 BSP Board Support X_STMOD_PLUS_MODEMS - BG96 or MONARCH (depending on your setup) STM32_Cellular Core Platform config: P-L496G-CELL02 Apply the following settings: Connectivity tab: I2C1 - Enable I2C USART1 - Enable Asynchronous, enable global interrupts USART2 - Enable Asynchronous, enable global interrupts Security tab: RNG - Enable Middleware tab: FreeRTOS Interface - CMSIS_V1 TOTAL_HEAP_SIZE - 32768 Bytes USE_COUNTING_SEMAPHORES - Enabled USE_TIMERS - Enabled vTaskDelayUntil - Enabled uxTaskGetStackHighWaterMark - Enabled System Core SYS Timebase Source - TIM1 Project Manager: Code Generator - Enable Generate peripheral initialization as a pair of '.c/.h' files per peripheral. Software Packs: I-CUBE-Anjay - select all enabled components and modify Client Settings with connection parameters. Parameter settings can be modified to alter Anjay LwM2M Library configuration. Generate the project and open it in STM32CubeIDE . Select generated project and modify Properties -> C/C++ Build -> Settings -> MCU Settings Change Runtime library to Standard C . Flash the project using Run As -> STM32 Cortex-M C/C++ Application .","title":"P-L496G-CELL02"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#compiler-dependent-options","text":"When generating code, CubeMX might warn you that USE_NEWLIB_REENTRANT option must be set. However, not all the IDEs have newlib in their toolchain libraries and checking this option can make your project uncompilable. For IAR and Keil simply press Yes to skip it. Depending on the Compiler Toolchain, redirecting standard output into the console via UART and serial port might require additional options in IDE and compiler-specific code. Solutions can be found below as well as in the Pack's demonstration projects.","title":"Compiler-dependent options"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#iar-embedded-workbench","text":"IAR Embedded Workbench for ARM version 9.20.2 or higher is required to compile the project. To compile client application example, navigate to Project -> Options ... -> C/C++ Compiler -> C dialect and set Allow VLA . To allow and handle serial output with application flashed on board and not attached to IAR, Semihosting has to be disabled. Navigate to Project -> Options ... -> General Options -> Library low-level interface implementation and set it to None . In main.c add the following lines of code: #include \"plf_hw_config.h\" #include <stdio.h> #include \"trace_interface.h\" #include <LowLevelIOInterface.h> // ... int iar_fputc(int ch); #define PUTCHAR_PROTOTYPE int iar_fputc(int ch) // ... size_t __write(int file, unsigned char const *ptr, size_t len) { size_t idx; unsigned char const *pdata = ptr; for (idx = 0; idx < len; idx++) { iar_fputc((int)*pdata); pdata++; } return len; } PUTCHAR_PROTOTYPE { /* Place your implementation of putchar here */ /* e.g. write a character to the USART3 and Loop until the end of transmission */ HAL_UART_Transmit(&TRACE_INTERFACE_UART_HANDLE, (uint8_t *)&ch, 1, 0xFFFF); return ch; }","title":"IAR Embedded Workbench"},{"location":"LwM2M_Client/STMicroelectronics/Building_LwM2M_applications/Building_LwM2M_applications_with_I-CUBE-Anjay/#keil-uvision","text":"The newest Keil MDK distribution no longer contains Arm Compiler 5, which is a target compiler when generating a project with STM32CubeMX. You have to either install Keil MDK version older than 5.37 or install the missing compiler manually - more information here . Keil's errno defines conflict with LwIP's errno and it must be resolved by adding LwIP's include folder to the list of the system includes. To do so, navigate to Project -> Options for Target (...) -> C/C++ -> Misc Controls and add a following command control option (ensure proper path; incorrect path will not generate an error): -J ../Middlewares/Third_Party/AVSystem_LwM2M_Stack/LwIP/src/include/compat/stdc -J \"$J\" To ensure proper handling of serial output with application flashed on board and not attached to uVision, navigate to Project -> Manage -> Run-Time Environment... -> Compiler -> I/O , select checkboxes and choose User variant for STRERR , STDIN and STDOUT . In main.c add the following lines of code: #include \"plf_hw_config.h\" #include <stdio.h> // ... #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) // ... PUTCHAR_PROTOTYPE { /* Place your implementation of putchar here */ /* e.g. write a character to the USART3 and Loop until the end of transmission */ HAL_UART_Transmit(&TRACE_INTERFACE_UART_HANDLE, (uint8_t *)&ch, 1, 0xFFFF); return ch; }","title":"Keil uVision"},{"location":"academy/","text":"LwM2M Academy # Welcome! # Welcome to the LwM2M Academy , an immersive online course tailored to equip you with understanding of the Lightweight Machine to Machine (LwM2M) protocol. This program is designed to provide you with both the theoretical understanding and hands-on skills necessary to utilize this powerful IoT standard. The course consists of 5 modules which will journey you through the diverse aspects of LwM2M, from the underlying principles and architecture to its implementation and optimization for creating robust IoT applications. By the end of the course, you will understand the advantages of the LwM2M standard and possess the skills to implement it effectively. With a strong emphasis on real-world applications, the course is designed to provide you with practical experience, empowering you to build IoT applications confidently using LwM2M. Embark on this learning journey and explore the fascinating world of LwM2M. LwM2M Academy available on Udemy The LwM2M Academy is now also available as an official course on Udemy . Follow the course on Udemy . Invitation to Discord Community # Step right into the heart of learning with the AVSystem Discord Community . During the course, Discord is the place for expert guidance on LwM2M, networking with fellow course students, and showcasing the cool stuff you're building. We've dedicated an exclusive channel for our learners, named lwm2m-academy . We invite you to join the AVSystem Discord Community to enrich your learning experience and interact with the LwM2M community. Provide your feedback # We're constantly working on improving the LwM2M Academy. Please share with us your feedback throughout the course so we can create an even better learning experience. Feedback form Intro to the hardware used in this course # Throughout this course, we will be using the Raspberry Pi Pico W , Raspberry Pi's first wireless microcontroller board. It has been designed as a tiny and low-cost yet flexible development platform for the RP2040 MCU. The 21 mm \u00d7 51 mm board comes with a 2.4GHz wireless LAN interface (802.11n). It provides 26 GPIO pins, three of which can function as analog inputs. Four RP2040 I/O pins are used for internal functions: driving an LED, on-board switch mode power supply power control, and sensing the system voltages. Reprogramming the Pico W flash can be done using USB (simply drag and drop a file onto the Pico W, which appears as a mass storage device), or using the serial wire debug (SWD) port. The SWD port can also be used to debug code running on the RP2040 interactively. Purchase hardware via Raspberry's website Sensor used in the course # In this course, we will be using the LM35 analog temperature sensor. Purchase the sensor via Kiwi electronics (EU), Amazon (US) or Mouser (EU/US) Intro to Anjay LwM2M Client # Anjay is a free and open-source LwM2M Client written in C for rapidly building LwM2M solutions. It comes with an SDK comprising pre-built examples and reference implementations for popular hardware platforms such as STM32, Raspberry Pi, Nordic or ESP32. Anjay eases the development of LwM2M applications by taking care of the implementation of the LwM2M protocol. The project was created and is actively maintained by AVSystem . Some expert features such as support for hardware security modules or SMS binding are available commercially. Anjay features Automatically implements the LwM2M data format & Smart Objects Security by default (DTLS, OSCORE) Support for FOTA (firmware updates over the air) Device management mechanisms to update configurations over time vStandard implementations available for many hardware platforms Find more information about Anjay and its features, or visit the official documentation website directly. Intro to Coiote IoT DM # Coiote IoT Device Management platform is built around the LwM2M standard. It acts as a LwM2M Server and is designed as a scalable platform to manage large numbers of devices. The platform comes with tools to monitor groups of devices, manage device configurations, and perform firmware updates. In addition, it supports cloud integrations with platforms such as AWS IoT Core or Azure IoT Hub. Coiote IoT DM has a developer version, allowing you to connect up to 10 devices free of charge. To create a developer account, visit eu.iot.avsystem.cloud Coiote IoT DM features Data collection and storage Connect LwM2M devices securely and store their data. Device management Remotely manage device configurations and firmware. Developer tools Tools include time series data visualization, hardware in loop testing, server-side logs collection and automated alerts. Processing data Collect data from your sensors and send them directly in the unified data format to the cloud thanks to various options of data integrations, including AWS IoT Core, Azure IoT Hub, Kafka, and Webhooks. Find more information about getting started with Coiote IoT Device Management platform.","title":"Welcome"},{"location":"academy/#lwm2m-academy","text":"","title":"LwM2M Academy"},{"location":"academy/#welcome","text":"Welcome to the LwM2M Academy , an immersive online course tailored to equip you with understanding of the Lightweight Machine to Machine (LwM2M) protocol. This program is designed to provide you with both the theoretical understanding and hands-on skills necessary to utilize this powerful IoT standard. The course consists of 5 modules which will journey you through the diverse aspects of LwM2M, from the underlying principles and architecture to its implementation and optimization for creating robust IoT applications. By the end of the course, you will understand the advantages of the LwM2M standard and possess the skills to implement it effectively. With a strong emphasis on real-world applications, the course is designed to provide you with practical experience, empowering you to build IoT applications confidently using LwM2M. Embark on this learning journey and explore the fascinating world of LwM2M. LwM2M Academy available on Udemy The LwM2M Academy is now also available as an official course on Udemy . Follow the course on Udemy .","title":"Welcome!"},{"location":"academy/#invitation-to-discord-community","text":"Step right into the heart of learning with the AVSystem Discord Community . During the course, Discord is the place for expert guidance on LwM2M, networking with fellow course students, and showcasing the cool stuff you're building. We've dedicated an exclusive channel for our learners, named lwm2m-academy . We invite you to join the AVSystem Discord Community to enrich your learning experience and interact with the LwM2M community.","title":"Invitation to Discord Community"},{"location":"academy/#provide-your-feedback","text":"We're constantly working on improving the LwM2M Academy. Please share with us your feedback throughout the course so we can create an even better learning experience. Feedback form","title":"Provide your feedback"},{"location":"academy/#intro-to-the-hardware-used-in-this-course","text":"Throughout this course, we will be using the Raspberry Pi Pico W , Raspberry Pi's first wireless microcontroller board. It has been designed as a tiny and low-cost yet flexible development platform for the RP2040 MCU. The 21 mm \u00d7 51 mm board comes with a 2.4GHz wireless LAN interface (802.11n). It provides 26 GPIO pins, three of which can function as analog inputs. Four RP2040 I/O pins are used for internal functions: driving an LED, on-board switch mode power supply power control, and sensing the system voltages. Reprogramming the Pico W flash can be done using USB (simply drag and drop a file onto the Pico W, which appears as a mass storage device), or using the serial wire debug (SWD) port. The SWD port can also be used to debug code running on the RP2040 interactively. Purchase hardware via Raspberry's website","title":"Intro to the hardware used in this course"},{"location":"academy/#sensor-used-in-the-course","text":"In this course, we will be using the LM35 analog temperature sensor. Purchase the sensor via Kiwi electronics (EU), Amazon (US) or Mouser (EU/US)","title":"Sensor used in the course"},{"location":"academy/#intro-to-anjay-lwm2m-client","text":"Anjay is a free and open-source LwM2M Client written in C for rapidly building LwM2M solutions. It comes with an SDK comprising pre-built examples and reference implementations for popular hardware platforms such as STM32, Raspberry Pi, Nordic or ESP32. Anjay eases the development of LwM2M applications by taking care of the implementation of the LwM2M protocol. The project was created and is actively maintained by AVSystem . Some expert features such as support for hardware security modules or SMS binding are available commercially. Anjay features Automatically implements the LwM2M data format & Smart Objects Security by default (DTLS, OSCORE) Support for FOTA (firmware updates over the air) Device management mechanisms to update configurations over time vStandard implementations available for many hardware platforms Find more information about Anjay and its features, or visit the official documentation website directly.","title":"Intro to Anjay LwM2M Client"},{"location":"academy/#intro-to-coiote-iot-dm","text":"Coiote IoT Device Management platform is built around the LwM2M standard. It acts as a LwM2M Server and is designed as a scalable platform to manage large numbers of devices. The platform comes with tools to monitor groups of devices, manage device configurations, and perform firmware updates. In addition, it supports cloud integrations with platforms such as AWS IoT Core or Azure IoT Hub. Coiote IoT DM has a developer version, allowing you to connect up to 10 devices free of charge. To create a developer account, visit eu.iot.avsystem.cloud Coiote IoT DM features Data collection and storage Connect LwM2M devices securely and store their data. Device management Remotely manage device configurations and firmware. Developer tools Tools include time series data visualization, hardware in loop testing, server-side logs collection and automated alerts. Processing data Collect data from your sensors and send them directly in the unified data format to the cloud thanks to various options of data integrations, including AWS IoT Core, Azure IoT Hub, Kafka, and Webhooks. Find more information about getting started with Coiote IoT Device Management platform.","title":"Intro to Coiote IoT DM"},{"location":"academy/exercise1/","text":"Exercise 1: Connect the Raspberry Pi Pico W to a LwM2M Server # Let\u2019s start with the first exercise on building an end-to-end LwM2M application by running Anjay LwM2M Client on the Raspberry Pi Pico W, and connecting your device to Coiote IoT Device Management platform over WiFi. Prerequisites # A Raspberry Pi Pico W board with a USB cable Git Access to a WiFi network Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account. Prepare binaries # Install dependencies # Configure and compile the LwM2M Client. To do so, you need to install some dependencies and clone three GitHub repositories: Anjay Client for the Raspberry Pi Pico W , the Raspberry Pi Pico W SDK , and the FreeRTOS kernel . Start by creating a new workspace, installing the dependencies, and cloning all three GitHub directories into this workspace. Create and open a new directory: mkdir lwm2m-academy cd lwm2m-academy Install dependencies: Linux When using Ubuntu , run the following command: sudo apt install python3 cmake gcc-arm-none-eabi libnewlib-arm-none-eabi libstdc++-arm-none-eabi-newlib When using Fedora , run the following command: sudo dnf install python3 cmake arm-none-eabi-newlib arm-none-eabi-gcc-cs-c++ arm-none-eabi-gcc-cs arm-none-eabi-binutils-cs gcc-arm-linux-gnu gcc-c++-arm-linux-gnu gcc gcc-c++ Mac When using MacOS, run the following command: brew install python cmake armmbed/formulae/arm-none-eabi-gcc Windows When using Windows, install the following dependencies: Python3 , MinGW and CMake . Download and run the installer to install arm-none-eabi-gcc and arm-none-eabi-gdb . Select the default destination directory (E.g. C:\\GNU_Arm_Embedded_Toolchain ). Check the Add path to environment variable option before you click the Finish button for the installation. Clone three GitHub repositories using Git. Clone the RPi Pico SDK repository and update its submodules git clone -b 1.5.1 https://github.com/raspberrypi/pico-sdk.git cd pico-sdk/ && git submodule update --init && cd .. Clone the FreeRTOS kernel repository git clone -b V10.5.0 https://github.com/FreeRTOS/FreeRTOS-Kernel.git Clone the Anjay-pico-client repository and update its modules git clone https://github.com/AVSystem/Anjay-pico-client.git cd Anjay-pico-client && git submodule update --init --recursive && cd .. Tip Need help? Head over to the lwm2m-academy channel on Discord to get in touch with our experts. Connect to the LwM2M Server # Before connecting your device to the cloud, log in to Coiote IoT Device Management platform: eu.iot.avsystem.cloud . Once logged in, select Device Inventory from the left-side menu In the Device Inventory, click Add device . Select the tile Connect your LwM2M device directly via the Management server . In the Device Credentials step: Enter the Endpoint name. You can choose an endpoint name by yourself. As the Security mode, choose NoSec . Click Add device and Confirm in the confirmation pop-up. Click Go to Summary to find your Device Center view. Compile the application # Let\u2019s continue building the required files for the application. We are using NoSec mode where encryption and authentication are disabled and the data messages are passed in plain text over the network. In future exercises, we\u2019ll cover secure implementation in more detail. Warning Use the NoSec mode only for development, testing, and debugging purposes, never in production environments unless end-to-end security is provided on a lower layer (e.g. IPSec). To start the compilation of the application, go to the Anjay-pico-client directory . Build the project with <ssid> and <pass> replaced with your WiFi network name and password respectively. The LwM2M Client Endpoint Name is configured using the <endpoint_name> parameter. Note A LwM2M Client is uniquely identified by an Endpoint Name . Use the Endpoint Name you created in the Connect to the Server section. Create and open a directory called build : mkdir build && cd build If you\u2019re using Linux or Mac , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" .. If you\u2019re using Windows , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" .. -G \"MinGW Makefiles\" Open up the build directory and run the following command: cmake --build . -j It will generate directories that contain the .uf2 and .hex files. The .uf2 files can be programmed using the bootloader (e.g. drag-and-drop method) and .hex files can be loaded directly into the memory of the device using the rp2 tool. In this example, we will use the .uf2 file. Flash the board using the bootloader: # To program the Raspberry Pi using the bootloader, press and hold the BOOTSEL button while connecting the device using a USB cable - it should be recognized as a Mass Storage device. In the build/mandatory_objects directory, you will find the .uf2 file. Copy the mandatory_objects.uf2 file to the Mass Storage device directory, and wait until the process finishes - copying the firmware image may take a while. Check the logs # With the board still connected to your PC, open a serial communication program (e.g. Minicom) and connect to the Raspberry Pi over a serial port. This will help you to validate if everything is working correctly. Note To open the serial port interface you need to check the name of the connected device and set the proper baud rate: Linux uses /dev/ttyACM[number] or /dev/ttyUSB[number] for a serial port device name. Windows uses COM[number] for a serial port device name. macOS uses /dev/tty.usbmodem[number] for a serial port device name. It\u2019s important to set the correct baud rate, too. The baud rate is the number of symbols transferred in a communication channel per second and must be the same both on the serial communication program and on the board. The most common baud rates for serial ports are 9600 and 115200 . In exercises throughout the academy, we use 115200 baud, since it\u2019s the default value used by Raspberry Pi Pico W. Tip Those logs may help figure out why the device didn't connect to the server (e.g. because of an incorrect WiFi password in the cmake command). If all went well and logs show registration successful/registration successfully updated , you can go to Coiote IoT DM where the Registration status should show Registered . Did you manage to connect the Raspberry Pi Pico W to the Coiote IoT Device Management platform? Well done! You\u2019ve created your first LwM2M application \ud83d\udc4f Data model view # Click the Data model tab from the top menu. In this view, we can see all LwM2M Object the device supports. As of now, there is only the LwM2M Server Object, more objects will be added in future exercises. Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Exercise 1 - Connect the RPI to a LwM2M Server"},{"location":"academy/exercise1/#exercise-1-connect-the-raspberry-pi-pico-w-to-a-lwm2m-server","text":"Let\u2019s start with the first exercise on building an end-to-end LwM2M application by running Anjay LwM2M Client on the Raspberry Pi Pico W, and connecting your device to Coiote IoT Device Management platform over WiFi.","title":"Exercise 1: Connect the Raspberry Pi Pico W to a LwM2M Server"},{"location":"academy/exercise1/#prerequisites","text":"A Raspberry Pi Pico W board with a USB cable Git Access to a WiFi network Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account.","title":"Prerequisites"},{"location":"academy/exercise1/#prepare-binaries","text":"","title":"Prepare binaries"},{"location":"academy/exercise1/#install-dependencies","text":"Configure and compile the LwM2M Client. To do so, you need to install some dependencies and clone three GitHub repositories: Anjay Client for the Raspberry Pi Pico W , the Raspberry Pi Pico W SDK , and the FreeRTOS kernel . Start by creating a new workspace, installing the dependencies, and cloning all three GitHub directories into this workspace. Create and open a new directory: mkdir lwm2m-academy cd lwm2m-academy Install dependencies: Linux When using Ubuntu , run the following command: sudo apt install python3 cmake gcc-arm-none-eabi libnewlib-arm-none-eabi libstdc++-arm-none-eabi-newlib When using Fedora , run the following command: sudo dnf install python3 cmake arm-none-eabi-newlib arm-none-eabi-gcc-cs-c++ arm-none-eabi-gcc-cs arm-none-eabi-binutils-cs gcc-arm-linux-gnu gcc-c++-arm-linux-gnu gcc gcc-c++ Mac When using MacOS, run the following command: brew install python cmake armmbed/formulae/arm-none-eabi-gcc Windows When using Windows, install the following dependencies: Python3 , MinGW and CMake . Download and run the installer to install arm-none-eabi-gcc and arm-none-eabi-gdb . Select the default destination directory (E.g. C:\\GNU_Arm_Embedded_Toolchain ). Check the Add path to environment variable option before you click the Finish button for the installation. Clone three GitHub repositories using Git. Clone the RPi Pico SDK repository and update its submodules git clone -b 1.5.1 https://github.com/raspberrypi/pico-sdk.git cd pico-sdk/ && git submodule update --init && cd .. Clone the FreeRTOS kernel repository git clone -b V10.5.0 https://github.com/FreeRTOS/FreeRTOS-Kernel.git Clone the Anjay-pico-client repository and update its modules git clone https://github.com/AVSystem/Anjay-pico-client.git cd Anjay-pico-client && git submodule update --init --recursive && cd .. Tip Need help? Head over to the lwm2m-academy channel on Discord to get in touch with our experts.","title":"Install dependencies"},{"location":"academy/exercise1/#connect-to-the-lwm2m-server","text":"Before connecting your device to the cloud, log in to Coiote IoT Device Management platform: eu.iot.avsystem.cloud . Once logged in, select Device Inventory from the left-side menu In the Device Inventory, click Add device . Select the tile Connect your LwM2M device directly via the Management server . In the Device Credentials step: Enter the Endpoint name. You can choose an endpoint name by yourself. As the Security mode, choose NoSec . Click Add device and Confirm in the confirmation pop-up. Click Go to Summary to find your Device Center view.","title":"Connect to the LwM2M Server"},{"location":"academy/exercise1/#compile-the-application","text":"Let\u2019s continue building the required files for the application. We are using NoSec mode where encryption and authentication are disabled and the data messages are passed in plain text over the network. In future exercises, we\u2019ll cover secure implementation in more detail. Warning Use the NoSec mode only for development, testing, and debugging purposes, never in production environments unless end-to-end security is provided on a lower layer (e.g. IPSec). To start the compilation of the application, go to the Anjay-pico-client directory . Build the project with <ssid> and <pass> replaced with your WiFi network name and password respectively. The LwM2M Client Endpoint Name is configured using the <endpoint_name> parameter. Note A LwM2M Client is uniquely identified by an Endpoint Name . Use the Endpoint Name you created in the Connect to the Server section. Create and open a directory called build : mkdir build && cd build If you\u2019re using Linux or Mac , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" .. If you\u2019re using Windows , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" .. -G \"MinGW Makefiles\" Open up the build directory and run the following command: cmake --build . -j It will generate directories that contain the .uf2 and .hex files. The .uf2 files can be programmed using the bootloader (e.g. drag-and-drop method) and .hex files can be loaded directly into the memory of the device using the rp2 tool. In this example, we will use the .uf2 file.","title":"Compile the application"},{"location":"academy/exercise1/#flash-the-board-using-the-bootloader","text":"To program the Raspberry Pi using the bootloader, press and hold the BOOTSEL button while connecting the device using a USB cable - it should be recognized as a Mass Storage device. In the build/mandatory_objects directory, you will find the .uf2 file. Copy the mandatory_objects.uf2 file to the Mass Storage device directory, and wait until the process finishes - copying the firmware image may take a while.","title":"Flash the board using the bootloader:"},{"location":"academy/exercise1/#check-the-logs","text":"With the board still connected to your PC, open a serial communication program (e.g. Minicom) and connect to the Raspberry Pi over a serial port. This will help you to validate if everything is working correctly. Note To open the serial port interface you need to check the name of the connected device and set the proper baud rate: Linux uses /dev/ttyACM[number] or /dev/ttyUSB[number] for a serial port device name. Windows uses COM[number] for a serial port device name. macOS uses /dev/tty.usbmodem[number] for a serial port device name. It\u2019s important to set the correct baud rate, too. The baud rate is the number of symbols transferred in a communication channel per second and must be the same both on the serial communication program and on the board. The most common baud rates for serial ports are 9600 and 115200 . In exercises throughout the academy, we use 115200 baud, since it\u2019s the default value used by Raspberry Pi Pico W. Tip Those logs may help figure out why the device didn't connect to the server (e.g. because of an incorrect WiFi password in the cmake command). If all went well and logs show registration successful/registration successfully updated , you can go to Coiote IoT DM where the Registration status should show Registered . Did you manage to connect the Raspberry Pi Pico W to the Coiote IoT Device Management platform? Well done! You\u2019ve created your first LwM2M application \ud83d\udc4f","title":"Check the logs"},{"location":"academy/exercise1/#data-model-view","text":"Click the Data model tab from the top menu. In this view, we can see all LwM2M Object the device supports. As of now, there is only the LwM2M Server Object, more objects will be added in future exercises. Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Data model view"},{"location":"academy/exercise2a/","text":"Exercise 2A: Analyze the Mandatory Objects # In this exercise, we will look into the implementation of the mandatory LwM2M Objects using the Anjay LwM2M Client. To connect the Raspberry Pi to a LwM2M Server and handle incoming packets, three objects need to be implemented: LwM2M Security (Object /0 ) LwM2M Server (Object /1 ) LwM2M Device (Object /3 ) Fortunately, Anjay provides these Objects in the form of pre-implemented modules which can be easily used. In this exercise, we analyze the application \u201c Mandatory Objects \u201d which we built in the exercise of module 1 . This application registers the device to the Coiote IoT Device Management platform and periodically sends status messages. This exercise describes the functionalities of the application that uses the NoSec security mode. In the next exercise we will implement a security mode. Prerequisites # A Raspberry Pi Pico W board with a USB cable. Completed exercise 1 from module 1. An active Coiote IoT DM user account. Introduction to Mandatory Objects # Note This exercise only describes functions from the Anjay-pico-client/mandatory_objects application necessary to run LwM2M Client. To create the Security Object with a different secure mode go to exercise 2B. Go to your local Anjay-pico-client/mandatory_objects directory and open the main.c file in a text editor (e.g. VS Code). Security Object /0 # In the setup_security_object() function the security configurations are defined. The Resources which are configured for the Security Object are: Resource /0/x/10 : Server Short ID (ssid). This Resource explicitly identifies the LwM2M Server. By default, this is set to 1. Additional values can be added when more LwM2M Security Objects are configured. Resource /0/x/0 : LwM2M Server URI . This Resource defines the address of the LwM2M Server. Resource /0/x/2 : Security Mode . This Resource defines the security mode. In this application, the NoSec (no security) mode is used. By changing this parameter, other security modes can be used, including Pre-Shared Key mode and Certificate mode. main.c // Installs Security Object and adds an instance of it. // An instance of Security Object provides information needed to connect // to LwM2M server. static int setup_security_object() { if (anjay_security_object_install(g_anjay)) { return -1; } const anjay_security_instance_t security_instance = { .ssid = 1, .server_uri = \"coap://eu.iot.avsystem.cloud:5683\", .security_mode = ANJAY_SECURITY_NOSEC }; // Anjay will assign Instance ID automatically anjay_iid_t security_instance_id = ANJAY_ID_INVALID; if (anjay_security_object_add_instance(g_anjay, &security_instance, &security_instance_id)) { return -1; } return 0; } Server Object /1 # The Server Object is defined in the setup_server_object() function which can be found in the main.c file. Within this function, the required credentials for connecting to a LwM2M Server are defined. Note The Security and Server configurations are linked by the Short Server ID Resource. That is why we need to ensure the SSIDs in both the setup_server_object() and setup_security_object() match. The Resources which are configured for the Server Object are: Resource /1/x/0 : Short Server ID (ssid). This Resource explicitly identifies the LwM2M Server. By default, this is set to 1. Additional values can be added when more LwM2M Server are configured. Resource /1/x/1 : Lifetime - This Resource shows the time for how long the server deems the registration valid which means that the Client (our device) should send an Update message to the server before Lifetime expires. In this application, the Client sends an update message at least every 50 seconds. Resource /1/x/2 : Default Min Period (pmin) - If this Resource is set, notifications will never be sent more than once every pmin seconds, if this parameter isn't configured on a particular Observation. In this application, we use \u201c-1\u201d which means the Default Minimum Period is disabled. Resource /1/x/3 : Default Max Period (pmax) - If this Resource is set, notifications will always be sent at least once every pmax seconds, if this parameter isn't configured on a particular Observation, even if the value did not change. In this application, we use \u201c-1\u201d which means the Default Maximum Period is disabled. Note Resource /1/x/2 : Default Min Period and Resource /1/x/3 : Default Max Period show usage of LwM2M Notifications which will be described in the next module: Module 4 - Device Management using LwM2M . Resource /1/x/5 : Disable Timeout - This Resource controls the time period after which, the LwM2M Client will re-register to the server. In this application, we use \u201c-1\u201d which means the Disable Timeout is disabled. When this Resource is not set, the default timeout value of 86400 seconds (1 day) is used. Resource /1/x/7 : Binding - This Resource sets the preferred transport method. In this application, it is set to UDP. The LwM2M standard provides the option to set the binding to TCP, SMS, LoRaWAN, CIoT, or WebSockets. main.c // Installs Server Object and adds an instance of it. // An instance of Server Object provides the data related to a LwM2M // Server. static int setup_server_object() { if (anjay_server_object_install(g_anjay)) { return -1; } const anjay_server_instance_t server_instance = { .ssid = 1, .lifetime = 50, .default_min_period = -1, .default_max_period = -1, .disable_timeout = -1, .binding = \"U\" }; // Anjay will assign Instance ID automatically anjay_iid_t server_instance_id = ANJAY_ID_INVALID; if (anjay_server_object_add_instance(g_anjay, &server_instance, &server_instance_id)) { return -1; } return 0; } Device Object /3 # The LwM2M Object can be used to define device-related details such as: Resource /3/x/0 : Manufacturer Resource /3/x/1 : Model Number Resource /3/x/2 : Serial Number Resource /3/x/3 : Firmware Version It is also used for invoking a device Resource /3/x/4 : Reboot or Resource /3/x/5 : Factory Reset . Note Although the LwM2M specifications define the Device Object as mandatory, the Coiote IoT Device Management platform works without creating this Object. Initiate Objects # After the setup_server_object() and the setup_security_object() have been added to the main.c file, these Objects need to be initiated using anjay_task() . This is done using the code below. main.c void anjay_task(__unused void *params) { init_wifi(); anjay_configuration_t config = { .endpoint_name = ENDPOINT_NAME, .in_buffer_size = 2048, .out_buffer_size = 2048, .msg_cache_size = 2048, }; if (!(g_anjay = anjay_new(&config))) { avs_log(main, ERROR, \"Could not create Anjay object\"); exit(1); } // Server and Security Objects are initiated here: if (setup_security_object() || setup_server_object()) { avs_log(main, ERROR, \"Failed to initialize basic objects\"); exit(1); } main_loop(); anjay_delete(g_anjay); } Did you review all of the code snippets in the Mandatory Objects application? Nice work! You now understand the basics of building a LwM2M application. \ud83c\udf89 Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Exercise 2A - Analyze Mandatory Objects"},{"location":"academy/exercise2a/#exercise-2a-analyze-the-mandatory-objects","text":"In this exercise, we will look into the implementation of the mandatory LwM2M Objects using the Anjay LwM2M Client. To connect the Raspberry Pi to a LwM2M Server and handle incoming packets, three objects need to be implemented: LwM2M Security (Object /0 ) LwM2M Server (Object /1 ) LwM2M Device (Object /3 ) Fortunately, Anjay provides these Objects in the form of pre-implemented modules which can be easily used. In this exercise, we analyze the application \u201c Mandatory Objects \u201d which we built in the exercise of module 1 . This application registers the device to the Coiote IoT Device Management platform and periodically sends status messages. This exercise describes the functionalities of the application that uses the NoSec security mode. In the next exercise we will implement a security mode.","title":"Exercise 2A: Analyze the Mandatory Objects"},{"location":"academy/exercise2a/#prerequisites","text":"A Raspberry Pi Pico W board with a USB cable. Completed exercise 1 from module 1. An active Coiote IoT DM user account.","title":"Prerequisites"},{"location":"academy/exercise2a/#introduction-to-mandatory-objects","text":"Note This exercise only describes functions from the Anjay-pico-client/mandatory_objects application necessary to run LwM2M Client. To create the Security Object with a different secure mode go to exercise 2B. Go to your local Anjay-pico-client/mandatory_objects directory and open the main.c file in a text editor (e.g. VS Code).","title":"Introduction to Mandatory Objects"},{"location":"academy/exercise2a/#security-object-0","text":"In the setup_security_object() function the security configurations are defined. The Resources which are configured for the Security Object are: Resource /0/x/10 : Server Short ID (ssid). This Resource explicitly identifies the LwM2M Server. By default, this is set to 1. Additional values can be added when more LwM2M Security Objects are configured. Resource /0/x/0 : LwM2M Server URI . This Resource defines the address of the LwM2M Server. Resource /0/x/2 : Security Mode . This Resource defines the security mode. In this application, the NoSec (no security) mode is used. By changing this parameter, other security modes can be used, including Pre-Shared Key mode and Certificate mode. main.c // Installs Security Object and adds an instance of it. // An instance of Security Object provides information needed to connect // to LwM2M server. static int setup_security_object() { if (anjay_security_object_install(g_anjay)) { return -1; } const anjay_security_instance_t security_instance = { .ssid = 1, .server_uri = \"coap://eu.iot.avsystem.cloud:5683\", .security_mode = ANJAY_SECURITY_NOSEC }; // Anjay will assign Instance ID automatically anjay_iid_t security_instance_id = ANJAY_ID_INVALID; if (anjay_security_object_add_instance(g_anjay, &security_instance, &security_instance_id)) { return -1; } return 0; }","title":"Security Object /0"},{"location":"academy/exercise2a/#server-object-1","text":"The Server Object is defined in the setup_server_object() function which can be found in the main.c file. Within this function, the required credentials for connecting to a LwM2M Server are defined. Note The Security and Server configurations are linked by the Short Server ID Resource. That is why we need to ensure the SSIDs in both the setup_server_object() and setup_security_object() match. The Resources which are configured for the Server Object are: Resource /1/x/0 : Short Server ID (ssid). This Resource explicitly identifies the LwM2M Server. By default, this is set to 1. Additional values can be added when more LwM2M Server are configured. Resource /1/x/1 : Lifetime - This Resource shows the time for how long the server deems the registration valid which means that the Client (our device) should send an Update message to the server before Lifetime expires. In this application, the Client sends an update message at least every 50 seconds. Resource /1/x/2 : Default Min Period (pmin) - If this Resource is set, notifications will never be sent more than once every pmin seconds, if this parameter isn't configured on a particular Observation. In this application, we use \u201c-1\u201d which means the Default Minimum Period is disabled. Resource /1/x/3 : Default Max Period (pmax) - If this Resource is set, notifications will always be sent at least once every pmax seconds, if this parameter isn't configured on a particular Observation, even if the value did not change. In this application, we use \u201c-1\u201d which means the Default Maximum Period is disabled. Note Resource /1/x/2 : Default Min Period and Resource /1/x/3 : Default Max Period show usage of LwM2M Notifications which will be described in the next module: Module 4 - Device Management using LwM2M . Resource /1/x/5 : Disable Timeout - This Resource controls the time period after which, the LwM2M Client will re-register to the server. In this application, we use \u201c-1\u201d which means the Disable Timeout is disabled. When this Resource is not set, the default timeout value of 86400 seconds (1 day) is used. Resource /1/x/7 : Binding - This Resource sets the preferred transport method. In this application, it is set to UDP. The LwM2M standard provides the option to set the binding to TCP, SMS, LoRaWAN, CIoT, or WebSockets. main.c // Installs Server Object and adds an instance of it. // An instance of Server Object provides the data related to a LwM2M // Server. static int setup_server_object() { if (anjay_server_object_install(g_anjay)) { return -1; } const anjay_server_instance_t server_instance = { .ssid = 1, .lifetime = 50, .default_min_period = -1, .default_max_period = -1, .disable_timeout = -1, .binding = \"U\" }; // Anjay will assign Instance ID automatically anjay_iid_t server_instance_id = ANJAY_ID_INVALID; if (anjay_server_object_add_instance(g_anjay, &server_instance, &server_instance_id)) { return -1; } return 0; }","title":"Server Object /1"},{"location":"academy/exercise2a/#device-object-3","text":"The LwM2M Object can be used to define device-related details such as: Resource /3/x/0 : Manufacturer Resource /3/x/1 : Model Number Resource /3/x/2 : Serial Number Resource /3/x/3 : Firmware Version It is also used for invoking a device Resource /3/x/4 : Reboot or Resource /3/x/5 : Factory Reset . Note Although the LwM2M specifications define the Device Object as mandatory, the Coiote IoT Device Management platform works without creating this Object.","title":"Device Object /3"},{"location":"academy/exercise2a/#initiate-objects","text":"After the setup_server_object() and the setup_security_object() have been added to the main.c file, these Objects need to be initiated using anjay_task() . This is done using the code below. main.c void anjay_task(__unused void *params) { init_wifi(); anjay_configuration_t config = { .endpoint_name = ENDPOINT_NAME, .in_buffer_size = 2048, .out_buffer_size = 2048, .msg_cache_size = 2048, }; if (!(g_anjay = anjay_new(&config))) { avs_log(main, ERROR, \"Could not create Anjay object\"); exit(1); } // Server and Security Objects are initiated here: if (setup_security_object() || setup_server_object()) { avs_log(main, ERROR, \"Failed to initialize basic objects\"); exit(1); } main_loop(); anjay_delete(g_anjay); } Did you review all of the code snippets in the Mandatory Objects application? Nice work! You now understand the basics of building a LwM2M application. \ud83c\udf89 Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Initiate Objects"},{"location":"academy/exercise2b/","text":"Exercise 2B: Implement Pre-Shared Key Security Mode # In this exercise, we will change the security mode from No-Sec to Pre-Shared Key (PSK). In this mode, communication is symmetrically encrypted and authenticated using the same secret key (password), shared between the server and the client. Prerequisites # A Raspberry Pi Pico W board with a USB cable. Completed exercise 1 from module 1. Completed exercise 2A from module 2. Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account. Connect to the LwM2M Server # For LwM2M Servers like Coiote IoT DM , server-side configuration needs to be updated to enable LwM2M Clients to connect using PSK. The simplest solution is to edit the connection parameters on the Coiote IoT Device Management platform configuration page. Follow the next steps to change the parameters and set them to Pre-Shared Key mode. Change connection parameters # Log in to Coiote IoT DM: https://eu.iot.avsystem.cloud . Select Device Inventory from the left-side menu. From the Device Inventory, go to your created device. Go to the Configuration page and click the right pencil icon on the Connection parameters panel. Update Connection parameters : In the Security mode section, select the Pre-Shared Key mode: In the Key identity field, it\u2019s recommended to provide the same value as in the Endpoint name field. In the Key field , create the shared secret used for device-server authentication. During the compilation step you will provide the PSK_KEY which must have the same value as the Key . Warning Nowadays it\u2019s easy to guess simple human-generated passwords. Generating a password using a combination of alphanumeric characters and special symbols ensures its security. Avoid putting your personal information and generate a combination of keys to help you maximize safety and security. Click the Save button and confirm the changes. Configure credentials in application sources # Let\u2019s get started by going to the Anjay-pico-client directory and creating a new directory called psk-mode . Important Copy and paste the main.c and CMakeLists.txt files from the Anjay-pico-client/mandatory_objects directory into the Anjay-pico-client/psk-mode directory. Open the main.c file in a code editor (e.g. VS Code). In this file, modify the setup_security_object() function to change Anjay\u2019s security settings and add the configuration of PSK-based encryption. This can be done using the code below. main.c static int setup_security_object() { if (anjay_security_object_install(g_anjay)) { return -1; } static const char psk_identity[] = PSK_IDENTITY; static const char psk_key[] = PSK_KEY; const anjay_security_instance_t security_instance = { .ssid = 1, .server_uri = \"coaps://eu.iot.avsystem.cloud:5684\", .security_mode = ANJAY_SECURITY_PSK, .public_cert_or_psk_identity = (const uint8_t *) psk_identity, .public_cert_or_psk_identity_size = strlen(psk_identity), .private_cert_or_psk_key = (const uint8_t *) psk_key, .private_cert_or_psk_key_size = strlen(psk_key) }; anjay_iid_t security_instance_id = ANJAY_ID_INVALID; if (anjay_security_object_add_instance(g_anjay, &security_instance, &security_instance_id)) { return -1; } return 0; } Next, open the CMakeLists.txt , change the file names and add the required information about the PSK mode. CMakeLists.txt cmake_minimum_required(VERSION 3.13) add_executable(psk-mode main.c ) target_link_libraries(psk-mode pico_stdlib anjay-pico FreeRTOS ) target_include_directories(psk-mode PRIVATE ${COMMON_DIR}/config ) target_compile_definitions(psk-mode PRIVATE WIFI_SSID=\\\"${WIFI_SSID}\\\" WIFI_PASSWORD=\\\"${WIFI_PASSWORD}\\\" ENDPOINT_NAME=\\\"${ENDPOINT_NAME}\\\" PSK_IDENTITY=\\\"${PSK_IDENTITY}\\\" PSK_KEY=\\\"${PSK_KEY}\\\" ) pico_enable_stdio_usb(psk-mode 1) pico_enable_stdio_uart(psk-mode 0) pico_add_extra_outputs(psk-mode) At the end of the file add the mention about subdirectory to the general CMakeLists.txt. Anjay-pico-client/CMakeLists.txt add_subdirectory(psk-mode) Now the client is ready to be built and connected to LwM2M Server, allowing it to read the Time object. Important Be aware that the Anjay-pico-client/CMakeLists.txt and Anjay-pico-client/psk-mode/CMakeLists.txt are two different files. Tip Need help? Head over to the lwm2m-academy channel on Discord to get in touch with our experts. Configure PSK Identity and Pre-Shared Key # After updating the setup_security_object() function in the main.c file, it is time to describe the most important variables to configure the PSK mode. PSK Identity ( PSK_IDENTITY ) is the name by which the device identifies itself during the DTLS handshake. It is recommended to use the endpoint name as the Key identity. PSK Key ( PSK_KEY ) is the shared secret (password) the device uses for server connections in PSK mode. You must enter this PSK Key in plain text. Server URI ( server_uri ) points to the LwM2M Server. Note that the URI port has changed from 5683 to 5684 . Note The complete code for a similar example targeting desktop platforms can be found in the secure_communication subdirectory of the Anjay-pico-client project repository. Recompile the application and flash the board # To recompile the application, go to the Anjay-pico-client/build directory. If you\u2019re using Linux or Mac , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. If you\u2019re using Windows , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. -G \"MinGW Makefiles\" Run the following command in the build directory: cmake --build . -j Program your board using the bootloader. Press and hold the BOOTSEL button while connecting the device through a USB cable - it should be recognized as a Mass Storage device. In the build/psk-mode directory, you will find the .uf2 file which contains the added changes. Copy the psk-mode.uf2 file to the Mass Storage device directory, and wait until the process finishes - copying the firmware image may take a while. Check the logs # If all went well and logs show registration successfully updated . In Coiote IoT Device Management platform, the Registration status should show Registered and the Security mode in the bottom-left corner panel should now include the tag: Pre-Shared Key . Can you see Registered in the registration status and the tag Pre-Shared Key ? If yes, well done! \ud83d\udc4f \ud83d\udc4f Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Exercise 2B - Pre-Shared Key"},{"location":"academy/exercise2b/#exercise-2b-implement-pre-shared-key-security-mode","text":"In this exercise, we will change the security mode from No-Sec to Pre-Shared Key (PSK). In this mode, communication is symmetrically encrypted and authenticated using the same secret key (password), shared between the server and the client.","title":"Exercise 2B: Implement Pre-Shared Key Security Mode"},{"location":"academy/exercise2b/#prerequisites","text":"A Raspberry Pi Pico W board with a USB cable. Completed exercise 1 from module 1. Completed exercise 2A from module 2. Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account.","title":"Prerequisites"},{"location":"academy/exercise2b/#connect-to-the-lwm2m-server","text":"For LwM2M Servers like Coiote IoT DM , server-side configuration needs to be updated to enable LwM2M Clients to connect using PSK. The simplest solution is to edit the connection parameters on the Coiote IoT Device Management platform configuration page. Follow the next steps to change the parameters and set them to Pre-Shared Key mode.","title":"Connect to the LwM2M Server"},{"location":"academy/exercise2b/#change-connection-parameters","text":"Log in to Coiote IoT DM: https://eu.iot.avsystem.cloud . Select Device Inventory from the left-side menu. From the Device Inventory, go to your created device. Go to the Configuration page and click the right pencil icon on the Connection parameters panel. Update Connection parameters : In the Security mode section, select the Pre-Shared Key mode: In the Key identity field, it\u2019s recommended to provide the same value as in the Endpoint name field. In the Key field , create the shared secret used for device-server authentication. During the compilation step you will provide the PSK_KEY which must have the same value as the Key . Warning Nowadays it\u2019s easy to guess simple human-generated passwords. Generating a password using a combination of alphanumeric characters and special symbols ensures its security. Avoid putting your personal information and generate a combination of keys to help you maximize safety and security. Click the Save button and confirm the changes.","title":"Change connection parameters"},{"location":"academy/exercise2b/#configure-credentials-in-application-sources","text":"Let\u2019s get started by going to the Anjay-pico-client directory and creating a new directory called psk-mode . Important Copy and paste the main.c and CMakeLists.txt files from the Anjay-pico-client/mandatory_objects directory into the Anjay-pico-client/psk-mode directory. Open the main.c file in a code editor (e.g. VS Code). In this file, modify the setup_security_object() function to change Anjay\u2019s security settings and add the configuration of PSK-based encryption. This can be done using the code below. main.c static int setup_security_object() { if (anjay_security_object_install(g_anjay)) { return -1; } static const char psk_identity[] = PSK_IDENTITY; static const char psk_key[] = PSK_KEY; const anjay_security_instance_t security_instance = { .ssid = 1, .server_uri = \"coaps://eu.iot.avsystem.cloud:5684\", .security_mode = ANJAY_SECURITY_PSK, .public_cert_or_psk_identity = (const uint8_t *) psk_identity, .public_cert_or_psk_identity_size = strlen(psk_identity), .private_cert_or_psk_key = (const uint8_t *) psk_key, .private_cert_or_psk_key_size = strlen(psk_key) }; anjay_iid_t security_instance_id = ANJAY_ID_INVALID; if (anjay_security_object_add_instance(g_anjay, &security_instance, &security_instance_id)) { return -1; } return 0; } Next, open the CMakeLists.txt , change the file names and add the required information about the PSK mode. CMakeLists.txt cmake_minimum_required(VERSION 3.13) add_executable(psk-mode main.c ) target_link_libraries(psk-mode pico_stdlib anjay-pico FreeRTOS ) target_include_directories(psk-mode PRIVATE ${COMMON_DIR}/config ) target_compile_definitions(psk-mode PRIVATE WIFI_SSID=\\\"${WIFI_SSID}\\\" WIFI_PASSWORD=\\\"${WIFI_PASSWORD}\\\" ENDPOINT_NAME=\\\"${ENDPOINT_NAME}\\\" PSK_IDENTITY=\\\"${PSK_IDENTITY}\\\" PSK_KEY=\\\"${PSK_KEY}\\\" ) pico_enable_stdio_usb(psk-mode 1) pico_enable_stdio_uart(psk-mode 0) pico_add_extra_outputs(psk-mode) At the end of the file add the mention about subdirectory to the general CMakeLists.txt. Anjay-pico-client/CMakeLists.txt add_subdirectory(psk-mode) Now the client is ready to be built and connected to LwM2M Server, allowing it to read the Time object. Important Be aware that the Anjay-pico-client/CMakeLists.txt and Anjay-pico-client/psk-mode/CMakeLists.txt are two different files. Tip Need help? Head over to the lwm2m-academy channel on Discord to get in touch with our experts.","title":"Configure credentials in application sources"},{"location":"academy/exercise2b/#configure-psk-identity-and-pre-shared-key","text":"After updating the setup_security_object() function in the main.c file, it is time to describe the most important variables to configure the PSK mode. PSK Identity ( PSK_IDENTITY ) is the name by which the device identifies itself during the DTLS handshake. It is recommended to use the endpoint name as the Key identity. PSK Key ( PSK_KEY ) is the shared secret (password) the device uses for server connections in PSK mode. You must enter this PSK Key in plain text. Server URI ( server_uri ) points to the LwM2M Server. Note that the URI port has changed from 5683 to 5684 . Note The complete code for a similar example targeting desktop platforms can be found in the secure_communication subdirectory of the Anjay-pico-client project repository.","title":"Configure PSK Identity and Pre-Shared Key"},{"location":"academy/exercise2b/#recompile-the-application-and-flash-the-board","text":"To recompile the application, go to the Anjay-pico-client/build directory. If you\u2019re using Linux or Mac , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. If you\u2019re using Windows , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. -G \"MinGW Makefiles\" Run the following command in the build directory: cmake --build . -j Program your board using the bootloader. Press and hold the BOOTSEL button while connecting the device through a USB cable - it should be recognized as a Mass Storage device. In the build/psk-mode directory, you will find the .uf2 file which contains the added changes. Copy the psk-mode.uf2 file to the Mass Storage device directory, and wait until the process finishes - copying the firmware image may take a while.","title":"Recompile the application and flash the board"},{"location":"academy/exercise2b/#check-the-logs","text":"If all went well and logs show registration successfully updated . In Coiote IoT Device Management platform, the Registration status should show Registered and the Security mode in the bottom-left corner panel should now include the tag: Pre-Shared Key . Can you see Registered in the registration status and the tag Pre-Shared Key ? If yes, well done! \ud83d\udc4f \ud83d\udc4f Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Check the logs"},{"location":"academy/exercise3a/","text":"Exercise 3A: Implement the Time Object # In this exercise, we are implementing the Time Object /3333 using LwM2M version 1.0. With only 3 Resources, it is one of the simplest Objects defined in the OMA LwM2M Registry . The Object allows LwM2M Clients to report the current time in seconds since January 1, 1970, UTC. The Time Object contains three Resources as shown in the table below. ID Name Operations Mandatory Type Description 5506 Current Time RW Mandatory Time Unix Time. A signed integer representing the number of seconds since Jan 1st, 1970 in the UTC time zone. 5507 Fractional Time RW Optional Float A fractional part of the time when sub-second precision is used (e.g., 0.23 for 230 ms). 5750 Application Type RW Optional String The application type of the sensor or actuator as a string depending on the use case. This description identifies Instance (e.g. description indicating the time comes from GPS, internal server clock, or another source) Explanation of table rows: ID - number used to identify the particular Resource. Operations - RW indicates that the Resource is Readable and Writable (the third possible option is E - Executable). Mandatory - not all Resources must be implemented to comply with the specification. In this case, only the Current Time Resource is mandatory. Note Current Time and Fractional Time Resources are writable, but for this exercise, we will only focus on implementing the read operation for these two resources. With our Time Object we will initiate one Instance, implement the read and write functions, make the device responsive to server read commands, and make the Object register to the server at boot. Prerequisites # A Raspberry Pi Pico W board with a USB cable Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. Python An active Coiote IoT DM user account. Completed exercise 2B from module 2 Implement the Time Object # Let\u2019s get started by going to the Anjay-pico-client directory and creating a new directory called time_object . Go to the directory and start by generating the Object's implementation. Important Copy and paste the main.c and CMakeLists.txt files from the Anjay-pico-client/secure_communication directory to the Anjay-pico-client/time_object directory. Generate base source code # To generate a layout of the Object\u2019s implementation, we will use the anjay_codegen.py and lwm2m_object_registry.py scripts which are bundled with the Anjay library. The script downloads the LwM2M Object Definition and generates a skeleton of the LwM2M Object code, requiring you to only fill in actual Object logic. For more information about the script, visit the Anjay documentation . If you\u2019re using Linux or MacOS go to the Anjay-pico-client directory, and run the following commands in your command line: python3 deps/anjay/tools/lwm2m_object_registry.py --get-xml 3333 -v 1.0 > time_object/lwm2m_3333.xml python3 deps/anjay/tools/anjay_codegen.py -i time_object/lwm2m_3333.xml -o time_object/time_object.c Important If you\u2019re using Windows , use python instead of python3 . The commands use the anjay_codegen.py and lwm2m_object_registry.py scripts to generate the lwm2m_3333.xml and time_object.c files in the Anjay-pico-client/time_object . The generated files still require some modifications to make them operational. In the next part, you can find the highlighted code blocks which should be added to the time_object.c files. Instance and Object state # Each Object requires at least one Object Instance which contains all the required Resources. Go to the Anjay-pico-client/time_object directory and open the file time_object.c . Start by adding some variables responsible for the state of our Time Object Instance to the time_instance_t structure. For this add a value of Application Type Resource because Current Time Resource will be using a system clock source directly, whenever a read handler is called. Note There is also a second array for keeping a backup of the Application Type - this will be required for the implementation of transactions. We will get back to it at the end of this exercise. time_object.c typedef struct time_instance_struct { anjay_iid_t iid; char application_type[64]; char application_type_backup[64]; } time_instance_t; typedef struct time_object_struct { const anjay_dm_object_def_t *def; AVS_LIST(time_instance_t) instances; } time_object_t; Initiate, release, and reset the Instance # Next up is implementing the init_instance() and release_instance() functions. These functions are used during the creation and deletion of Instances, usually performed through device work. In this case, all we have to do is initialize the Application Type with some value. We can do this by setting the first byte of time_instance_t::application_type variable to \\0 . Note To better understand the code, it is useful to know the \u201cfull names\u201d of some variables: obj - Object iid - Instance ID rid - Resource ID riid - Resource Instance ID time_object.c static int init_instance(time_instance_t *inst, anjay_iid_t iid) { assert(iid != ANJAY_ID_INVALID); inst->iid = iid; inst->application_type[0] = '\\0'; return 0; } The next function to implement is instance_reset() which resets the Instance to its default state. In our case, this means we clear the Application Type. time_object.c static int instance_reset(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr, anjay_iid_t iid) { (void) anjay; time_object_t *obj = get_obj(obj_ptr); assert(obj); time_instance_t *inst = find_instance(obj, iid); assert(inst); inst->application_type[0] = '\\0'; return 0; } We can also disable the presence of one of the Resources in the list_resources() function. It is done by changing ANJAY_DM_RES_PRESENT to ANJAY_DM_RES_ABSENT in the anjay_dm_emit_res() call. This change will simplify the implementation of the Read Handler and Observe/Notifications support in the next section. time_object.c static int list_resources(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr, anjay_iid_t iid, anjay_dm_resource_list_ctx_t *ctx) { (void) anjay; (void) obj_ptr; (void) iid; anjay_dm_emit_res(ctx, RID_CURRENT_TIME, ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT); anjay_dm_emit_res(ctx, RID_FRACTIONAL_TIME, ANJAY_DM_RES_RW, ANJAY_DM_RES_ABSENT); anjay_dm_emit_res(ctx, RID_APPLICATION_TYPE, ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT); return 0; } Note Using the -r command line option in anjay_codegen.py you can generate Object\u2019s stub with specified Resources only. You can run python3 deps/anjay/tools/anjay_codegen.py --help from the Anjay-pico-client direcotry for more help. Read and Write handlers # Now we are ready to implement resource_read() and resource_write() handlers. These handlers will be called every time LwM2M Server performs a Read or Write operation on the Time Object. Note Read and Write operations will be described in more detail in the next module: Module 4 - Device Management using LwM2M . The resource_read() operation on Current Time resource should return current time in seconds since January 1, 1970, UTC. To get this value, we can use the preimplemented avs_time_real_now() function. The same operation on Application Type resource should return the time_instance_t::application_type string. Because we\u2019ve made the Fractional Time resource absent, we won\u2019t perform any actions on this resource during resource_read() operation. time_object.c static int resource_read(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr, anjay_iid_t iid, anjay_rid_t rid, anjay_riid_t riid, anjay_output_ctx_t *ctx) { (void) anjay; time_object_t *obj = get_obj(obj_ptr); assert(obj); time_instance_t *inst = find_instance(obj, iid); assert(inst); switch (rid) { case RID_CURRENT_TIME: { assert(riid == ANJAY_ID_INVALID); int64_t timestamp; if (avs_time_real_to_scalar(&timestamp, AVS_TIME_S, avs_time_real_now())) { return -1; } return anjay_ret_i64(ctx, timestamp); } case RID_APPLICATION_TYPE: assert(riid == ANJAY_ID_INVALID); return anjay_ret_string(ctx, inst->application_type); default: return ANJAY_ERR_METHOD_NOT_ALLOWED; } } As discussed, we only implement the Read operation on the Current Time Resource, so the Write operation is only implemented on the Application Type Resource. time_object.c static int resource_write(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr, anjay_iid_t iid, anjay_rid_t rid, anjay_riid_t riid, anjay_input_ctx_t *ctx) { (void) anjay; time_object_t *obj = get_obj(obj_ptr); assert(obj); time_instance_t *inst = find_instance(obj, iid); assert(inst); switch (rid) { case RID_APPLICATION_TYPE: assert(riid == ANJAY_ID_INVALID); return anjay_get_string(ctx, inst->application_type, sizeof(inst->application_type)); default: return ANJAY_ERR_METHOD_NOT_ALLOWED; } } Initialize the Object # There is one function left to implement: time_object_create() . This function uses add_instance() to create an Object Instance, allowing data to be read by the LwM2M Server. time_object.c const anjay_dm_object_def_t **time_object_create(void) { time_object_t *obj = (time_object_t *) avs_calloc(1, sizeof(time_object_t)); if (!obj) { return NULL; } obj->def = &OBJ_DEF; time_instance_t *inst = add_instance(obj, 0); if (!inst) { avs_free(obj); return NULL; } strcpy(inst->application_type, \"Clock 0\"); return &obj->def; } Register the Object in Anjay # The last thing to do is to create the header file time_object.h for the implemented object, include the header file in the main.c and update the CMakeLists.txt file. time_object.h #pragma once #include <anjay/dm.h> const anjay_dm_object_def_t **time_object_create(void); void time_object_release(const anjay_dm_object_def_t **def); main.c void anjay_task(__unused void *params) { init_wifi(); anjay_configuration_t config = { .endpoint_name = ENDPOINT_NAME, .in_buffer_size = 2048, .out_buffer_size = 2048, .msg_cache_size = 2048, }; if (!(g_anjay = anjay_new(&config))) { avs_log(main, ERROR, \"Could not create Anjay object\"); exit(1); } if (setup_security_object() || setup_server_object()) { avs_log(main, ERROR, \"Failed to initialize basic objects\"); exit(1); } const anjay_dm_object_def_t **time_object = time_object_create(); if (!time_object || anjay_register_object(g_anjay, time_object)) { avs_log(main, WARNING, \"Failed to initialize time object\"); } main_loop(); time_object_release(time_object); anjay_delete(g_anjay); } Include the time_object.h file on the top of the main.c file. time_object.c #include <avsystem/commons/avs_list.h> #include <avsystem/commons/avs_log.h> #include <avsystem/commons/avs_prng.h> #include <avsystem/commons/avs_time.h> #include \"time_object.h\" #ifndef RUN_FREERTOS_ON_CORE # define RUN_FREERTOS_ON_CORE 0 #endif CMakeLists.txt cmake_minimum_required(VERSION 3.13) add_executable(time_object main.c time_object.c time_object.h ) target_link_libraries(time_object pico_stdlib anjay-pico FreeRTOS ) target_include_directories(time_object PRIVATE ${COMMON_DIR}/config ) target_compile_definitions(time_object PRIVATE WIFI_SSID=\\\"${WIFI_SSID}\\\" WIFI_PASSWORD=\\\"${WIFI_PASSWORD}\\\" ENDPOINT_NAME=\\\"${ENDPOINT_NAME}\\\" PSK_IDENTITY=\\\"${PSK_IDENTITY}\\\" PSK_KEY=\\\"${PSK_KEY}\\\" ) pico_enable_stdio_usb(time_object 1) pico_enable_stdio_uart(time_object 0) pico_add_extra_outputs(time_object) At the end of the file add the mention about subdirectory to the general CMakeLists.txt . Anjay-pico-client/CMakeLists.txt add_subdirectory(time_object) Now the client is ready to be built and connected to LwM2M Server, allowing it to read the Time object. Support transactional writes # Consider the following scenario: the LwM2M Server tries to write to two or more Resources simultaneously. The write-on Application Type will probably succeed, but we are sure that writing at the Current Time will fail as we didn\u2019t implement this Write operation. Without supporting transactions, the entire Write operation will fail. By default, transaction handlers are set to anjay_dm_transaction_NOOP and do nothing. To properly support Writes on the O two handlers: transaction_begin which makes a backup of the Application Type value, and transaction_rollback which reverts the Application Type to its initial value (before the Write operation is performed) for which we need the time_instance_t::application_type_backup array. Go back to the time_object.c file and update the file using the following code block: time_object.c static int transaction_begin(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr) { (void) anjay; time_object_t *obj = get_obj(obj_ptr); time_instance_t *element; AVS_LIST_FOREACH(element, obj->instances) { strcpy(element->application_type_backup, element->application_type); } return 0; } static int transaction_rollback(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr) { (void) anjay; time_object_t *obj = get_obj(obj_ptr); time_instance_t *element; AVS_LIST_FOREACH(element, obj->instances) { strcpy(element->application_type, element->application_type_backup); } return 0; } static const anjay_dm_object_def_t OBJ_DEF = { .oid = 3333, .handlers = { .list_instances = list_instances, .instance_create = instance_create, .instance_remove = instance_remove, .instance_reset = instance_reset, .list_resources = list_resources, .resource_read = resource_read, .resource_write = resource_write, .transaction_begin = transaction_begin, .transaction_validate = anjay_dm_transaction_NOOP, .transaction_commit = anjay_dm_transaction_NOOP, .transaction_rollback = transaction_rollback } }; Recompile the application and flash the board # To recompile the application, go to the Anjay-pico-client/build directory. If you\u2019re using Linux or Mac , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. If you\u2019re using Windows , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. -G \"MinGW Makefiles\" Run the following command in the build directory cmake --build . -j Program your board using the bootloader. Press and hold the BOOTSEL button while connecting the device through a USB cable - it should be recognized as a Mass Storage device. In the build/time_object directory, you will find the .uf2 file which has our added changes. Copy the time_object.uf2 file to the Mass Storage device directory, and wait until the process finishes - copying the firmware image may take a while. Check the logs # With the board still connected to your PC, open a serial communication program. This will help you to check if everything is working correctly. If all went well and logs show registration successfully updated , you can go to Coiote IoT Device Management platform where the Registration status should show Registered . Go to the Data Model and check if you can see the Time Object in the Defined objects section. Note The Object allows LwM2M Clients to report the current time in seconds since January 1, 1970, UTC. After refreshing the page you can see that the value changed. Good job! \ud83d\udc4f\ud83d\udc4f Now you are ready to create more difficult Objects. For this, go to the next exercise. Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Exercise 3A - Implement Time Object"},{"location":"academy/exercise3a/#exercise-3a-implement-the-time-object","text":"In this exercise, we are implementing the Time Object /3333 using LwM2M version 1.0. With only 3 Resources, it is one of the simplest Objects defined in the OMA LwM2M Registry . The Object allows LwM2M Clients to report the current time in seconds since January 1, 1970, UTC. The Time Object contains three Resources as shown in the table below. ID Name Operations Mandatory Type Description 5506 Current Time RW Mandatory Time Unix Time. A signed integer representing the number of seconds since Jan 1st, 1970 in the UTC time zone. 5507 Fractional Time RW Optional Float A fractional part of the time when sub-second precision is used (e.g., 0.23 for 230 ms). 5750 Application Type RW Optional String The application type of the sensor or actuator as a string depending on the use case. This description identifies Instance (e.g. description indicating the time comes from GPS, internal server clock, or another source) Explanation of table rows: ID - number used to identify the particular Resource. Operations - RW indicates that the Resource is Readable and Writable (the third possible option is E - Executable). Mandatory - not all Resources must be implemented to comply with the specification. In this case, only the Current Time Resource is mandatory. Note Current Time and Fractional Time Resources are writable, but for this exercise, we will only focus on implementing the read operation for these two resources. With our Time Object we will initiate one Instance, implement the read and write functions, make the device responsive to server read commands, and make the Object register to the server at boot.","title":"Exercise 3A: Implement the Time Object"},{"location":"academy/exercise3a/#prerequisites","text":"A Raspberry Pi Pico W board with a USB cable Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. Python An active Coiote IoT DM user account. Completed exercise 2B from module 2","title":"Prerequisites"},{"location":"academy/exercise3a/#implement-the-time-object","text":"Let\u2019s get started by going to the Anjay-pico-client directory and creating a new directory called time_object . Go to the directory and start by generating the Object's implementation. Important Copy and paste the main.c and CMakeLists.txt files from the Anjay-pico-client/secure_communication directory to the Anjay-pico-client/time_object directory.","title":"Implement the Time Object"},{"location":"academy/exercise3a/#generate-base-source-code","text":"To generate a layout of the Object\u2019s implementation, we will use the anjay_codegen.py and lwm2m_object_registry.py scripts which are bundled with the Anjay library. The script downloads the LwM2M Object Definition and generates a skeleton of the LwM2M Object code, requiring you to only fill in actual Object logic. For more information about the script, visit the Anjay documentation . If you\u2019re using Linux or MacOS go to the Anjay-pico-client directory, and run the following commands in your command line: python3 deps/anjay/tools/lwm2m_object_registry.py --get-xml 3333 -v 1.0 > time_object/lwm2m_3333.xml python3 deps/anjay/tools/anjay_codegen.py -i time_object/lwm2m_3333.xml -o time_object/time_object.c Important If you\u2019re using Windows , use python instead of python3 . The commands use the anjay_codegen.py and lwm2m_object_registry.py scripts to generate the lwm2m_3333.xml and time_object.c files in the Anjay-pico-client/time_object . The generated files still require some modifications to make them operational. In the next part, you can find the highlighted code blocks which should be added to the time_object.c files.","title":"Generate base source code"},{"location":"academy/exercise3a/#instance-and-object-state","text":"Each Object requires at least one Object Instance which contains all the required Resources. Go to the Anjay-pico-client/time_object directory and open the file time_object.c . Start by adding some variables responsible for the state of our Time Object Instance to the time_instance_t structure. For this add a value of Application Type Resource because Current Time Resource will be using a system clock source directly, whenever a read handler is called. Note There is also a second array for keeping a backup of the Application Type - this will be required for the implementation of transactions. We will get back to it at the end of this exercise. time_object.c typedef struct time_instance_struct { anjay_iid_t iid; char application_type[64]; char application_type_backup[64]; } time_instance_t; typedef struct time_object_struct { const anjay_dm_object_def_t *def; AVS_LIST(time_instance_t) instances; } time_object_t;","title":"Instance and Object state"},{"location":"academy/exercise3a/#initiate-release-and-reset-the-instance","text":"Next up is implementing the init_instance() and release_instance() functions. These functions are used during the creation and deletion of Instances, usually performed through device work. In this case, all we have to do is initialize the Application Type with some value. We can do this by setting the first byte of time_instance_t::application_type variable to \\0 . Note To better understand the code, it is useful to know the \u201cfull names\u201d of some variables: obj - Object iid - Instance ID rid - Resource ID riid - Resource Instance ID time_object.c static int init_instance(time_instance_t *inst, anjay_iid_t iid) { assert(iid != ANJAY_ID_INVALID); inst->iid = iid; inst->application_type[0] = '\\0'; return 0; } The next function to implement is instance_reset() which resets the Instance to its default state. In our case, this means we clear the Application Type. time_object.c static int instance_reset(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr, anjay_iid_t iid) { (void) anjay; time_object_t *obj = get_obj(obj_ptr); assert(obj); time_instance_t *inst = find_instance(obj, iid); assert(inst); inst->application_type[0] = '\\0'; return 0; } We can also disable the presence of one of the Resources in the list_resources() function. It is done by changing ANJAY_DM_RES_PRESENT to ANJAY_DM_RES_ABSENT in the anjay_dm_emit_res() call. This change will simplify the implementation of the Read Handler and Observe/Notifications support in the next section. time_object.c static int list_resources(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr, anjay_iid_t iid, anjay_dm_resource_list_ctx_t *ctx) { (void) anjay; (void) obj_ptr; (void) iid; anjay_dm_emit_res(ctx, RID_CURRENT_TIME, ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT); anjay_dm_emit_res(ctx, RID_FRACTIONAL_TIME, ANJAY_DM_RES_RW, ANJAY_DM_RES_ABSENT); anjay_dm_emit_res(ctx, RID_APPLICATION_TYPE, ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT); return 0; } Note Using the -r command line option in anjay_codegen.py you can generate Object\u2019s stub with specified Resources only. You can run python3 deps/anjay/tools/anjay_codegen.py --help from the Anjay-pico-client direcotry for more help.","title":"Initiate, release, and reset the Instance"},{"location":"academy/exercise3a/#read-and-write-handlers","text":"Now we are ready to implement resource_read() and resource_write() handlers. These handlers will be called every time LwM2M Server performs a Read or Write operation on the Time Object. Note Read and Write operations will be described in more detail in the next module: Module 4 - Device Management using LwM2M . The resource_read() operation on Current Time resource should return current time in seconds since January 1, 1970, UTC. To get this value, we can use the preimplemented avs_time_real_now() function. The same operation on Application Type resource should return the time_instance_t::application_type string. Because we\u2019ve made the Fractional Time resource absent, we won\u2019t perform any actions on this resource during resource_read() operation. time_object.c static int resource_read(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr, anjay_iid_t iid, anjay_rid_t rid, anjay_riid_t riid, anjay_output_ctx_t *ctx) { (void) anjay; time_object_t *obj = get_obj(obj_ptr); assert(obj); time_instance_t *inst = find_instance(obj, iid); assert(inst); switch (rid) { case RID_CURRENT_TIME: { assert(riid == ANJAY_ID_INVALID); int64_t timestamp; if (avs_time_real_to_scalar(&timestamp, AVS_TIME_S, avs_time_real_now())) { return -1; } return anjay_ret_i64(ctx, timestamp); } case RID_APPLICATION_TYPE: assert(riid == ANJAY_ID_INVALID); return anjay_ret_string(ctx, inst->application_type); default: return ANJAY_ERR_METHOD_NOT_ALLOWED; } } As discussed, we only implement the Read operation on the Current Time Resource, so the Write operation is only implemented on the Application Type Resource. time_object.c static int resource_write(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr, anjay_iid_t iid, anjay_rid_t rid, anjay_riid_t riid, anjay_input_ctx_t *ctx) { (void) anjay; time_object_t *obj = get_obj(obj_ptr); assert(obj); time_instance_t *inst = find_instance(obj, iid); assert(inst); switch (rid) { case RID_APPLICATION_TYPE: assert(riid == ANJAY_ID_INVALID); return anjay_get_string(ctx, inst->application_type, sizeof(inst->application_type)); default: return ANJAY_ERR_METHOD_NOT_ALLOWED; } }","title":"Read and Write handlers"},{"location":"academy/exercise3a/#initialize-the-object","text":"There is one function left to implement: time_object_create() . This function uses add_instance() to create an Object Instance, allowing data to be read by the LwM2M Server. time_object.c const anjay_dm_object_def_t **time_object_create(void) { time_object_t *obj = (time_object_t *) avs_calloc(1, sizeof(time_object_t)); if (!obj) { return NULL; } obj->def = &OBJ_DEF; time_instance_t *inst = add_instance(obj, 0); if (!inst) { avs_free(obj); return NULL; } strcpy(inst->application_type, \"Clock 0\"); return &obj->def; }","title":"Initialize the Object"},{"location":"academy/exercise3a/#register-the-object-in-anjay","text":"The last thing to do is to create the header file time_object.h for the implemented object, include the header file in the main.c and update the CMakeLists.txt file. time_object.h #pragma once #include <anjay/dm.h> const anjay_dm_object_def_t **time_object_create(void); void time_object_release(const anjay_dm_object_def_t **def); main.c void anjay_task(__unused void *params) { init_wifi(); anjay_configuration_t config = { .endpoint_name = ENDPOINT_NAME, .in_buffer_size = 2048, .out_buffer_size = 2048, .msg_cache_size = 2048, }; if (!(g_anjay = anjay_new(&config))) { avs_log(main, ERROR, \"Could not create Anjay object\"); exit(1); } if (setup_security_object() || setup_server_object()) { avs_log(main, ERROR, \"Failed to initialize basic objects\"); exit(1); } const anjay_dm_object_def_t **time_object = time_object_create(); if (!time_object || anjay_register_object(g_anjay, time_object)) { avs_log(main, WARNING, \"Failed to initialize time object\"); } main_loop(); time_object_release(time_object); anjay_delete(g_anjay); } Include the time_object.h file on the top of the main.c file. time_object.c #include <avsystem/commons/avs_list.h> #include <avsystem/commons/avs_log.h> #include <avsystem/commons/avs_prng.h> #include <avsystem/commons/avs_time.h> #include \"time_object.h\" #ifndef RUN_FREERTOS_ON_CORE # define RUN_FREERTOS_ON_CORE 0 #endif CMakeLists.txt cmake_minimum_required(VERSION 3.13) add_executable(time_object main.c time_object.c time_object.h ) target_link_libraries(time_object pico_stdlib anjay-pico FreeRTOS ) target_include_directories(time_object PRIVATE ${COMMON_DIR}/config ) target_compile_definitions(time_object PRIVATE WIFI_SSID=\\\"${WIFI_SSID}\\\" WIFI_PASSWORD=\\\"${WIFI_PASSWORD}\\\" ENDPOINT_NAME=\\\"${ENDPOINT_NAME}\\\" PSK_IDENTITY=\\\"${PSK_IDENTITY}\\\" PSK_KEY=\\\"${PSK_KEY}\\\" ) pico_enable_stdio_usb(time_object 1) pico_enable_stdio_uart(time_object 0) pico_add_extra_outputs(time_object) At the end of the file add the mention about subdirectory to the general CMakeLists.txt . Anjay-pico-client/CMakeLists.txt add_subdirectory(time_object) Now the client is ready to be built and connected to LwM2M Server, allowing it to read the Time object.","title":"Register the Object in Anjay"},{"location":"academy/exercise3a/#support-transactional-writes","text":"Consider the following scenario: the LwM2M Server tries to write to two or more Resources simultaneously. The write-on Application Type will probably succeed, but we are sure that writing at the Current Time will fail as we didn\u2019t implement this Write operation. Without supporting transactions, the entire Write operation will fail. By default, transaction handlers are set to anjay_dm_transaction_NOOP and do nothing. To properly support Writes on the O two handlers: transaction_begin which makes a backup of the Application Type value, and transaction_rollback which reverts the Application Type to its initial value (before the Write operation is performed) for which we need the time_instance_t::application_type_backup array. Go back to the time_object.c file and update the file using the following code block: time_object.c static int transaction_begin(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr) { (void) anjay; time_object_t *obj = get_obj(obj_ptr); time_instance_t *element; AVS_LIST_FOREACH(element, obj->instances) { strcpy(element->application_type_backup, element->application_type); } return 0; } static int transaction_rollback(anjay_t *anjay, const anjay_dm_object_def_t *const *obj_ptr) { (void) anjay; time_object_t *obj = get_obj(obj_ptr); time_instance_t *element; AVS_LIST_FOREACH(element, obj->instances) { strcpy(element->application_type, element->application_type_backup); } return 0; } static const anjay_dm_object_def_t OBJ_DEF = { .oid = 3333, .handlers = { .list_instances = list_instances, .instance_create = instance_create, .instance_remove = instance_remove, .instance_reset = instance_reset, .list_resources = list_resources, .resource_read = resource_read, .resource_write = resource_write, .transaction_begin = transaction_begin, .transaction_validate = anjay_dm_transaction_NOOP, .transaction_commit = anjay_dm_transaction_NOOP, .transaction_rollback = transaction_rollback } };","title":"Support transactional writes"},{"location":"academy/exercise3a/#recompile-the-application-and-flash-the-board","text":"To recompile the application, go to the Anjay-pico-client/build directory. If you\u2019re using Linux or Mac , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. If you\u2019re using Windows , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. -G \"MinGW Makefiles\" Run the following command in the build directory cmake --build . -j Program your board using the bootloader. Press and hold the BOOTSEL button while connecting the device through a USB cable - it should be recognized as a Mass Storage device. In the build/time_object directory, you will find the .uf2 file which has our added changes. Copy the time_object.uf2 file to the Mass Storage device directory, and wait until the process finishes - copying the firmware image may take a while.","title":"Recompile the application and flash the board"},{"location":"academy/exercise3a/#check-the-logs","text":"With the board still connected to your PC, open a serial communication program. This will help you to check if everything is working correctly. If all went well and logs show registration successfully updated , you can go to Coiote IoT Device Management platform where the Registration status should show Registered . Go to the Data Model and check if you can see the Time Object in the Defined objects section. Note The Object allows LwM2M Clients to report the current time in seconds since January 1, 1970, UTC. After refreshing the page you can see that the value changed. Good job! \ud83d\udc4f\ud83d\udc4f Now you are ready to create more difficult Objects. For this, go to the next exercise. Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Check the logs"},{"location":"academy/exercise3b/","text":"Exercise 3B: Implement the Temperature Object # Among many Objects defined in the OMA LwM2M Object and Resource Registry , Temperature is one of the most frequently used. We will implement the Temperature Object ( /3303 ) in this exercise using the LM35 temperature sensor . Anjay provides an easy-to-use API for implementing new sensor Objects as you will experience in this tutorial. Note In this exercise, we\u2019re presenting an alternative way for implementing Objects which is different from what we used in exercise 3A . The implementation in this exercise requires more manual work, but provides an easier way to implement Objects which contain many Resources. Prerequisites # A Raspberry Pi Pico W board with a USB cable A LM35 temperature sensor Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account. Completed exercise 2B from module 2 Tip Need help? Head over to the lwm2m-academy channel on Discord to get in touch with our experts. Implement the Temperature Object # In these steps, we are going to generate the temperature sensor files required to: Install the IPSO Temperature Object /3303 Make the Object register to the LwM2M Server at boot Make the device responsive to server read commands Generate the lm35.c file # Let\u2019s get started by going to the Anjay-pico-client directory and creating a new directory called temperature_object_lm35 .In this directory, we are creating the files: lm35.c and its header file lm35.h temperature_sensor.c and its header file temperature_sensor.h main.c CMakeLists.txt Important Copy and paste the main.c and CMakeLists.txt files from the Anjay-pico-client/secure_communication directory to the Anjay-pico-client/temperature_object_lm35 directory. In the lm35.c file we need two functions: The lm35_init() for the initialization of the ADC (Analog to Digital Converter) and the ADC GPIO pin. The temperature_get_data() for computing the temperature value from the sensor. This function will be called from the temperature_sensor.c file. lm35.c #include <hardware/adc.h> #include <hardware/gpio.h> #include <pico/stdlib.h> #include \"lm35.h\" #if (LM35_GPIO_PIN < 26) || (LM35_GPIO_PIN > 28) # error \"Invalid ADC GPIO pin selected for LM35 sensor\" #endif int lm35_init(void) { adc_init(); adc_gpio_init(LM35_GPIO_PIN); return 0; } int temperature_get_data(double *sensor_data) { adc_select_input(LM35_ADC_CHANNEL); uint adc_val = adc_read(); // read ADC value (0-4095) double milli_volts = (double) adc_val * (3300. / 4096.); // 3.3 V which is 3300 mV // divide by 4096 because of the size of ADC 12 bits (2^12 = 4096) *sensor_data = milli_volts / 10.; // product requirements return 0; } Generate the temperature_sensor.c file # To generate a layout of the Object\u2019s implementation, we need a few functions to be added to the temperature_sensor.c file: temperature_sensor_install() , temperature_sensor_update() , temperature_sensor_release() and temperature_sensor_get_value() . The most important function is responsible for getting the temperature value from the sensor. For this, we create temperature_sensor_get_value() function where we call the temperature_get_data() function (this function was created in lm35.c file). temperature_sensor.c static int temperature_sensor_get_value(anjay_iid_t iid, void *_ctx, double *value) { (void) iid; (void) _ctx; assert(value); return temperature_get_data(value); } In the temperature_sensor_install() function, we describe the initialization of the LM35 sensor, the installation of the ipso_basic_sensor parameters using sensor-friendly Anjay API, and the creation of the Instance parameters. To install an Anjay IPSO Object we can use anjay_ipso_basic_sensor_install . For Instance parameters we need to describe the proper temperature unit which is degrees Celsius (as defined in SenML RFC ), and our sensor measures temperatures which are between 0 and 100 degrees Celsius. Knowing this we can prepare an Instance and pass it to the anjay_ipso_basic_sensor_instance_add() function. Let\u2019s look at the temperature_sensor_install() function implementation: temperature_sensor.c void temperature_sensor_install(anjay_t *anjay) { if (lm35_init()) { avs_log(ipso_object, WARNING, \"Driver for LM35 could not be initialized!\"); return; } if (anjay_ipso_basic_sensor_install(anjay, 3303, NUM_INSTANCES)) { avs_log(ipso_object, WARNING, \"Object: Temperature sensor could not be installed\"); return; } if (anjay_ipso_basic_sensor_instance_add( anjay, 3303, 0, (anjay_ipso_basic_sensor_impl_t) { .unit = \"Cel\", .min_range_value = 0, .max_range_value = 100, .get_value = temperature_sensor_get_value })) { avs_log(ipso_object, WARNING, \"Instance of Temperature sensor object could not be added\"); } } This function can be divided into a three sections: Section 1 At the beginning we need to initialize our sensor so we can use it and get data from it. In our case, we call lm35_init() function, which will initialize Analog-to-Digital Converter (ADC) on Pico W and ADC GPIO Pin for LM35. if (lm35_init()) { avs_log(ipso_object, WARNING, \"Driver for LM35 could not be initialized!\"); return; } Section 2 Next, we need to create an Object\u2019s Instance with ID /3303 . Because we will use only one sensor, we create only one Instance of this Object. Note Variable NUM_INSTANCES is defined on top of the temperature_sensor.c file and its value shows the number of created Instances. If you want to add another instance you have to call anjay_ipso_basic_sensor_instance_add in the loop. if (anjay_ipso_basic_sensor_install(anjay, 3303, NUM_INSTANCES)) { avs_log(ipso_object, WARNING, \"Object: Temperature sensor could not be installed\"); return; } Section 3 After the sensor and Object initialization, we can add an instance of a sensor. Because it\u2019s the first and only instance, we will define it as /3303/0 . The sensor readings will be calculated to Celsius and the sensor can read value between 0-100 Cel degrees. To acquire sensor value, Anjay will use the temperature_sensor_get_value() function we\u2019ve created before. if (anjay_ipso_basic_sensor_instance_add( anjay, 3303, 0, (anjay_ipso_basic_sensor_impl_t) { .unit = \"Cel\", .min_range_value = 0, .max_range_value = 100, .get_value = temperature_sensor_get_value })) { avs_log(ipso_object, WARNING, \"Instance of Temperature sensor object could not be added\"); } Let's add the functions temperature_sensor_update() , and temperature_sensor_release() . To update the Instance we can use anjay_ipso_basic_sensor_instance_update . temperature_sensor.c void temperature_sensor_update(anjay_t *anjay) { anjay_ipso_basic_sensor_update(anjay, 3303, 0); } void temperature_sensor_release(void) { gpio_deinit(LM35_GPIO_PIN); } Add on top the necessary paths to the libraries used in the temperature_sensor.c and defined constant. In file you should include: temperature_sensor.c #include <assert.h> #include <stdbool.h> #include <anjay/anjay.h> #include <anjay/ipso_objects.h> #include <avsystem/commons/avs_defs.h> #include <avsystem/commons/avs_log.h> #include <hardware/gpio.h> #include \"lm35.h\" #include \"temperature_sensor.h\" #define NUM_INSTANCES 1 Register the Object in Anjay # The last things to do is creating the header files ( temperature_sensor.h and lm35.h ) for the implemented Object, registering the temperature sensor in Anjay by updating the main.c file, and updating CMakeLists.txt file. temperature_sensor.h #pragma once #include <anjay/dm.h> void temperature_sensor_install(anjay_t *anjay); void temperature_sensor_update(anjay_t *anjay); void temperature_sensor_release(void); lm35.h #pragma once #define ADC_PIN_TO_CHANNEL(Pin) ((Pin) - (26)) /* Temperature sensor ADC channel and pin */ #define LM35_GPIO_PIN 26 #define LM35_ADC_CHANNEL ADC_PIN_TO_CHANNEL(LM35_GPIO_PIN) int lm35_init(void); int temperature_get_data(double *sensor_data); main.c void temperature_sensor_update_task(__unused void *params) { const TickType_t delay = 2000 / portTICK_PERIOD_MS; while (true) { temperature_sensor_update(g_anjay); vTaskDelay(delay); } } void anjay_task(__unused void *params) { init_wifi(); anjay_configuration_t config = { .endpoint_name = ENDPOINT_NAME, .in_buffer_size = 2048, .out_buffer_size = 2048, .msg_cache_size = 2048, }; if (!(g_anjay = anjay_new(&config))) { avs_log(main, ERROR, \"Could not create Anjay object\"); exit(1); } if (setup_security_object() || setup_server_object()) { avs_log(main, ERROR, \"Failed to initialize basic objects\"); exit(1); } temperature_sensor_install(g_anjay); xTaskCreateStatic(temperature_sensor_update_task, \"TemperatureUpdateTask\", TEMP_UPDATE_TASK_SIZE, NULL, TEMP_UPDATE_TASK_PRIORITY, temp_update_stack, &temp_update_task_buffer); main_loop(); anjay_delete(g_anjay); temperature_sensor_release(); } Add on top the necessary paths to the libraries used in the main.c file you should include: main.c #include \"temperature_sensor.h\" #ifndef RUN_FREERTOS_ON_CORE # define RUN_FREERTOS_ON_CORE 0 #endif #define ANJAY_TASK_PRIORITY (tskIDLE_PRIORITY + 2UL) #define TEMP_UPDATE_TASK_PRIORITY (tskIDLE_PRIORITY + 1UL) #define ANJAY_TASK_SIZE (4000U) #define TEMP_UPDATE_TASK_SIZE (1000U) static anjay_t *g_anjay; static StackType_t anjay_stack[ANJAY_TASK_SIZE]; static StaticTask_t anjay_task_buffer; static StackType_t temp_update_stack[TEMP_UPDATE_TASK_SIZE]; static StaticTask_t temp_update_task_buffer; CMakeLists.txt cmake_minimum_required(VERSION 3.13) add_executable(temperature_object_lm35 main.c temperature_sensor.c lm35.c ) target_link_libraries(temperature_object_lm35 pico_stdlib hardware_adc anjay-pico FreeRTOS ) target_include_directories(temperature_object_lm35 PRIVATE ${COMMON_DIR}/config ) target_compile_definitions(temperature_object_lm35 PRIVATE WIFI_SSID=\\\"${WIFI_SSID}\\\" WIFI_PASSWORD=\\\"${WIFI_PASSWORD}\\\" ENDPOINT_NAME=\\\"${ENDPOINT_NAME}\\\" PSK_IDENTITY=\\\"${PSK_IDENTITY}\\\" PSK_KEY=\\\"${PSK_KEY}\\\" ) pico_enable_stdio_usb(temperature_object_lm35 1) pico_enable_stdio_uart(temperature_object_lm35 0) pico_add_extra_outputs(temperature_object_lm35) At the end of the file add the mention about subdirectory to the general CMakeLists.txt. Anjay-pico-client/CMakeLists.txt add_subdirectory(temperature_object_lm35) Save the created code and go to the next step to build the .uf2 file. Recompile the application and flash the board # To recompile the application, go to the Anjay-pico-client/build directory. If you\u2019re using Linux or Mac , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. If you\u2019re using Windows , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. -G \"MinGW Makefiles\" Run the following command in the build directory cmake --build . -j Connect the sensor to Raspberry Pi Pico W # Now, let\u2019s connect the LM35 temperature sensor to the Raspberry Pi Pico W. For this, we need 3 cables to connect the power, the ground, and the analog output of the sensor. VCC is the power supply pin of the LM35 temperature sensor which we connect to the VBUS pin of the RPI Pico W. GND is the ground pin of the LM35 temperature sensor and should be connected to the ground pin of the RPI Pico W. OUT is the temperature sensor analog output pin, the output voltage on this pin is directly proportional to the temperature. We connect this pin to the GPIO 26 pin of the RPI Pico W. Once the sensor is connected, it\u2019s time to flash the .uf2 file to the Pico. Program your board using the bootloader. Press and hold the BOOTSEL button while connecting the device through a USB cable, it should be recognized as a Mass Storage device. Go to the Anjay-pico-client/build/temperature_object_lm35 directory, copy the temperature_object_lm35.uf2 file to the Mass Storage device directory and wait until the process finishes - copying the firmware image may take a while. Check the logs # With the board still connected to your PC, open a serial communication program. This will help you to check if everything is working correctly. If all went well and logs show registration successfully updated , you can go to Coiote IoT Device Management platform where the Registration status should show Registered . In the Data model view, you should now see the Temperature Object containing all the created Resources. Well done adding the temperature Object to the Raspberry Pi Pico W \ud83d\udc4f Tip In the temperature Object you can see the Operations column. If you want to get to know what it is and how to work with this, go to the next module: Module 4 - Device Management using LwM2M . Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Exercise 3B - Implement Temperature Object"},{"location":"academy/exercise3b/#exercise-3b-implement-the-temperature-object","text":"Among many Objects defined in the OMA LwM2M Object and Resource Registry , Temperature is one of the most frequently used. We will implement the Temperature Object ( /3303 ) in this exercise using the LM35 temperature sensor . Anjay provides an easy-to-use API for implementing new sensor Objects as you will experience in this tutorial. Note In this exercise, we\u2019re presenting an alternative way for implementing Objects which is different from what we used in exercise 3A . The implementation in this exercise requires more manual work, but provides an easier way to implement Objects which contain many Resources.","title":"Exercise 3B: Implement the Temperature Object"},{"location":"academy/exercise3b/#prerequisites","text":"A Raspberry Pi Pico W board with a USB cable A LM35 temperature sensor Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account. Completed exercise 2B from module 2 Tip Need help? Head over to the lwm2m-academy channel on Discord to get in touch with our experts.","title":"Prerequisites"},{"location":"academy/exercise3b/#implement-the-temperature-object","text":"In these steps, we are going to generate the temperature sensor files required to: Install the IPSO Temperature Object /3303 Make the Object register to the LwM2M Server at boot Make the device responsive to server read commands","title":"Implement the Temperature Object"},{"location":"academy/exercise3b/#generate-the-lm35c-file","text":"Let\u2019s get started by going to the Anjay-pico-client directory and creating a new directory called temperature_object_lm35 .In this directory, we are creating the files: lm35.c and its header file lm35.h temperature_sensor.c and its header file temperature_sensor.h main.c CMakeLists.txt Important Copy and paste the main.c and CMakeLists.txt files from the Anjay-pico-client/secure_communication directory to the Anjay-pico-client/temperature_object_lm35 directory. In the lm35.c file we need two functions: The lm35_init() for the initialization of the ADC (Analog to Digital Converter) and the ADC GPIO pin. The temperature_get_data() for computing the temperature value from the sensor. This function will be called from the temperature_sensor.c file. lm35.c #include <hardware/adc.h> #include <hardware/gpio.h> #include <pico/stdlib.h> #include \"lm35.h\" #if (LM35_GPIO_PIN < 26) || (LM35_GPIO_PIN > 28) # error \"Invalid ADC GPIO pin selected for LM35 sensor\" #endif int lm35_init(void) { adc_init(); adc_gpio_init(LM35_GPIO_PIN); return 0; } int temperature_get_data(double *sensor_data) { adc_select_input(LM35_ADC_CHANNEL); uint adc_val = adc_read(); // read ADC value (0-4095) double milli_volts = (double) adc_val * (3300. / 4096.); // 3.3 V which is 3300 mV // divide by 4096 because of the size of ADC 12 bits (2^12 = 4096) *sensor_data = milli_volts / 10.; // product requirements return 0; }","title":"Generate the lm35.c file"},{"location":"academy/exercise3b/#generate-the-temperature_sensorc-file","text":"To generate a layout of the Object\u2019s implementation, we need a few functions to be added to the temperature_sensor.c file: temperature_sensor_install() , temperature_sensor_update() , temperature_sensor_release() and temperature_sensor_get_value() . The most important function is responsible for getting the temperature value from the sensor. For this, we create temperature_sensor_get_value() function where we call the temperature_get_data() function (this function was created in lm35.c file). temperature_sensor.c static int temperature_sensor_get_value(anjay_iid_t iid, void *_ctx, double *value) { (void) iid; (void) _ctx; assert(value); return temperature_get_data(value); } In the temperature_sensor_install() function, we describe the initialization of the LM35 sensor, the installation of the ipso_basic_sensor parameters using sensor-friendly Anjay API, and the creation of the Instance parameters. To install an Anjay IPSO Object we can use anjay_ipso_basic_sensor_install . For Instance parameters we need to describe the proper temperature unit which is degrees Celsius (as defined in SenML RFC ), and our sensor measures temperatures which are between 0 and 100 degrees Celsius. Knowing this we can prepare an Instance and pass it to the anjay_ipso_basic_sensor_instance_add() function. Let\u2019s look at the temperature_sensor_install() function implementation: temperature_sensor.c void temperature_sensor_install(anjay_t *anjay) { if (lm35_init()) { avs_log(ipso_object, WARNING, \"Driver for LM35 could not be initialized!\"); return; } if (anjay_ipso_basic_sensor_install(anjay, 3303, NUM_INSTANCES)) { avs_log(ipso_object, WARNING, \"Object: Temperature sensor could not be installed\"); return; } if (anjay_ipso_basic_sensor_instance_add( anjay, 3303, 0, (anjay_ipso_basic_sensor_impl_t) { .unit = \"Cel\", .min_range_value = 0, .max_range_value = 100, .get_value = temperature_sensor_get_value })) { avs_log(ipso_object, WARNING, \"Instance of Temperature sensor object could not be added\"); } } This function can be divided into a three sections: Section 1 At the beginning we need to initialize our sensor so we can use it and get data from it. In our case, we call lm35_init() function, which will initialize Analog-to-Digital Converter (ADC) on Pico W and ADC GPIO Pin for LM35. if (lm35_init()) { avs_log(ipso_object, WARNING, \"Driver for LM35 could not be initialized!\"); return; } Section 2 Next, we need to create an Object\u2019s Instance with ID /3303 . Because we will use only one sensor, we create only one Instance of this Object. Note Variable NUM_INSTANCES is defined on top of the temperature_sensor.c file and its value shows the number of created Instances. If you want to add another instance you have to call anjay_ipso_basic_sensor_instance_add in the loop. if (anjay_ipso_basic_sensor_install(anjay, 3303, NUM_INSTANCES)) { avs_log(ipso_object, WARNING, \"Object: Temperature sensor could not be installed\"); return; } Section 3 After the sensor and Object initialization, we can add an instance of a sensor. Because it\u2019s the first and only instance, we will define it as /3303/0 . The sensor readings will be calculated to Celsius and the sensor can read value between 0-100 Cel degrees. To acquire sensor value, Anjay will use the temperature_sensor_get_value() function we\u2019ve created before. if (anjay_ipso_basic_sensor_instance_add( anjay, 3303, 0, (anjay_ipso_basic_sensor_impl_t) { .unit = \"Cel\", .min_range_value = 0, .max_range_value = 100, .get_value = temperature_sensor_get_value })) { avs_log(ipso_object, WARNING, \"Instance of Temperature sensor object could not be added\"); } Let's add the functions temperature_sensor_update() , and temperature_sensor_release() . To update the Instance we can use anjay_ipso_basic_sensor_instance_update . temperature_sensor.c void temperature_sensor_update(anjay_t *anjay) { anjay_ipso_basic_sensor_update(anjay, 3303, 0); } void temperature_sensor_release(void) { gpio_deinit(LM35_GPIO_PIN); } Add on top the necessary paths to the libraries used in the temperature_sensor.c and defined constant. In file you should include: temperature_sensor.c #include <assert.h> #include <stdbool.h> #include <anjay/anjay.h> #include <anjay/ipso_objects.h> #include <avsystem/commons/avs_defs.h> #include <avsystem/commons/avs_log.h> #include <hardware/gpio.h> #include \"lm35.h\" #include \"temperature_sensor.h\" #define NUM_INSTANCES 1","title":"Generate the temperature_sensor.c file"},{"location":"academy/exercise3b/#register-the-object-in-anjay","text":"The last things to do is creating the header files ( temperature_sensor.h and lm35.h ) for the implemented Object, registering the temperature sensor in Anjay by updating the main.c file, and updating CMakeLists.txt file. temperature_sensor.h #pragma once #include <anjay/dm.h> void temperature_sensor_install(anjay_t *anjay); void temperature_sensor_update(anjay_t *anjay); void temperature_sensor_release(void); lm35.h #pragma once #define ADC_PIN_TO_CHANNEL(Pin) ((Pin) - (26)) /* Temperature sensor ADC channel and pin */ #define LM35_GPIO_PIN 26 #define LM35_ADC_CHANNEL ADC_PIN_TO_CHANNEL(LM35_GPIO_PIN) int lm35_init(void); int temperature_get_data(double *sensor_data); main.c void temperature_sensor_update_task(__unused void *params) { const TickType_t delay = 2000 / portTICK_PERIOD_MS; while (true) { temperature_sensor_update(g_anjay); vTaskDelay(delay); } } void anjay_task(__unused void *params) { init_wifi(); anjay_configuration_t config = { .endpoint_name = ENDPOINT_NAME, .in_buffer_size = 2048, .out_buffer_size = 2048, .msg_cache_size = 2048, }; if (!(g_anjay = anjay_new(&config))) { avs_log(main, ERROR, \"Could not create Anjay object\"); exit(1); } if (setup_security_object() || setup_server_object()) { avs_log(main, ERROR, \"Failed to initialize basic objects\"); exit(1); } temperature_sensor_install(g_anjay); xTaskCreateStatic(temperature_sensor_update_task, \"TemperatureUpdateTask\", TEMP_UPDATE_TASK_SIZE, NULL, TEMP_UPDATE_TASK_PRIORITY, temp_update_stack, &temp_update_task_buffer); main_loop(); anjay_delete(g_anjay); temperature_sensor_release(); } Add on top the necessary paths to the libraries used in the main.c file you should include: main.c #include \"temperature_sensor.h\" #ifndef RUN_FREERTOS_ON_CORE # define RUN_FREERTOS_ON_CORE 0 #endif #define ANJAY_TASK_PRIORITY (tskIDLE_PRIORITY + 2UL) #define TEMP_UPDATE_TASK_PRIORITY (tskIDLE_PRIORITY + 1UL) #define ANJAY_TASK_SIZE (4000U) #define TEMP_UPDATE_TASK_SIZE (1000U) static anjay_t *g_anjay; static StackType_t anjay_stack[ANJAY_TASK_SIZE]; static StaticTask_t anjay_task_buffer; static StackType_t temp_update_stack[TEMP_UPDATE_TASK_SIZE]; static StaticTask_t temp_update_task_buffer; CMakeLists.txt cmake_minimum_required(VERSION 3.13) add_executable(temperature_object_lm35 main.c temperature_sensor.c lm35.c ) target_link_libraries(temperature_object_lm35 pico_stdlib hardware_adc anjay-pico FreeRTOS ) target_include_directories(temperature_object_lm35 PRIVATE ${COMMON_DIR}/config ) target_compile_definitions(temperature_object_lm35 PRIVATE WIFI_SSID=\\\"${WIFI_SSID}\\\" WIFI_PASSWORD=\\\"${WIFI_PASSWORD}\\\" ENDPOINT_NAME=\\\"${ENDPOINT_NAME}\\\" PSK_IDENTITY=\\\"${PSK_IDENTITY}\\\" PSK_KEY=\\\"${PSK_KEY}\\\" ) pico_enable_stdio_usb(temperature_object_lm35 1) pico_enable_stdio_uart(temperature_object_lm35 0) pico_add_extra_outputs(temperature_object_lm35) At the end of the file add the mention about subdirectory to the general CMakeLists.txt. Anjay-pico-client/CMakeLists.txt add_subdirectory(temperature_object_lm35) Save the created code and go to the next step to build the .uf2 file.","title":"Register the Object in Anjay"},{"location":"academy/exercise3b/#recompile-the-application-and-flash-the-board","text":"To recompile the application, go to the Anjay-pico-client/build directory. If you\u2019re using Linux or Mac , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. If you\u2019re using Windows , run the following command: cmake -DCMAKE_BUILD_TYPE=Debug -DWIFI_SSID=\"<ssid>\" -DWIFI_PASSWORD=\"<pass>\" -DENDPOINT_NAME=\"<endpoint_name>\" -DPSK_IDENTITY=\"<identity>\" -DPSK_KEY=\"<psk>\" .. -G \"MinGW Makefiles\" Run the following command in the build directory cmake --build . -j","title":"Recompile the application and flash the board"},{"location":"academy/exercise3b/#connect-the-sensor-to-raspberry-pi-pico-w","text":"Now, let\u2019s connect the LM35 temperature sensor to the Raspberry Pi Pico W. For this, we need 3 cables to connect the power, the ground, and the analog output of the sensor. VCC is the power supply pin of the LM35 temperature sensor which we connect to the VBUS pin of the RPI Pico W. GND is the ground pin of the LM35 temperature sensor and should be connected to the ground pin of the RPI Pico W. OUT is the temperature sensor analog output pin, the output voltage on this pin is directly proportional to the temperature. We connect this pin to the GPIO 26 pin of the RPI Pico W. Once the sensor is connected, it\u2019s time to flash the .uf2 file to the Pico. Program your board using the bootloader. Press and hold the BOOTSEL button while connecting the device through a USB cable, it should be recognized as a Mass Storage device. Go to the Anjay-pico-client/build/temperature_object_lm35 directory, copy the temperature_object_lm35.uf2 file to the Mass Storage device directory and wait until the process finishes - copying the firmware image may take a while.","title":"Connect the sensor to Raspberry Pi Pico W"},{"location":"academy/exercise3b/#check-the-logs","text":"With the board still connected to your PC, open a serial communication program. This will help you to check if everything is working correctly. If all went well and logs show registration successfully updated , you can go to Coiote IoT Device Management platform where the Registration status should show Registered . In the Data model view, you should now see the Temperature Object containing all the created Resources. Well done adding the temperature Object to the Raspberry Pi Pico W \ud83d\udc4f Tip In the temperature Object you can see the Operations column. If you want to get to know what it is and how to work with this, go to the next module: Module 4 - Device Management using LwM2M . Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Check the logs"},{"location":"academy/exercise4a/","text":"Exercise 4A: LwM2M Operations # Some Resources represent values that change over time, like sensor readings. The LwM2M Server may request the Client to send notification messages at regular intervals or when values exceed a certain threshold. To do so, the Server can send an Observe Operation to the device, after which the device responds with periodic Notify messages containing the values of the observed Object, Object Instance, or Resource. Next to the Observe Operation, the Server can request the Client to send the value of a specific Resource using the Read Operation. This operations is performed only once. In this exercise, we start sending LwM2M Operations to the Client to monitor the Temperature Object implemented in the previous 3B exercise. Prerequisites # A Raspberry Pi Pico W board with a USB cable A LM35 temperature sensor Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account. Completed exercise 3B from module 3 Notifications support # Let\u2019s get started by connecting our Raspberry Pi Pico W to the computer via a USB cable. Open a serial communication program to watch the device logs and go to the Coiote IoT Device Management platform to check if your device has connected successfully. If so, you are ready to perform your first Observe/Read operations on your LwM2M Device (a.k.a. The LwM2M Client). Go to Coiote IoT DM , select the Data model tab and open the Temperature Object /3303 . Find in the Operations column three different icons representing three different Operations. Read - The Read operation requests the Client to send its latest value. The operation can be invoked on an Object, Object Instance, Resource or Resource Instance. Observe - After invoking the Observe operation, the Server requests the Client to send Notify messages periodically based on configurable time intervals or triggers. Execute - Execute operation invokes an action or operation on a Resource. For example instructing a device to reset, reboot, upgrade its firmware or just turn some LED on. Note There is no Write operation visible here, because the Sensor Objects do not have any \u201cwritable\u201d resources (i.e. resources into which you can write your value). Such operation can be found in e.g. Time Object\u2019s Application Type resource. Read Operation # The Server can perform a LwM2M Read operation on a Resource, Object Instance or a whole Object. To do this, click the circular icon in the Operations column (or use the 3 vertical dots menu in case of Objects and Object Instances). You can see that each time you perform a Read Operation on a specific Resource, its value is updated because the Client has been instructed to send the newest value to the server. Observe Operation # The Server can set observations on a Resource, Object Instance or a whole Object. To set an observation on the Sensor Value Resource /3303/*/5700 , click an eye icon to open the Set observation panel. Change the default \u201cNot more often than once every\u201d and \u201cNot more often than once every\u201d values. Not more often than once every - the minimum time in seconds between two notifications. At least once every - the maximum time in seconds between two notifications. The notification is sent even if the value hasn't changed. To set an observation on an Object or Object Instance, click on the 3 vertical dots menu and select Set observation . You can see that after each time interval which you set in the observation menu, the value is changed as a result of the Client sending an update. Execute Operation # To perform a LwM2M EXECUTE operation on a resource, click the cogwheel icon in the Operations column and select Execute , or Execute with parameters to set additional EXECUTE conditions. Well done! You remotely managed your IoT devices using the LwM2M Operations Read and Observe \ud83d\udc4f Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Exercise 4A - Read & Observe"},{"location":"academy/exercise4a/#exercise-4a-lwm2m-operations","text":"Some Resources represent values that change over time, like sensor readings. The LwM2M Server may request the Client to send notification messages at regular intervals or when values exceed a certain threshold. To do so, the Server can send an Observe Operation to the device, after which the device responds with periodic Notify messages containing the values of the observed Object, Object Instance, or Resource. Next to the Observe Operation, the Server can request the Client to send the value of a specific Resource using the Read Operation. This operations is performed only once. In this exercise, we start sending LwM2M Operations to the Client to monitor the Temperature Object implemented in the previous 3B exercise.","title":"Exercise 4A: LwM2M Operations"},{"location":"academy/exercise4a/#prerequisites","text":"A Raspberry Pi Pico W board with a USB cable A LM35 temperature sensor Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account. Completed exercise 3B from module 3","title":"Prerequisites"},{"location":"academy/exercise4a/#notifications-support","text":"Let\u2019s get started by connecting our Raspberry Pi Pico W to the computer via a USB cable. Open a serial communication program to watch the device logs and go to the Coiote IoT Device Management platform to check if your device has connected successfully. If so, you are ready to perform your first Observe/Read operations on your LwM2M Device (a.k.a. The LwM2M Client). Go to Coiote IoT DM , select the Data model tab and open the Temperature Object /3303 . Find in the Operations column three different icons representing three different Operations. Read - The Read operation requests the Client to send its latest value. The operation can be invoked on an Object, Object Instance, Resource or Resource Instance. Observe - After invoking the Observe operation, the Server requests the Client to send Notify messages periodically based on configurable time intervals or triggers. Execute - Execute operation invokes an action or operation on a Resource. For example instructing a device to reset, reboot, upgrade its firmware or just turn some LED on. Note There is no Write operation visible here, because the Sensor Objects do not have any \u201cwritable\u201d resources (i.e. resources into which you can write your value). Such operation can be found in e.g. Time Object\u2019s Application Type resource.","title":"Notifications support"},{"location":"academy/exercise4a/#read-operation","text":"The Server can perform a LwM2M Read operation on a Resource, Object Instance or a whole Object. To do this, click the circular icon in the Operations column (or use the 3 vertical dots menu in case of Objects and Object Instances). You can see that each time you perform a Read Operation on a specific Resource, its value is updated because the Client has been instructed to send the newest value to the server.","title":"Read Operation"},{"location":"academy/exercise4a/#observe-operation","text":"The Server can set observations on a Resource, Object Instance or a whole Object. To set an observation on the Sensor Value Resource /3303/*/5700 , click an eye icon to open the Set observation panel. Change the default \u201cNot more often than once every\u201d and \u201cNot more often than once every\u201d values. Not more often than once every - the minimum time in seconds between two notifications. At least once every - the maximum time in seconds between two notifications. The notification is sent even if the value hasn't changed. To set an observation on an Object or Object Instance, click on the 3 vertical dots menu and select Set observation . You can see that after each time interval which you set in the observation menu, the value is changed as a result of the Client sending an update.","title":"Observe Operation"},{"location":"academy/exercise4a/#execute-operation","text":"To perform a LwM2M EXECUTE operation on a resource, click the cogwheel icon in the Operations column and select Execute , or Execute with parameters to set additional EXECUTE conditions. Well done! You remotely managed your IoT devices using the LwM2M Operations Read and Observe \ud83d\udc4f Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Execute Operation"},{"location":"academy/exercise4b/","text":"Exercise 4B: LwM2M Send # In this exercise, we implement the LwM2M Send Operation for the Temperature Object and adjust the time interval between two Send Operations. The Send Operation is used by the LwM2M Client to send data without an explicit request from the LwM2M Server (unlike the Read Operation). Prerequisites # A Raspberry Pi Pico W board with a USB cable A LM35 temperature sensor Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account Completed exercise 3B from module 3 Completed exercise 4A from module 4 Send Operation support # Let\u2019s start by going to the Anjay-pico-client/temperature_object_lm35 directory. We will update the completed implementation to have the possibility to support Send Operations. Using a serial communication program we can monitor the LwM2M Client\u2019s behavior after making our changes. For doing so, we need to add code to our files. Temperature_sensor files # Let\u2019s start with the temperature_sensor.c file where we define the Temperature Object\u2019s Resources and add two functions: send_finished_handler() and temperature_object_lm35_send() . Let\u2019s start by defining all available Resources in temperature_sensor.c . temperature_sensor.c #include \"lm35.h\" #include \"temperature_sensor.h\" #define NUM_INSTANCES 1 /** * Min Measured Value: R, Single, Optional * type: float, range: N/A, unit: N/A * The minimum value measured by the sensor since power ON or reset. */ # define RID_MIN_MEASURED_VALUE 5601 /** * Max Measured Value: R, Single, Optional * type: float, range: N/A, unit: N/A * The maximum value measured by the sensor since power ON or reset. */ # define RID_MAX_MEASURED_VALUE 5602 /** * Min Range Value: R, Single, Optional * type: float, range: N/A, unit: N/A * The minimum value that can be measured the sensor. */ # define RID_MIN_RANGE_VALUE 5603 /** * Max Range Value: R, Single, Optional * type: float, range: N/A, unit: N/A * The maximum value that can be measured by the sensor. */ # define RID_MAX_RANGE_VALUE 5604 /** * Reset Min and Max Measured Values: E, Single, Optional * type: N/A, range: N/A, unit: N/A * Reset the Min and Max Measured Values to Current Value. */ # define RID_RESET_MIN_AND_MAX_MEASURED_VALUES 5605 /** * Sensor Value: R, Single, Mandatory * type: float, range: N/A, unit: N/A * Last or Current Measured Value from the Sensor. */ # define RID_SENSOR_VALUE 5700 /** * Sensor Units: R, Single, Optional * type: string, range: N/A, unit: N/A * Measurement Units Definition. */ # define RID_SENSOR_UNITS 5701 Next, at the end of the temperature_sensor.c file, add a handler which is called automatically each time a Send operation finishes, to send logs to the serial communication program about the operation result. temperature_sensor.c static void send_finished_handler(anjay_t *anjay, anjay_ssid_t ssid, const anjay_send_batch_t *batch, int result, void *data) { (void) anjay; (void) ssid; (void) batch; (void) data; if (result != ANJAY_SEND_SUCCESS) { avs_log(temperature_sensor, ERROR, \"Send failed, result: %d\", result); } else { avs_log(temperature_sensor, INFO, \"Send operation successful\"); } } It\u2019s time to create a function with the Send Operation itself. Data messages are created using anjay_send_batch_builder which builds the payload to be sent to the LwM2M Server. The payload can consist of multiple values from different resources. Calling the temperature_object_lm35_send() function does not send a batch immediately, but schedules a task to be run on the next iteration of the Anjay\u2019s event loop. temperature_sensor.c void temperature_object_lm35_send(anjay_t *anjay) { if (!anjay) { return; } const anjay_ssid_t server_ssid = 1; // Allocate new batch builder. anjay_send_batch_builder_t *builder = anjay_send_batch_builder_new(); if (!builder) { avs_log(temperature_sensor, ERROR, \"Failed to allocate batch builder\"); return; } int res = 0; for (int it = 0; it < NUM_INSTANCES; it++) { // Add current values of resources from Temperature Object. if (anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_MIN_MEASURED_VALUE) || anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_MAX_MEASURED_VALUE) || anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_MIN_RANGE_VALUE) || anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_MAX_RANGE_VALUE) || anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_SENSOR_VALUE) || anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_SENSOR_UNITS)) { anjay_send_batch_builder_cleanup(&builder); avs_log(temperature_sensor, ERROR, \"Failed to add batch data, result: %d\", res); return; } } // After adding all values, compile our batch for sending. anjay_send_batch_t *batch = anjay_send_batch_builder_compile(&builder); if (!batch) { anjay_send_batch_builder_cleanup(&builder); avs_log(temperature_sensor, ERROR, \"Batch compile failed\"); return; } // Schedule our send to be run on next `anjay_sched_run()` call. res = anjay_send(anjay, server_ssid, batch, send_finished_handler, NULL); if (res) { avs_log(temperature_sensor, ERROR, \"Failed to send, result: %d\", res); } // After scheduling, we can release our batch. anjay_send_batch_release(&batch); } Add on top the necessary paths to the libraries used in the temperature_sensor.c and defined constant. temperature_sensor.c #include <assert.h> #include <stdbool.h> #include <anjay/anjay.h> #include <anjay/ipso_objects.h> #include <anjay/lwm2m_send.h> #include <avsystem/commons/avs_defs.h> #include <avsystem/commons/avs_log.h> #include <avsystem/commons/avs_list.h> #include <hardware/gpio.h> #include \"lm35.h\" #include \"temperature_sensor.h\" #define NUM_INSTANCES 1 Declare the function in the temperature_sensor.h file. temperature_sensor.h #pragma once #include <anjay/dm.h> void temperature_sensor_install(anjay_t *anjay); void temperature_sensor_update(anjay_t *anjay); void temperature_sensor_release(void); void temperature_object_lm35_send(anjay_t *anjay); Update Anjay task # Next up is updating the main.c file. We need to create a temperature_object struct and send_job() function to periodically issue a Send message. Note Optionally update the time interval from 10 seconds to any interval you prefer. main.c #define ANJAY_TASK_SIZE (4000U) #define TEMP_UPDATE_TASK_SIZE (1000U) static anjay_t *g_anjay; static StackType_t anjay_stack[ANJAY_TASK_SIZE]; static StaticTask_t anjay_task_buffer; static StackType_t temp_update_stack[TEMP_UPDATE_TASK_SIZE]; static StaticTask_t temp_update_task_buffer; typedef struct { anjay_t *anjay; } temperature_object_lm35_job_args_t; static void send_job(avs_sched_t *sched, const void *args_ptr) { const temperature_object_lm35_job_args_t *args = (const temperature_object_lm35_job_args_t *) args_ptr; temperature_object_lm35_send(args->anjay); // Schedule run of the same function after 10 seconds AVS_SCHED_DELAYED(sched, NULL, avs_time_duration_from_scalar(10, AVS_TIME_S), send_job, args, sizeof(*args)); } Now let\u2019s call the send_job() function in anjay_task() . main.c void anjay_task(__unused void *params) { init_wifi(); anjay_configuration_t config = { .endpoint_name = ENDPOINT_NAME, .in_buffer_size = 2048, .out_buffer_size = 2048, .msg_cache_size = 2048, }; if (!(g_anjay = anjay_new(&config))) { avs_log(main, ERROR, \"Could not create Anjay object\"); exit(1); } if (setup_security_object() || setup_server_object()) { avs_log(main, ERROR, \"Failed to initialize basic objects\"); exit(1); } temperature_sensor_install(g_anjay); xTaskCreateStatic(temperature_sensor_update_task, \"TemperatureUpdateTask\", TEMP_UPDATE_TASK_SIZE, NULL, TEMP_UPDATE_TASK_PRIORITY, temp_update_stack, &temp_update_task_buffer); send_job(anjay_get_scheduler(g_anjay), &(const temperature_object_lm35_job_args_t) { .anjay = g_anjay, }); main_loop(); anjay_delete(g_anjay); temperature_sensor_release(); } Save the created code, recompile the application and flash the board. Validate the new firmware # After flashing the board, open up your serial communication program and wait for the event \u201cSend Operation successful\u201d . This event shows that the Client performs regular Send Operations containing Temperature data. INFO [temperature_sensor][/temperature_object_lm35_send/temperature_sensor.c:135]: Send successful Now, open Coiote IoT Device Management platform and validate if the Resources are updated after each configured time interval. Well done! You\u2019ve added support for Send Operations in your firmware \ud83d\udc4f Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Exercise 4B - LwM2M Send"},{"location":"academy/exercise4b/#exercise-4b-lwm2m-send","text":"In this exercise, we implement the LwM2M Send Operation for the Temperature Object and adjust the time interval between two Send Operations. The Send Operation is used by the LwM2M Client to send data without an explicit request from the LwM2M Server (unlike the Read Operation).","title":"Exercise 4B: LwM2M Send"},{"location":"academy/exercise4b/#prerequisites","text":"A Raspberry Pi Pico W board with a USB cable A LM35 temperature sensor Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account Completed exercise 3B from module 3 Completed exercise 4A from module 4","title":"Prerequisites"},{"location":"academy/exercise4b/#send-operation-support","text":"Let\u2019s start by going to the Anjay-pico-client/temperature_object_lm35 directory. We will update the completed implementation to have the possibility to support Send Operations. Using a serial communication program we can monitor the LwM2M Client\u2019s behavior after making our changes. For doing so, we need to add code to our files.","title":"Send Operation support"},{"location":"academy/exercise4b/#temperature_sensor-files","text":"Let\u2019s start with the temperature_sensor.c file where we define the Temperature Object\u2019s Resources and add two functions: send_finished_handler() and temperature_object_lm35_send() . Let\u2019s start by defining all available Resources in temperature_sensor.c . temperature_sensor.c #include \"lm35.h\" #include \"temperature_sensor.h\" #define NUM_INSTANCES 1 /** * Min Measured Value: R, Single, Optional * type: float, range: N/A, unit: N/A * The minimum value measured by the sensor since power ON or reset. */ # define RID_MIN_MEASURED_VALUE 5601 /** * Max Measured Value: R, Single, Optional * type: float, range: N/A, unit: N/A * The maximum value measured by the sensor since power ON or reset. */ # define RID_MAX_MEASURED_VALUE 5602 /** * Min Range Value: R, Single, Optional * type: float, range: N/A, unit: N/A * The minimum value that can be measured the sensor. */ # define RID_MIN_RANGE_VALUE 5603 /** * Max Range Value: R, Single, Optional * type: float, range: N/A, unit: N/A * The maximum value that can be measured by the sensor. */ # define RID_MAX_RANGE_VALUE 5604 /** * Reset Min and Max Measured Values: E, Single, Optional * type: N/A, range: N/A, unit: N/A * Reset the Min and Max Measured Values to Current Value. */ # define RID_RESET_MIN_AND_MAX_MEASURED_VALUES 5605 /** * Sensor Value: R, Single, Mandatory * type: float, range: N/A, unit: N/A * Last or Current Measured Value from the Sensor. */ # define RID_SENSOR_VALUE 5700 /** * Sensor Units: R, Single, Optional * type: string, range: N/A, unit: N/A * Measurement Units Definition. */ # define RID_SENSOR_UNITS 5701 Next, at the end of the temperature_sensor.c file, add a handler which is called automatically each time a Send operation finishes, to send logs to the serial communication program about the operation result. temperature_sensor.c static void send_finished_handler(anjay_t *anjay, anjay_ssid_t ssid, const anjay_send_batch_t *batch, int result, void *data) { (void) anjay; (void) ssid; (void) batch; (void) data; if (result != ANJAY_SEND_SUCCESS) { avs_log(temperature_sensor, ERROR, \"Send failed, result: %d\", result); } else { avs_log(temperature_sensor, INFO, \"Send operation successful\"); } } It\u2019s time to create a function with the Send Operation itself. Data messages are created using anjay_send_batch_builder which builds the payload to be sent to the LwM2M Server. The payload can consist of multiple values from different resources. Calling the temperature_object_lm35_send() function does not send a batch immediately, but schedules a task to be run on the next iteration of the Anjay\u2019s event loop. temperature_sensor.c void temperature_object_lm35_send(anjay_t *anjay) { if (!anjay) { return; } const anjay_ssid_t server_ssid = 1; // Allocate new batch builder. anjay_send_batch_builder_t *builder = anjay_send_batch_builder_new(); if (!builder) { avs_log(temperature_sensor, ERROR, \"Failed to allocate batch builder\"); return; } int res = 0; for (int it = 0; it < NUM_INSTANCES; it++) { // Add current values of resources from Temperature Object. if (anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_MIN_MEASURED_VALUE) || anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_MAX_MEASURED_VALUE) || anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_MIN_RANGE_VALUE) || anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_MAX_RANGE_VALUE) || anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_SENSOR_VALUE) || anjay_send_batch_data_add_current(builder, anjay, 3303, it, RID_SENSOR_UNITS)) { anjay_send_batch_builder_cleanup(&builder); avs_log(temperature_sensor, ERROR, \"Failed to add batch data, result: %d\", res); return; } } // After adding all values, compile our batch for sending. anjay_send_batch_t *batch = anjay_send_batch_builder_compile(&builder); if (!batch) { anjay_send_batch_builder_cleanup(&builder); avs_log(temperature_sensor, ERROR, \"Batch compile failed\"); return; } // Schedule our send to be run on next `anjay_sched_run()` call. res = anjay_send(anjay, server_ssid, batch, send_finished_handler, NULL); if (res) { avs_log(temperature_sensor, ERROR, \"Failed to send, result: %d\", res); } // After scheduling, we can release our batch. anjay_send_batch_release(&batch); } Add on top the necessary paths to the libraries used in the temperature_sensor.c and defined constant. temperature_sensor.c #include <assert.h> #include <stdbool.h> #include <anjay/anjay.h> #include <anjay/ipso_objects.h> #include <anjay/lwm2m_send.h> #include <avsystem/commons/avs_defs.h> #include <avsystem/commons/avs_log.h> #include <avsystem/commons/avs_list.h> #include <hardware/gpio.h> #include \"lm35.h\" #include \"temperature_sensor.h\" #define NUM_INSTANCES 1 Declare the function in the temperature_sensor.h file. temperature_sensor.h #pragma once #include <anjay/dm.h> void temperature_sensor_install(anjay_t *anjay); void temperature_sensor_update(anjay_t *anjay); void temperature_sensor_release(void); void temperature_object_lm35_send(anjay_t *anjay);","title":"Temperature_sensor files"},{"location":"academy/exercise4b/#update-anjay-task","text":"Next up is updating the main.c file. We need to create a temperature_object struct and send_job() function to periodically issue a Send message. Note Optionally update the time interval from 10 seconds to any interval you prefer. main.c #define ANJAY_TASK_SIZE (4000U) #define TEMP_UPDATE_TASK_SIZE (1000U) static anjay_t *g_anjay; static StackType_t anjay_stack[ANJAY_TASK_SIZE]; static StaticTask_t anjay_task_buffer; static StackType_t temp_update_stack[TEMP_UPDATE_TASK_SIZE]; static StaticTask_t temp_update_task_buffer; typedef struct { anjay_t *anjay; } temperature_object_lm35_job_args_t; static void send_job(avs_sched_t *sched, const void *args_ptr) { const temperature_object_lm35_job_args_t *args = (const temperature_object_lm35_job_args_t *) args_ptr; temperature_object_lm35_send(args->anjay); // Schedule run of the same function after 10 seconds AVS_SCHED_DELAYED(sched, NULL, avs_time_duration_from_scalar(10, AVS_TIME_S), send_job, args, sizeof(*args)); } Now let\u2019s call the send_job() function in anjay_task() . main.c void anjay_task(__unused void *params) { init_wifi(); anjay_configuration_t config = { .endpoint_name = ENDPOINT_NAME, .in_buffer_size = 2048, .out_buffer_size = 2048, .msg_cache_size = 2048, }; if (!(g_anjay = anjay_new(&config))) { avs_log(main, ERROR, \"Could not create Anjay object\"); exit(1); } if (setup_security_object() || setup_server_object()) { avs_log(main, ERROR, \"Failed to initialize basic objects\"); exit(1); } temperature_sensor_install(g_anjay); xTaskCreateStatic(temperature_sensor_update_task, \"TemperatureUpdateTask\", TEMP_UPDATE_TASK_SIZE, NULL, TEMP_UPDATE_TASK_PRIORITY, temp_update_stack, &temp_update_task_buffer); send_job(anjay_get_scheduler(g_anjay), &(const temperature_object_lm35_job_args_t) { .anjay = g_anjay, }); main_loop(); anjay_delete(g_anjay); temperature_sensor_release(); } Save the created code, recompile the application and flash the board.","title":"Update Anjay task"},{"location":"academy/exercise4b/#validate-the-new-firmware","text":"After flashing the board, open up your serial communication program and wait for the event \u201cSend Operation successful\u201d . This event shows that the Client performs regular Send Operations containing Temperature data. INFO [temperature_sensor][/temperature_object_lm35_send/temperature_sensor.c:135]: Send successful Now, open Coiote IoT Device Management platform and validate if the Resources are updated after each configured time interval. Well done! You\u2019ve added support for Send Operations in your firmware \ud83d\udc4f Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Validate the new firmware"},{"location":"academy/exercise5/","text":"Exercise 5: Implement Firmware Update # In this exercise, we implement Object 5 - Firmware Update. It utilizes the pico_fota_bootloader to swap the flash partitions after downloading the appropriate binary file from Coiote IoT DM. Prerequisites # A Raspberry Pi Pico W board with a USB cable Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account Completed exercise 4A from module 4 Completed exercise 4B from module 4 What is Bootloader and why do I need this here? # A bootloader as a program is responsible for loading and launching the operating system or firmware of a computer or embedded system. It is typically the initial program that runs when a device is powered on or restarted. The bootloader undertakes the essential configuration of internal modules, ensuring that fundamental settings are established for subsequent operations. Implement Firmware Update # Anjay comes with a built-in Firmware Update module, which simplifies FOTA implementation for the user. Let\u2019s dive into the code and discuss its most important fragments. Note This part only describes functions that are in the code in Anjay-pico-client/firmware_update directory. The user doesn\u2019t have to modify the code. In our code, firmware update module installation will be taken by the function declared in firmware_update.h : firmware_update.h #pragma once #include <anjay/anjay.h> int fw_update_install ( anjay_t * anjay ); In the main.c file the installation of the Firmware Update module takes place in the anjay_task() funktion: main.c void anjay_task ( __unused void * params ) { init_wifi (); pfb_firmware_commit (); anjay_configuration_t config = { . endpoint_name = ENDPOINT_NAME , . in_buffer_size = 2048 , . out_buffer_size = 2048 , . msg_cache_size = 2048 , }; if ( ! ( g_anjay = anjay_new ( & config ))) { avs_log ( main , ERROR , \"Could not create Anjay object\" ); exit ( 1 ); } if ( setup_security_object () || setup_server_object ()) { avs_log ( main , ERROR , \"Failed to initialize basic objects\" ); exit ( 1 ); } if ( fw_update_install ( g_anjay )) { avs_log ( main , ERROR , \"Failed to initialize FOTA object\" ); exit ( 1 ); } main_loop (); anjay_delete ( g_anjay ); } The Firmware Update module consists of user-implemented callbacks of various sorts implemented in the firmware_update.c file: stream_open is called whenever a new firmware download is started by the server. Its main responsibility is to prepare client for receiving firmware chunks - e.g. by opening a file or getting flash storage ready, etc. firmware_update.c static int fw_stream_open ( void * user_ptr , const char * package_uri , const struct anjay_etag * package_etag ) { ( void ) user_ptr ; ( void ) package_uri ; ( void ) package_etag ; pfb_initialize_download_slot (); flash_aligned_writer_new ( writer_buf , AVS_ARRAY_SIZE ( writer_buf ), pfb_write_to_flash_aligned_256_bytes , & writer ); downloaded_bytes = 0 ; update_initialized = true ; avs_log ( fw_update , INFO , \"Init successful\" ); return 0 ; } stream_write is called whenever there is a next firmware chunk received, ready to be stored. Its responsibility is to append the chunk to the storage. firmware_update.c static int fw_stream_write ( void * user_ptr , const void * data , size_t length ) { ( void ) user_ptr ; assert ( update_initialized ); int res = flash_aligned_writer_write ( & writer , data , length ); if ( res ) { return res ; } downloaded_bytes += length ; avs_log ( fw_update , INFO , \"Downloaded %zu bytes.\" , downloaded_bytes ); return 0 ; } stream_finish is called whenever the writing process is finished and the stored data can now be thought of as a complete firmware image. It may be a good moment here to verify if the entire firmware image is valid. firmware_update.c static int fw_stream_finish ( void * user_ptr ) { ( void ) user_ptr ; assert ( update_initialized ); update_initialized = false ; int res = flash_aligned_writer_flush ( & writer ); if ( res ) { avs_log ( fw_update , ERROR , \"Failed to finish download: flash aligned writer flush failed, \" \"result: %d\" , res ); return -1 ; } if ( pfb_firmware_sha256_check ( downloaded_bytes )) { avs_log ( fw_update , ERROR , \"SHA256 check failed\" ); return -1 ; } return 0 ; } reset is called whenever there is an error during firmware download, or if the Server decides to not pursue firmware update with downloaded firmware (e.g. because it was notified that firmware verification failed). firmware_update.c static void fw_reset ( void * user_ptr ) { ( void ) user_ptr ; update_initialized = false ; } static void fw_update_reboot ( avs_sched_t * sched , const void * data ) { ( void ) sched ; ( void ) data ; avs_log ( fw_update , INFO , \"Rebooting.....\" ); pfb_perform_update (); } perform_upgrade is called whenever the download is finished, the firmware is successfully verified on the Client and the Server decides to upgrade the device. firmware_update.c static int fw_perform_upgrade ( void * anjay ) { pfb_mark_download_slot_as_valid (); avs_log ( fw_update , INFO , \"The firmware will be updated at the next device reset\" ); return AVS_SCHED_DELAYED ( anjay_get_scheduler ( anjay ), NULL , avs_time_duration_from_scalar ( 1 , AVS_TIME_S ), fw_update_reboot , NULL , 0 ); } To install the module, we are going to use the fw_update_install() function which is called in the main.c file: firmware_update.c static const anjay_fw_update_handlers_t handlers = { . stream_open = fw_stream_open , . stream_write = fw_stream_write , . stream_finish = fw_stream_finish , . reset = fw_reset , . perform_upgrade = fw_perform_upgrade }; int fw_update_install ( anjay_t * anjay ) { anjay_fw_update_initial_state_t state = { 0 }; if ( pfb_is_after_firmware_update ()) { state . result = ANJAY_FW_UPDATE_INITIAL_SUCCESS ; avs_log ( fw_update , INFO , \"Running on a new firmware\" ); } else if ( pfb_is_after_rollback ()) { state . result = ANJAY_FW_UPDATE_INITIAL_NEUTRAL ; avs_log ( fw_update , WARNING , \"Rollback performed\" ); } return anjay_fw_update_install ( anjay , & handlers , anjay , & state ); } Flash alignment # Flash APIs require that the length of data to write will be a multiple of 256 bytes, so we need to enforce that by additional buffering. For this in the firmware_update directory there are two more files: flash_aligned_writer.c flash_aligned_writer.c #include <assert.h> #include <stddef.h> #include <stdint.h> #include <avsystem/commons/avs_utils.h> #include \"flash_aligned_writer.h\" void flash_aligned_writer_new ( uint8_t * batch_buf , size_t batch_buf_max_len_bytes , flash_aligned_writer_cb_t * writer_cb , flash_aligned_writer_t * out_writer ) { assert ( batch_buf ); assert ( batch_buf_max_len_bytes ); assert ( writer_cb ); out_writer -> batch_buf = batch_buf ; out_writer -> batch_buf_max_len_bytes = batch_buf_max_len_bytes ; out_writer -> batch_buf_len_bytes = 0 ; out_writer -> write_offset_bytes = 0 ; out_writer -> writer_cb = writer_cb ; } int flash_aligned_writer_write ( flash_aligned_writer_t * writer , const uint8_t * data , size_t length_bytes ) { while ( length_bytes > 0 ) { const size_t bytes_to_copy = AVS_MIN ( writer -> batch_buf_max_len_bytes - writer -> batch_buf_len_bytes , length_bytes ); memcpy ( writer -> batch_buf + writer -> batch_buf_len_bytes , data , bytes_to_copy ); data += bytes_to_copy ; length_bytes -= bytes_to_copy ; writer -> batch_buf_len_bytes += bytes_to_copy ; if ( writer -> batch_buf_len_bytes == writer -> batch_buf_max_len_bytes ) { int res = writer -> writer_cb ( writer -> batch_buf , writer -> write_offset_bytes , writer -> batch_buf_len_bytes ); if ( res ) { return res ; } writer -> write_offset_bytes += writer -> batch_buf_len_bytes ; writer -> batch_buf_len_bytes = 0 ; } } return 0 ; } int flash_aligned_writer_flush ( flash_aligned_writer_t * writer ) { if ( writer -> batch_buf_len_bytes == 0 ) { return 0 ; } int res = writer -> writer_cb ( writer -> batch_buf , writer -> write_offset_bytes , writer -> batch_buf_len_bytes ); if ( res ) { return res ; } writer -> write_offset_bytes += writer -> batch_buf_len_bytes ; writer -> batch_buf_len_bytes = 0 ; return 0 ; } flash_aligned_writer.h flash_aligned_writer.h #pragma once #include <stddef.h> #include <stdint.h> typedef int flash_aligned_writer_cb_t ( uint8_t * src , size_t offset_bytes , size_t len_bytes ); typedef struct { uint8_t * batch_buf ; size_t batch_buf_max_len_bytes ; size_t batch_buf_len_bytes ; size_t write_offset_bytes ; flash_aligned_writer_cb_t * writer_cb ; } flash_aligned_writer_t ; void flash_aligned_writer_new ( uint8_t * batch_buf , size_t batch_buf_max_len_bytes , flash_aligned_writer_cb_t * writer_cb , flash_aligned_writer_t * out_writer ); int flash_aligned_writer_write ( flash_aligned_writer_t * writer , const uint8_t * data , size_t length ); int flash_aligned_writer_flush ( flash_aligned_writer_t * writer ); Recompile the application and flash the board # Your data model doesn't have Firmware Update Object /5 . For updating this set Raspberry Pi Pico W to the BOOTSEL state (by powering it up with the BOOTSEL button pressed) and copy the build/firmware_update/pico_fota_bootloader/pico_fota_bootloader.uf2 file into it. Right now the Raspberry Pi Pico W is flashed with the bootloader but does not have proper application in the application FLASH memory slot yet. Then, set Raspberry Pi Pico W to the BOOTSEL state again and copy the build/firmware_update/firmware_update.uf2 file. The board should reboot and start the firmware_update application. Prepare the Firmware Update in Coiote # In the Coiote IoT Device Management platform, go to Device Inventory . Go to the Data model tab to validate if the Firmware Update Object /5 is present. If so, the Object is supported by the LwM2M Client. Go to the Firmware update tab. Click the Update Firmware button. Select Basic Firmware Update . Upload the firmware image . Note The firmware image firmware_update_fota_image_encrypted.bin file can be found in the build/firmware_update directory. Choose between Pull and Push : Pull method (recommended): The LwM2M Client receives the URI of the file that is to be downloaded and pulls the file from it. Push method : The LwM2M Server pushes the firmware file to the device. Info Pull supports the following transport types : CoAP or CoAPs over UDP CoAP or CoAPs over TCP HTTP or HTTPs Push transmits the firmware over the same transport type as is used for device management, which is CoAPs over UDP by default. Which transport protocol to choose? Downloads using CoAP(s) over UDP tend to be slow due to the limitation of the maximum CoAP Block size of 1024 bytes and the required acknowledgements for each Block transfer. Choosing CoAP(s) over TCP or HTTP(s) usually results in faster download speeds. However, not every device supports these transport protocols. Click Schedule Update to trigger the Firmware Update process. Note After doing so, a Firmware Update process will begin. Check the serial output logs - the INFO [fw_update] [/anjay-pico-client/firmware_update/firmware_update.c]: Downloaded X bytes logs should appear. Download & Upgrade Process # If the Firmware Update is scheduled successfully, the device starts downloading the firmware at the next practical opportunity. The actual firmware update starts once the integrity and authenticity of the firmware image has been validated by the LwM2M Client. Once executed successfully, the status in the Update list panel changes to Success . Note While the device is updating its firmware, it will deregister and reboot using the new firmware. This process may time several minutes. Monitoring the update process # During the update process, the status of the firmware update can be monitored by reviewing the Resources State /5/0/3 and Update Results /5/0/5 . To find the Resources, select the Data model tab and open the Firmware Update Object /5 . If no errors occur, the update process follows this pattern: Downloading state 1 & update result 0 Downloaded state 2 & update result 0 Updating state 3 & update result 0 Updated state 0 & update result 1 Update successful? Does the State /5/0/3 report 0 and the Update Result /5/0/5 report 1 ? Congratulations! You've successfully updated the firmware of your device. \ud83c\udf89","title":"Exercise 5 - Implement Firmware Update"},{"location":"academy/exercise5/#exercise-5-implement-firmware-update","text":"In this exercise, we implement Object 5 - Firmware Update. It utilizes the pico_fota_bootloader to swap the flash partitions after downloading the appropriate binary file from Coiote IoT DM.","title":"Exercise 5: Implement Firmware Update"},{"location":"academy/exercise5/#prerequisites","text":"A Raspberry Pi Pico W board with a USB cable Installed minicom (for Linux), RealTerm , PuTTy (for Windows), or another serial communication program. An active Coiote IoT DM user account Completed exercise 4A from module 4 Completed exercise 4B from module 4","title":"Prerequisites"},{"location":"academy/exercise5/#what-is-bootloader-and-why-do-i-need-this-here","text":"A bootloader as a program is responsible for loading and launching the operating system or firmware of a computer or embedded system. It is typically the initial program that runs when a device is powered on or restarted. The bootloader undertakes the essential configuration of internal modules, ensuring that fundamental settings are established for subsequent operations.","title":"What is Bootloader and why do I need this here?"},{"location":"academy/exercise5/#implement-firmware-update","text":"Anjay comes with a built-in Firmware Update module, which simplifies FOTA implementation for the user. Let\u2019s dive into the code and discuss its most important fragments. Note This part only describes functions that are in the code in Anjay-pico-client/firmware_update directory. The user doesn\u2019t have to modify the code. In our code, firmware update module installation will be taken by the function declared in firmware_update.h : firmware_update.h #pragma once #include <anjay/anjay.h> int fw_update_install ( anjay_t * anjay ); In the main.c file the installation of the Firmware Update module takes place in the anjay_task() funktion: main.c void anjay_task ( __unused void * params ) { init_wifi (); pfb_firmware_commit (); anjay_configuration_t config = { . endpoint_name = ENDPOINT_NAME , . in_buffer_size = 2048 , . out_buffer_size = 2048 , . msg_cache_size = 2048 , }; if ( ! ( g_anjay = anjay_new ( & config ))) { avs_log ( main , ERROR , \"Could not create Anjay object\" ); exit ( 1 ); } if ( setup_security_object () || setup_server_object ()) { avs_log ( main , ERROR , \"Failed to initialize basic objects\" ); exit ( 1 ); } if ( fw_update_install ( g_anjay )) { avs_log ( main , ERROR , \"Failed to initialize FOTA object\" ); exit ( 1 ); } main_loop (); anjay_delete ( g_anjay ); } The Firmware Update module consists of user-implemented callbacks of various sorts implemented in the firmware_update.c file: stream_open is called whenever a new firmware download is started by the server. Its main responsibility is to prepare client for receiving firmware chunks - e.g. by opening a file or getting flash storage ready, etc. firmware_update.c static int fw_stream_open ( void * user_ptr , const char * package_uri , const struct anjay_etag * package_etag ) { ( void ) user_ptr ; ( void ) package_uri ; ( void ) package_etag ; pfb_initialize_download_slot (); flash_aligned_writer_new ( writer_buf , AVS_ARRAY_SIZE ( writer_buf ), pfb_write_to_flash_aligned_256_bytes , & writer ); downloaded_bytes = 0 ; update_initialized = true ; avs_log ( fw_update , INFO , \"Init successful\" ); return 0 ; } stream_write is called whenever there is a next firmware chunk received, ready to be stored. Its responsibility is to append the chunk to the storage. firmware_update.c static int fw_stream_write ( void * user_ptr , const void * data , size_t length ) { ( void ) user_ptr ; assert ( update_initialized ); int res = flash_aligned_writer_write ( & writer , data , length ); if ( res ) { return res ; } downloaded_bytes += length ; avs_log ( fw_update , INFO , \"Downloaded %zu bytes.\" , downloaded_bytes ); return 0 ; } stream_finish is called whenever the writing process is finished and the stored data can now be thought of as a complete firmware image. It may be a good moment here to verify if the entire firmware image is valid. firmware_update.c static int fw_stream_finish ( void * user_ptr ) { ( void ) user_ptr ; assert ( update_initialized ); update_initialized = false ; int res = flash_aligned_writer_flush ( & writer ); if ( res ) { avs_log ( fw_update , ERROR , \"Failed to finish download: flash aligned writer flush failed, \" \"result: %d\" , res ); return -1 ; } if ( pfb_firmware_sha256_check ( downloaded_bytes )) { avs_log ( fw_update , ERROR , \"SHA256 check failed\" ); return -1 ; } return 0 ; } reset is called whenever there is an error during firmware download, or if the Server decides to not pursue firmware update with downloaded firmware (e.g. because it was notified that firmware verification failed). firmware_update.c static void fw_reset ( void * user_ptr ) { ( void ) user_ptr ; update_initialized = false ; } static void fw_update_reboot ( avs_sched_t * sched , const void * data ) { ( void ) sched ; ( void ) data ; avs_log ( fw_update , INFO , \"Rebooting.....\" ); pfb_perform_update (); } perform_upgrade is called whenever the download is finished, the firmware is successfully verified on the Client and the Server decides to upgrade the device. firmware_update.c static int fw_perform_upgrade ( void * anjay ) { pfb_mark_download_slot_as_valid (); avs_log ( fw_update , INFO , \"The firmware will be updated at the next device reset\" ); return AVS_SCHED_DELAYED ( anjay_get_scheduler ( anjay ), NULL , avs_time_duration_from_scalar ( 1 , AVS_TIME_S ), fw_update_reboot , NULL , 0 ); } To install the module, we are going to use the fw_update_install() function which is called in the main.c file: firmware_update.c static const anjay_fw_update_handlers_t handlers = { . stream_open = fw_stream_open , . stream_write = fw_stream_write , . stream_finish = fw_stream_finish , . reset = fw_reset , . perform_upgrade = fw_perform_upgrade }; int fw_update_install ( anjay_t * anjay ) { anjay_fw_update_initial_state_t state = { 0 }; if ( pfb_is_after_firmware_update ()) { state . result = ANJAY_FW_UPDATE_INITIAL_SUCCESS ; avs_log ( fw_update , INFO , \"Running on a new firmware\" ); } else if ( pfb_is_after_rollback ()) { state . result = ANJAY_FW_UPDATE_INITIAL_NEUTRAL ; avs_log ( fw_update , WARNING , \"Rollback performed\" ); } return anjay_fw_update_install ( anjay , & handlers , anjay , & state ); }","title":"Implement Firmware Update"},{"location":"academy/exercise5/#flash-alignment","text":"Flash APIs require that the length of data to write will be a multiple of 256 bytes, so we need to enforce that by additional buffering. For this in the firmware_update directory there are two more files: flash_aligned_writer.c flash_aligned_writer.c #include <assert.h> #include <stddef.h> #include <stdint.h> #include <avsystem/commons/avs_utils.h> #include \"flash_aligned_writer.h\" void flash_aligned_writer_new ( uint8_t * batch_buf , size_t batch_buf_max_len_bytes , flash_aligned_writer_cb_t * writer_cb , flash_aligned_writer_t * out_writer ) { assert ( batch_buf ); assert ( batch_buf_max_len_bytes ); assert ( writer_cb ); out_writer -> batch_buf = batch_buf ; out_writer -> batch_buf_max_len_bytes = batch_buf_max_len_bytes ; out_writer -> batch_buf_len_bytes = 0 ; out_writer -> write_offset_bytes = 0 ; out_writer -> writer_cb = writer_cb ; } int flash_aligned_writer_write ( flash_aligned_writer_t * writer , const uint8_t * data , size_t length_bytes ) { while ( length_bytes > 0 ) { const size_t bytes_to_copy = AVS_MIN ( writer -> batch_buf_max_len_bytes - writer -> batch_buf_len_bytes , length_bytes ); memcpy ( writer -> batch_buf + writer -> batch_buf_len_bytes , data , bytes_to_copy ); data += bytes_to_copy ; length_bytes -= bytes_to_copy ; writer -> batch_buf_len_bytes += bytes_to_copy ; if ( writer -> batch_buf_len_bytes == writer -> batch_buf_max_len_bytes ) { int res = writer -> writer_cb ( writer -> batch_buf , writer -> write_offset_bytes , writer -> batch_buf_len_bytes ); if ( res ) { return res ; } writer -> write_offset_bytes += writer -> batch_buf_len_bytes ; writer -> batch_buf_len_bytes = 0 ; } } return 0 ; } int flash_aligned_writer_flush ( flash_aligned_writer_t * writer ) { if ( writer -> batch_buf_len_bytes == 0 ) { return 0 ; } int res = writer -> writer_cb ( writer -> batch_buf , writer -> write_offset_bytes , writer -> batch_buf_len_bytes ); if ( res ) { return res ; } writer -> write_offset_bytes += writer -> batch_buf_len_bytes ; writer -> batch_buf_len_bytes = 0 ; return 0 ; } flash_aligned_writer.h flash_aligned_writer.h #pragma once #include <stddef.h> #include <stdint.h> typedef int flash_aligned_writer_cb_t ( uint8_t * src , size_t offset_bytes , size_t len_bytes ); typedef struct { uint8_t * batch_buf ; size_t batch_buf_max_len_bytes ; size_t batch_buf_len_bytes ; size_t write_offset_bytes ; flash_aligned_writer_cb_t * writer_cb ; } flash_aligned_writer_t ; void flash_aligned_writer_new ( uint8_t * batch_buf , size_t batch_buf_max_len_bytes , flash_aligned_writer_cb_t * writer_cb , flash_aligned_writer_t * out_writer ); int flash_aligned_writer_write ( flash_aligned_writer_t * writer , const uint8_t * data , size_t length ); int flash_aligned_writer_flush ( flash_aligned_writer_t * writer );","title":"Flash alignment"},{"location":"academy/exercise5/#recompile-the-application-and-flash-the-board","text":"Your data model doesn't have Firmware Update Object /5 . For updating this set Raspberry Pi Pico W to the BOOTSEL state (by powering it up with the BOOTSEL button pressed) and copy the build/firmware_update/pico_fota_bootloader/pico_fota_bootloader.uf2 file into it. Right now the Raspberry Pi Pico W is flashed with the bootloader but does not have proper application in the application FLASH memory slot yet. Then, set Raspberry Pi Pico W to the BOOTSEL state again and copy the build/firmware_update/firmware_update.uf2 file. The board should reboot and start the firmware_update application.","title":"Recompile the application and flash the board"},{"location":"academy/exercise5/#prepare-the-firmware-update-in-coiote","text":"In the Coiote IoT Device Management platform, go to Device Inventory . Go to the Data model tab to validate if the Firmware Update Object /5 is present. If so, the Object is supported by the LwM2M Client. Go to the Firmware update tab. Click the Update Firmware button. Select Basic Firmware Update . Upload the firmware image . Note The firmware image firmware_update_fota_image_encrypted.bin file can be found in the build/firmware_update directory. Choose between Pull and Push : Pull method (recommended): The LwM2M Client receives the URI of the file that is to be downloaded and pulls the file from it. Push method : The LwM2M Server pushes the firmware file to the device. Info Pull supports the following transport types : CoAP or CoAPs over UDP CoAP or CoAPs over TCP HTTP or HTTPs Push transmits the firmware over the same transport type as is used for device management, which is CoAPs over UDP by default. Which transport protocol to choose? Downloads using CoAP(s) over UDP tend to be slow due to the limitation of the maximum CoAP Block size of 1024 bytes and the required acknowledgements for each Block transfer. Choosing CoAP(s) over TCP or HTTP(s) usually results in faster download speeds. However, not every device supports these transport protocols. Click Schedule Update to trigger the Firmware Update process. Note After doing so, a Firmware Update process will begin. Check the serial output logs - the INFO [fw_update] [/anjay-pico-client/firmware_update/firmware_update.c]: Downloaded X bytes logs should appear.","title":"Prepare the Firmware Update in Coiote"},{"location":"academy/exercise5/#download-upgrade-process","text":"If the Firmware Update is scheduled successfully, the device starts downloading the firmware at the next practical opportunity. The actual firmware update starts once the integrity and authenticity of the firmware image has been validated by the LwM2M Client. Once executed successfully, the status in the Update list panel changes to Success . Note While the device is updating its firmware, it will deregister and reboot using the new firmware. This process may time several minutes.","title":"Download &amp; Upgrade Process"},{"location":"academy/exercise5/#monitoring-the-update-process","text":"During the update process, the status of the firmware update can be monitored by reviewing the Resources State /5/0/3 and Update Results /5/0/5 . To find the Resources, select the Data model tab and open the Firmware Update Object /5 . If no errors occur, the update process follows this pattern: Downloading state 1 & update result 0 Downloaded state 2 & update result 0 Updating state 3 & update result 0 Updated state 0 & update result 1 Update successful? Does the State /5/0/3 report 0 and the Update Result /5/0/5 report 1 ? Congratulations! You've successfully updated the firmware of your device. \ud83c\udf89","title":"Monitoring the update process"},{"location":"academy/gradproject/","text":"Graduation Project # Congratulations on your progress in the LwM2M Academy! As you approach graduation, one final task awaits: bringing your IoT idea to life using the LwM2M standard. Your graduation project involves building an application that utilizes the LwM2M standard and the Coiote IoT Device Management platform. Whether you choose the Raspberry Pi Pico W or any other IoT device, your task is to effectively gather sensor data and establish a cloud connection. Once your project is complete, please publish the final result on our AVSystem Discord or share it publicly via platforms such as Hackster, Instructables, or your own social media. Best of luck with this final step. We can't wait to see how you apply your acquired knowledge to create a compelling end-to-end application. Useful Resources # Getting Started guides containing detailed documentation on using different IoT development kits AVSystem Discord for support and for submitting your graduation project Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Graduation Project"},{"location":"academy/gradproject/#graduation-project","text":"Congratulations on your progress in the LwM2M Academy! As you approach graduation, one final task awaits: bringing your IoT idea to life using the LwM2M standard. Your graduation project involves building an application that utilizes the LwM2M standard and the Coiote IoT Device Management platform. Whether you choose the Raspberry Pi Pico W or any other IoT device, your task is to effectively gather sensor data and establish a cloud connection. Once your project is complete, please publish the final result on our AVSystem Discord or share it publicly via platforms such as Hackster, Instructables, or your own social media. Best of luck with this final step. We can't wait to see how you apply your acquired knowledge to create a compelling end-to-end application.","title":"Graduation Project"},{"location":"academy/gradproject/#useful-resources","text":"Getting Started guides containing detailed documentation on using different IoT development kits AVSystem Discord for support and for submitting your graduation project Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Useful Resources"},{"location":"academy/module1/","text":"Module 1: Introduction to LwM2M # Today\u2019s challenges Today\u2019s challenges when developing IoT solutions # One of today\u2019s biggest challenges in IoT is interoperability. There are a plethora of devices, all of which solve specific problems with the help of sensors, actuators, communication modules, and local processing. Due to a lack of standards, devices use different communication protocols, data formats, and device management mechanisms. As a result, unique processes need to be implemented in order to make sense of the devices\u2019 data and manage them remotely over time. Once the device data reaches the cloud, it becomes challenging to interpret as each device uses a unique data format. Device management is usually embedded into the application firmware, and configurations can be updated using specific commands sent from the server, making it complex to implement when working with various devices. Finally, firmware updates are very challenging to implement. If FOTA (Firmware Over The Air) is implemented at all, it is custom built for each project. Managing a mixed fleet of devices and integrating the data into one platform is hard to realize. Lightweight M2M # To answer the industry\u2019s need for an easy, fast, and power-efficient device management mechanism, the OMA SpecWorks created a communication standard for IoT devices called Lightweight Machine-to-Machine (LwM2M) . The LwM2M protocol, released in 2017, was designed to simplify messaging and device management for resource-constrained IoT devices. The LwM2M optimizes bandwidth efficient consumption by using space-efficient binary payloads and introduces support for wireless standards such as NB-IoT, LTE-M, Bluetooth, WiFi, and SMS transport. It includes a uniform data format for easy interpretation of data, standardized device management processes, and support for FOTA (Firmware Over The Air). When IoT devices adhere to the LwM2M standard, cloud applications can easily interpret data, and devices independent of the manufacturer, hardware, or software can be managed the same way. LwM2M architecture # The architecture of a LwM2M application contains 3 components: The LwM2M Client runs on the end device and ensures a secure connection with the LwM2M Server and optionally Bootstrap Server. All data sent from the clients is formatted as dictated by the LwM2M standard. The LwM2M Server manages devices including their configurations and firmware in the cloud. It also captures and stores all telemetry data sent from the LwM2M Clients. The LwM2M Bootstrap Server is a cloud service to authenticate and provision LwM2M Clients. This is an optional component used to improve the application\u2019s security. LwM2M data format # In order to manage devices and process their data, components of IoT systems must be able to \u201cspeak\u201d the same language. This not only relates to the communication protocol but also to the data structure. The LwM2M standard realizes an interoperable data structure through the use of its LwM2M Object Model . LwM2M Objects represent configurations, functionalities, and sensors of IoT devices. By structuring the Objects in a particular manner, a language is created which both the LwM2M Client and the LwM2M Server can understand. This language is organized in (most situations as) a three-level tree comprising Objects which consist of Object Instances , and Object Instances consist of Resources . Entities on each of those levels are identified with numerical identifiers in the range 0-65534 and defined by the OMA in the LwM2M Registry . The language follows a sequence containing the Object ID, Object Instance ID, and Resource ID. To be more precise, a URI is made up of three unsigned 16-bit integers that are separated by the ' / ' character and look like this: /<object_ID>/<object_instance_ID>/<resource_ID> For example, a GNSS module generates location data containing latitude and longitude values. The URI of the latitude is: /6/0/0 , and the URI of the longitude is: /6/0/1 . 6 \u2192 The ID of the Location Object 0 \u200b\u200b\u2192 Instance 0 of the Location Object 0 \u2192 The ID of the latitude Resource 1 \u2192 The ID of the longitude Resource Objects - Devices contain different building blocks, each of these blocks is represented by an Object and identified by an Object ID . For example, the Firmware Update Object is used to invoke and track the status of the firmware update process. Objects can also describe the connectivity technology (e.g. cellular or WiFi), device information (serial number, manufacturer, firmware version), sensors (temperature, air quality), or peripherals (GPS, LEDs, buzzers). Object Instances - Some Objects are described as \u201csingle-instance\u201d. Such Objects have exactly one Instance with the identifier /0 . Examples are the Device Object which describes the device itself, and the Firmware Update Object which is used to perform firmware upgrades. Other Objects have multiple Instances. Examples of such Objects include the Object that manages connections to LwM2M Servers as multiple LwM2M Servers can be configured. Devices can also use Object Instances when using multiple SIMs with different APN profiles. When devices contain multiple identical sensors, Object Instances are used to distinguish the different sensors. Resources - Object Instances have one or multiple Resources. Resources can be represented as certain data types such as string, integer, Boolean, or float. For example, the \u201cDevice\u201d Object has multiple Resources such as the manufacturer , serial number , and firmware version . The \u201cLocation\u201d Object has the Resources' latitude, longitude , and altitude . Resource Instances - In some cases, Resources have multiple Resource Instances which turns the language into a four-level tree. For example: Device Object /3 includes Resource /6 : Available Power Sources. The different Resource Instances describe the different power sources: 0 : DC power 1 : Internal Battery 2 : External Battery 3 : Fuel Cell 4 : Power over Ethernet 5 : USB 6 : AC (Mains) power 7 : Solar To describe the availability of solar power, the URI becomes: /3/0/6/7 Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Theory Module 1"},{"location":"academy/module1/#module-1-introduction-to-lwm2m","text":"Today\u2019s challenges","title":"Module 1: Introduction to LwM2M"},{"location":"academy/module1/#todays-challenges-when-developing-iot-solutions","text":"One of today\u2019s biggest challenges in IoT is interoperability. There are a plethora of devices, all of which solve specific problems with the help of sensors, actuators, communication modules, and local processing. Due to a lack of standards, devices use different communication protocols, data formats, and device management mechanisms. As a result, unique processes need to be implemented in order to make sense of the devices\u2019 data and manage them remotely over time. Once the device data reaches the cloud, it becomes challenging to interpret as each device uses a unique data format. Device management is usually embedded into the application firmware, and configurations can be updated using specific commands sent from the server, making it complex to implement when working with various devices. Finally, firmware updates are very challenging to implement. If FOTA (Firmware Over The Air) is implemented at all, it is custom built for each project. Managing a mixed fleet of devices and integrating the data into one platform is hard to realize.","title":"Today\u2019s challenges when developing IoT solutions"},{"location":"academy/module1/#lightweight-m2m","text":"To answer the industry\u2019s need for an easy, fast, and power-efficient device management mechanism, the OMA SpecWorks created a communication standard for IoT devices called Lightweight Machine-to-Machine (LwM2M) . The LwM2M protocol, released in 2017, was designed to simplify messaging and device management for resource-constrained IoT devices. The LwM2M optimizes bandwidth efficient consumption by using space-efficient binary payloads and introduces support for wireless standards such as NB-IoT, LTE-M, Bluetooth, WiFi, and SMS transport. It includes a uniform data format for easy interpretation of data, standardized device management processes, and support for FOTA (Firmware Over The Air). When IoT devices adhere to the LwM2M standard, cloud applications can easily interpret data, and devices independent of the manufacturer, hardware, or software can be managed the same way.","title":"Lightweight M2M"},{"location":"academy/module1/#lwm2m-architecture","text":"The architecture of a LwM2M application contains 3 components: The LwM2M Client runs on the end device and ensures a secure connection with the LwM2M Server and optionally Bootstrap Server. All data sent from the clients is formatted as dictated by the LwM2M standard. The LwM2M Server manages devices including their configurations and firmware in the cloud. It also captures and stores all telemetry data sent from the LwM2M Clients. The LwM2M Bootstrap Server is a cloud service to authenticate and provision LwM2M Clients. This is an optional component used to improve the application\u2019s security.","title":"LwM2M architecture"},{"location":"academy/module1/#lwm2m-data-format","text":"In order to manage devices and process their data, components of IoT systems must be able to \u201cspeak\u201d the same language. This not only relates to the communication protocol but also to the data structure. The LwM2M standard realizes an interoperable data structure through the use of its LwM2M Object Model . LwM2M Objects represent configurations, functionalities, and sensors of IoT devices. By structuring the Objects in a particular manner, a language is created which both the LwM2M Client and the LwM2M Server can understand. This language is organized in (most situations as) a three-level tree comprising Objects which consist of Object Instances , and Object Instances consist of Resources . Entities on each of those levels are identified with numerical identifiers in the range 0-65534 and defined by the OMA in the LwM2M Registry . The language follows a sequence containing the Object ID, Object Instance ID, and Resource ID. To be more precise, a URI is made up of three unsigned 16-bit integers that are separated by the ' / ' character and look like this: /<object_ID>/<object_instance_ID>/<resource_ID> For example, a GNSS module generates location data containing latitude and longitude values. The URI of the latitude is: /6/0/0 , and the URI of the longitude is: /6/0/1 . 6 \u2192 The ID of the Location Object 0 \u200b\u200b\u2192 Instance 0 of the Location Object 0 \u2192 The ID of the latitude Resource 1 \u2192 The ID of the longitude Resource Objects - Devices contain different building blocks, each of these blocks is represented by an Object and identified by an Object ID . For example, the Firmware Update Object is used to invoke and track the status of the firmware update process. Objects can also describe the connectivity technology (e.g. cellular or WiFi), device information (serial number, manufacturer, firmware version), sensors (temperature, air quality), or peripherals (GPS, LEDs, buzzers). Object Instances - Some Objects are described as \u201csingle-instance\u201d. Such Objects have exactly one Instance with the identifier /0 . Examples are the Device Object which describes the device itself, and the Firmware Update Object which is used to perform firmware upgrades. Other Objects have multiple Instances. Examples of such Objects include the Object that manages connections to LwM2M Servers as multiple LwM2M Servers can be configured. Devices can also use Object Instances when using multiple SIMs with different APN profiles. When devices contain multiple identical sensors, Object Instances are used to distinguish the different sensors. Resources - Object Instances have one or multiple Resources. Resources can be represented as certain data types such as string, integer, Boolean, or float. For example, the \u201cDevice\u201d Object has multiple Resources such as the manufacturer , serial number , and firmware version . The \u201cLocation\u201d Object has the Resources' latitude, longitude , and altitude . Resource Instances - In some cases, Resources have multiple Resource Instances which turns the language into a four-level tree. For example: Device Object /3 includes Resource /6 : Available Power Sources. The different Resource Instances describe the different power sources: 0 : DC power 1 : Internal Battery 2 : External Battery 3 : Fuel Cell 4 : Power over Ethernet 5 : USB 6 : AC (Mains) power 7 : Solar To describe the availability of solar power, the URI becomes: /3/0/6/7 Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"LwM2M data format"},{"location":"academy/module2/","text":"Module 2 - Getting Started with LwM2M # Introduction # Welcome to the second module of the LwM2M Academy. In the previous module, we introduced the LwM2M protocol and its key features. In this module, we will dive deeper into the technical details of LwM2M by focusing on the mandatory Objects that must be implemented by all compliant devices. These Objects provide a standardized way to represent various aspects of an IoT device, such as its security settings, device information, and server connection. Additionally, we will discuss the different security modes of LwM2M both in theory as well as in practice. Mandatory Objects are: Security /0 , Server Object /1 & Device /3 Mandatory Objects # LwM2M is a protocol designed for efficient communication between IoT devices and servers. It is a client-server protocol where IoT devices (known as LwM2M Clients ) communicate with LwM2M Servers using various networking technologies such as cellular, WiFi, or Ethernet. To ensure interoperability and standardization among different LwM2M implementations, the protocol defines a set of mandatory Objects that LwM2M Clients must implement. These Objects provide a baseline level of functionality that enables LwM2M Servers to communicate effectively with LwM2M Clients, regardless of the specific use case or vendor. The mandatory Objects cover essential aspects of the LwM2M protocol regarding security, server management, and device management. They enable LwM2M Servers to authenticate and authorize LwM2M Clients, manage their connection, and retrieve important information about their status and capabilities. By defining mandatory objects, the LwM2M protocol ensures that LwM2M implementations are consistent and interoperable, which ultimately leads to greater efficiency, scalability, and ease of deployment for IoT devices and services. The three mandatory Objects are: # Security Object (Object /0 ) - This Object is responsible for the management of security credentials and the establishment of secure communication between the LwM2M Client and the LwM2M Server. It contains Resources for specifying the security mode, identity, keys, and other security-related parameters. Server Object (Object /1 ) - This Object is responsible for the management of the LwM2M Server to which the LwM2M Client is connected. It contains Resources for specifying the server address, lifetime of the registration, and other server-related parameters. Device Object (Object /3 ) - This Object provides information about the LwM2M Client device. It contains Resources for specifying the device manufacturer, model number, firmware version, battery level (if available), and other device-related parameters. The OMA LwM2M Object and Resource Registry The OMA LwM2M Object and Resource Registry is a comprehensive database containing all the LwM2M Objects and Resources that have been defined by the Open Mobile Alliance (OMA). The registry serves as a reference guide for developers who are implementing the LwM2M standard. The Registry is organized by Object ID. Each Object in the Registry is associated with a set of Resources, which are identified by Resource ID. The registry provides clear descriptions, data types, and usage guidelines for each Object and Resource. Open up the Object and Resource Registry and have a look at the Registry and go through the three mandatory Objects. Note: At the time of writing, LwM2M version 1.1 is most commonly used. LwM2M security # Security is a crucial aspect of any IoT deployment. The LwM2M standard defines security features to ensure secure and reliable communication between devices and servers. These security features are critical for protecting IoT devices from attacks and ensuring the authenticity, confidentiality, and integrity of the data exchange. Authentication means that a receiver can determine the sender of a message \u2013 and vice versa. Confidentiality means that only the receiving endpoint can read the sender\u2019s message. Integrity means that the data message has not been tampered with. Two layers of security are implemented when using LwM2M. The transport layer is secured using DTLS (for UDP traffic) or TLS (for TCP traffic). The application layer is protected using OSCORE (optional). DTLS and OSCORE can work together to provide end-to-end security. DTLS/TLS is used to establish a secure channel between the client and server, and OSCORE is used to encrypt and protect messages exchanged within that channel. This approach provides multiple layers of security, ensuring that the communication channel and the data being exchanged within that channel are both protected against unauthorized access and tampering. The transport layer is secured using DTLS or TLS. The application layer is protected using OSCORE. Security modes # There are different ways for the LwM2M Server to authenticate LwM2M Clients. All options as defined in the Security Mode Resource : /0/x/2 . The most commonly used modes are: Pre-Shared Key mode - Communication is symmetrically encrypted and authenticated using the same secret key, shared between the server and the client. Certificate mode - An asymmetrical public-key cryptographic algorithm is used to authenticate the connection endpoints and initialize payload encryption. Appropriate certificates need to be generated for both the LwM2M Client and the LwM2M Server. Public certificates of both parties are mutually available, and each party also has access to its own corresponding private key. NoSec mode - Encryption and authentication are disabled and the messages are passed in plain text over the network. It is not recommended to be used in production environments unless end-to-end security is provided on a lower layer (e.g. IPsec). The NoSec mode is mostly useful for development, testing, and debugging purposes. Bootstrap Server # When using the LwM2M standard, a Bootstrap Server can be used to provision LwM2M Clients. Instead of connecting to the LwM2M Server directly, the Client connects to a Bootstrap Server to derive the necessary configuration information to securely connect to a LwM2M Server. Configuration information includes the address of the LwM2M Server and the security credentials to establish a secure connection. At any time, the LwM2M Server can instruct the device to send a new bootstrap request to update its security credentials, and/or to update the server address it\u2019s connected to. The Bootstrap Server is defined in the LwM2M Server URI Resource: /0/x/0 , and Bootstrap-Server Resource /0/x/1 . Note: Bootstrapping is an advanced feature and won\u2019t be covered in detail throughout this course. Registration # Before telemetry data can be exchanged, the device needs to register to a LwM2M Server. In the registration process, the Client connects to a Server and includes device-specific information such as its name, security credentials, and a list of supported Objects and Object Instances. The Server validates this information and responds whether the registration was successful. At regular intervals, the Client sends update messages informing the Server about being alive and functioning properly. If new Objects, Object Instances, or Resources are added over time, the Server gets synchronized with the Client during the status update message. Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Theory Module 2"},{"location":"academy/module2/#module-2-getting-started-with-lwm2m","text":"","title":"Module 2 - Getting Started with LwM2M"},{"location":"academy/module2/#introduction","text":"Welcome to the second module of the LwM2M Academy. In the previous module, we introduced the LwM2M protocol and its key features. In this module, we will dive deeper into the technical details of LwM2M by focusing on the mandatory Objects that must be implemented by all compliant devices. These Objects provide a standardized way to represent various aspects of an IoT device, such as its security settings, device information, and server connection. Additionally, we will discuss the different security modes of LwM2M both in theory as well as in practice. Mandatory Objects are: Security /0 , Server Object /1 & Device /3","title":"Introduction"},{"location":"academy/module2/#mandatory-objects","text":"LwM2M is a protocol designed for efficient communication between IoT devices and servers. It is a client-server protocol where IoT devices (known as LwM2M Clients ) communicate with LwM2M Servers using various networking technologies such as cellular, WiFi, or Ethernet. To ensure interoperability and standardization among different LwM2M implementations, the protocol defines a set of mandatory Objects that LwM2M Clients must implement. These Objects provide a baseline level of functionality that enables LwM2M Servers to communicate effectively with LwM2M Clients, regardless of the specific use case or vendor. The mandatory Objects cover essential aspects of the LwM2M protocol regarding security, server management, and device management. They enable LwM2M Servers to authenticate and authorize LwM2M Clients, manage their connection, and retrieve important information about their status and capabilities. By defining mandatory objects, the LwM2M protocol ensures that LwM2M implementations are consistent and interoperable, which ultimately leads to greater efficiency, scalability, and ease of deployment for IoT devices and services.","title":"Mandatory Objects"},{"location":"academy/module2/#the-three-mandatory-objects-are","text":"Security Object (Object /0 ) - This Object is responsible for the management of security credentials and the establishment of secure communication between the LwM2M Client and the LwM2M Server. It contains Resources for specifying the security mode, identity, keys, and other security-related parameters. Server Object (Object /1 ) - This Object is responsible for the management of the LwM2M Server to which the LwM2M Client is connected. It contains Resources for specifying the server address, lifetime of the registration, and other server-related parameters. Device Object (Object /3 ) - This Object provides information about the LwM2M Client device. It contains Resources for specifying the device manufacturer, model number, firmware version, battery level (if available), and other device-related parameters. The OMA LwM2M Object and Resource Registry The OMA LwM2M Object and Resource Registry is a comprehensive database containing all the LwM2M Objects and Resources that have been defined by the Open Mobile Alliance (OMA). The registry serves as a reference guide for developers who are implementing the LwM2M standard. The Registry is organized by Object ID. Each Object in the Registry is associated with a set of Resources, which are identified by Resource ID. The registry provides clear descriptions, data types, and usage guidelines for each Object and Resource. Open up the Object and Resource Registry and have a look at the Registry and go through the three mandatory Objects. Note: At the time of writing, LwM2M version 1.1 is most commonly used.","title":"The three mandatory Objects are:"},{"location":"academy/module2/#lwm2m-security","text":"Security is a crucial aspect of any IoT deployment. The LwM2M standard defines security features to ensure secure and reliable communication between devices and servers. These security features are critical for protecting IoT devices from attacks and ensuring the authenticity, confidentiality, and integrity of the data exchange. Authentication means that a receiver can determine the sender of a message \u2013 and vice versa. Confidentiality means that only the receiving endpoint can read the sender\u2019s message. Integrity means that the data message has not been tampered with. Two layers of security are implemented when using LwM2M. The transport layer is secured using DTLS (for UDP traffic) or TLS (for TCP traffic). The application layer is protected using OSCORE (optional). DTLS and OSCORE can work together to provide end-to-end security. DTLS/TLS is used to establish a secure channel between the client and server, and OSCORE is used to encrypt and protect messages exchanged within that channel. This approach provides multiple layers of security, ensuring that the communication channel and the data being exchanged within that channel are both protected against unauthorized access and tampering. The transport layer is secured using DTLS or TLS. The application layer is protected using OSCORE.","title":"LwM2M security"},{"location":"academy/module2/#security-modes","text":"There are different ways for the LwM2M Server to authenticate LwM2M Clients. All options as defined in the Security Mode Resource : /0/x/2 . The most commonly used modes are: Pre-Shared Key mode - Communication is symmetrically encrypted and authenticated using the same secret key, shared between the server and the client. Certificate mode - An asymmetrical public-key cryptographic algorithm is used to authenticate the connection endpoints and initialize payload encryption. Appropriate certificates need to be generated for both the LwM2M Client and the LwM2M Server. Public certificates of both parties are mutually available, and each party also has access to its own corresponding private key. NoSec mode - Encryption and authentication are disabled and the messages are passed in plain text over the network. It is not recommended to be used in production environments unless end-to-end security is provided on a lower layer (e.g. IPsec). The NoSec mode is mostly useful for development, testing, and debugging purposes.","title":"Security modes"},{"location":"academy/module2/#bootstrap-server","text":"When using the LwM2M standard, a Bootstrap Server can be used to provision LwM2M Clients. Instead of connecting to the LwM2M Server directly, the Client connects to a Bootstrap Server to derive the necessary configuration information to securely connect to a LwM2M Server. Configuration information includes the address of the LwM2M Server and the security credentials to establish a secure connection. At any time, the LwM2M Server can instruct the device to send a new bootstrap request to update its security credentials, and/or to update the server address it\u2019s connected to. The Bootstrap Server is defined in the LwM2M Server URI Resource: /0/x/0 , and Bootstrap-Server Resource /0/x/1 . Note: Bootstrapping is an advanced feature and won\u2019t be covered in detail throughout this course.","title":"Bootstrap Server"},{"location":"academy/module2/#registration","text":"Before telemetry data can be exchanged, the device needs to register to a LwM2M Server. In the registration process, the Client connects to a Server and includes device-specific information such as its name, security credentials, and a list of supported Objects and Object Instances. The Server validates this information and responds whether the registration was successful. At regular intervals, the Client sends update messages informing the Server about being alive and functioning properly. If new Objects, Object Instances, or Resources are added over time, the Server gets synchronized with the Client during the status update message. Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Registration"},{"location":"academy/module3/","text":"Module 3 - Building LwM2M Applications # Introduction # LwM2M uses a Client-Server architecture, designed to efficiently communicate data between IoT devices and cloud services. Let\u2019s dive into the communication process and discuss the underlying communication mechanisms to ensure reliable communication of application payload and device management operations. IoT Communication Protocols # In order to convey a message from the device to the cloud and vice versa, both the Client and the Server need to agree on a common language to make sense of the data, as well as a delivery method to communicate effectively. As we learned in the previous modules, the LwM2M standard uses the LwM2M Object Model to format the data so it can be comprehended by both the Client and Server. Let\u2019s have a look at the delivery method which ensures the LwM2M data messages end up in the right place at the right time. CoAP # The LwM2M standard uses the CoAP (Constrained Application) protocol to get the messages from the Client to and from the Server. Think of CoAP as the HTTP protocol, but optimized for resource-constrained devices. CoAP is designed to be lightweight using low overhead due to a small header size and the use of UDP (User Datagram Protocol) as its underlying transport protocol. Because UDP does not guarantee data delivery, CoAP provides message reliability mechanisms, e.g. by allowing devices to send unconfirmed and confirmed messages, the latter needs to be acknowledged by the receiver, hence improving the reliability of the data transfer. Although CoAP supports transmission over TCP, UDP is typically the preferred choice for IoT applications due to its small overhead and simple implementation. This comes at the cost of reliability; UDP does not guarantee data delivery as acknowledgments or retransmissions are not embedded in the protocol. In contrast, TCP does establish and maintain a connection before the start of the data transmission. TCP ensures that data gets delivered by tracking which packets are received and retransmitting the packets which get lost during transmission. This results in more reliability which comes at the cost of larger overhead and higher latency compared to UDP. CoAP vs MQTT MQTT (Message Queuing Telemetry Transport) is the most widely implemented messaging protocol in IoT. MQTT is often compared with CoAP as both protocols provide a lightweight transport mechanism which is well-suited for resource-constrained IoT devices. Whereas CoAP is relatively new with its specifications being introduced in 2014, MQTT dates all the way back to 1999. Even though the messaging protocols can be seemingly used interchangeably, there are some key differences in the architectures. MQTT is a publish-subscribe messaging protocol where clients (IoT Devices) communicate using TCP to a server which is referred to as the Broker. Each message is sent to an address known as a topic, e.g. /temperature. Clients can subscribe to one or multiple topics and get notified when new data is received on any of those topics. Due to the publish-subscribe architecture, communication can happen one-to-one, one-to-many and many-to-one. MQTT knows three levels of Quality of Service (QoS), from 0 to 2 QoS 0: At most once. Data is sent without acknowledgment QoS 1: At least once. A message requires an acknowledgment, ensuring the data reaches the receiver. QoS 2: Exactly once. Through the process of a four-step handshake, the sender ensures the data is received exactly once. A variation of the MQTT protocol is called MQTT-SN (MQTT for Sensor Networks) and is designed for sensor networks as it supports UDP transport. CoAP uses \u2014 similar to HTTP \u2014 a request-response model. It uses UDP by default, but it can also run on top of TCP or SMS. Unconfirmed messages are similar to MQTT QoS 0, confirmed messages with MQTT QoS 1. Similar to MQTT, data is sent to specific addresses. When using CoAP we refer to these addresses as URIs . CoAP provides support for a publish-subscribe architecture; specific resources can be Observed . Every time an observed value changes an update is sent to the Server. Due to the underlying UDP transport layer, CoAP messages are somewhat smaller than MQTT packets due to the smaller overhead. An advantage of CoAP is the interoperability with HTTP. Because of the many similarities, it is relatively easy to translate HTTP requests to and from CoAP requests. LwM2M operations # CoAP took its inspiration from web APIs which depend on the REST architecture. CoAP uses similar methods but optimized for IoT applications. A Client or Server sends a request and \u2013 depending on the request \u2013 awaits a response which includes a response code. The methods used by CoAP are GET, POST, PUT, DELETE, FETCH, and (i)PATCH. Due to its similarities with HTTP, CoAP is interoperable with HTTP with only a translation proxy between the protocols. The CoAP GET request can be used to Observe a specific resource. When a resource updates its value (e.g. after a new sensor reading), the Client directly sends an update to the Server. These CoAP commands are utilized by the LwM2M standard and are referred to as Operations . Operations come in different forms to support the registration of devices, to report telemetry data and to manage device configurations or firmware. All LwM2M Operations are based on the CoAP request/response methods . In the previous modules, we learned about the Bootstrap and Registration processes \u2013 referred to as interfaces . Both interfaces use a combination of CoAP commands. E.g. during the registration process, the LwM2M Client sends a Request operation to the LwM2M Server using a CoAP POST to inform the Server of its existence and provides metadata describing its data model and IP address. When a Bootstrap Server is used, the LwM2M Client sends a Bootstrap-Request (CoAP POST) to trigger the bootstrap sequence, after which the Bootstrap server sends a Bootstrap Discover using the CoAP GET command to request information about the data model supported by the Client. Data encoding formats # Whereas humans comprehend information through words, computers prefer information to be encoded in a more compact way, allowing for faster processing of data. There are different encoding formats (also known as content formats ) which are optimized for resource-constrained devices. LwM2M supports several encoding formats including plain text , opaque , TLV , JSON , CoRE Link , CBOR , and SenML . The different encoding formats are used for different LwM2M Operations, as defined by the specifications . Let\u2019s discuss these formats in more detail. Note It is not required to fully understand the data encoding formats. LwM2M Client libraries automatically encode the information in such a way it meets the encoding and LwM2M data format criteria. Plain text : used for READ and WRITE operations on Resources. Example: Req: Get /3/0/0 Res: 2.05 Content Open Mobile Alliance Opaque : used for READ and WRITE operations on Resources where the value of the Resource is an opaque sequence of binary octets. CBOR : the Concise Binary Object Representation format is used for READ and WRITE operations on Resources. CoRE Link : the CoRE Link content format is used as a response to DISCOVER operations and contains a list of Objects, Objects Instances, Resources and Resource Instances. TLV : the Type-Length-Value format can be used for READ and WRITE operations and represents a singular or an array of values. For example, if the LwM2M Server requests to READ the Device Object Instance /3/0 , the client may reply using TLV payload which includes all readable Resources. TLV payload Translation C8 00 14 4F 70 65 6E 20 4D 6F 62 69 6C 65 20 41 6C 6C 69 61 6E 63 65 C8 01 16 4C 69 67 68 74 77 65 69 67 74 20 4D 32 4D 20 43 6C 69 65 6E 74 C8 02 09 33 34 35 30 30 30 31 32 33 C3 03 31 2E 30 86 06 41 00 01 41 01 05 C1 09 64 /0 Open Mobile Alliance /1 Lightweight M2M Client /2 345000123 /3 1.0 /7 /0 /5 /9 100 SenML (Sensor Measurement Lists) is a popular encoding format used for READ and WRITE operations, specifically with the operations READ-Composite and WRITE-Composite. SenML comes in a SenML JSON and SenML CBOR variant. For example, the following shows a single SenML JSON Record containing temperature ( /3303/x/5700 ), humidity ( /3304/x/5700 ) and location data ( /6/x/0 & /6/0/1 ). [ {\"n\":\"/3303/0/5700\",\"t\":1681817678,\"v\":23.1}, {\"n\":\"/3304/0/5700\",\"t\":1681817678,\"v\":54.4}, {\"n\":\"/6/0/0\",\"t\":1681817678,\"v\":43.61092}, {\"n\":\"/6/0/1\",\"t\":1681817678,\"v\":3.87723}, ] \u201cn\u201d represents the name and follows the LwM2M Object Model, \u201ct\u201d contains the timestamp and \u201cv\u201d field represents the value as a float. Alternative value fields are: Boolean \u201cvb\u201c , Object Link Value \u201cvlo\u201c , Opaque Value \u201cvd\u201c or String \u201cvs\u201c . SenML CBOR follows the same pattern as SenML JSON, but is harder to read for humans. The previous message can also be written in SenML CBOR which is a binary format and looks something like this: A4 83 18 67 98 56 42 02 82 00 18 3B 0F 7B 76 82 00 18 3E 48 3C 29 82 00 18 41 CE 4B FD 82 01 18 3F B2 A7 28 Useful Resources # Efficient transport of telemetry data in IoT with the LwM2M protocol Comparing the efficiency of LwM2M and MQTT: hands-on test results of two technology clients on a typical IoT device LwM2M v1.1 Technical specifications CoAP specifications SenML specifications Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Theory Module 3"},{"location":"academy/module3/#module-3-building-lwm2m-applications","text":"","title":"Module 3 - Building LwM2M Applications"},{"location":"academy/module3/#introduction","text":"LwM2M uses a Client-Server architecture, designed to efficiently communicate data between IoT devices and cloud services. Let\u2019s dive into the communication process and discuss the underlying communication mechanisms to ensure reliable communication of application payload and device management operations.","title":"Introduction"},{"location":"academy/module3/#iot-communication-protocols","text":"In order to convey a message from the device to the cloud and vice versa, both the Client and the Server need to agree on a common language to make sense of the data, as well as a delivery method to communicate effectively. As we learned in the previous modules, the LwM2M standard uses the LwM2M Object Model to format the data so it can be comprehended by both the Client and Server. Let\u2019s have a look at the delivery method which ensures the LwM2M data messages end up in the right place at the right time.","title":"IoT Communication Protocols"},{"location":"academy/module3/#coap","text":"The LwM2M standard uses the CoAP (Constrained Application) protocol to get the messages from the Client to and from the Server. Think of CoAP as the HTTP protocol, but optimized for resource-constrained devices. CoAP is designed to be lightweight using low overhead due to a small header size and the use of UDP (User Datagram Protocol) as its underlying transport protocol. Because UDP does not guarantee data delivery, CoAP provides message reliability mechanisms, e.g. by allowing devices to send unconfirmed and confirmed messages, the latter needs to be acknowledged by the receiver, hence improving the reliability of the data transfer. Although CoAP supports transmission over TCP, UDP is typically the preferred choice for IoT applications due to its small overhead and simple implementation. This comes at the cost of reliability; UDP does not guarantee data delivery as acknowledgments or retransmissions are not embedded in the protocol. In contrast, TCP does establish and maintain a connection before the start of the data transmission. TCP ensures that data gets delivered by tracking which packets are received and retransmitting the packets which get lost during transmission. This results in more reliability which comes at the cost of larger overhead and higher latency compared to UDP. CoAP vs MQTT MQTT (Message Queuing Telemetry Transport) is the most widely implemented messaging protocol in IoT. MQTT is often compared with CoAP as both protocols provide a lightweight transport mechanism which is well-suited for resource-constrained IoT devices. Whereas CoAP is relatively new with its specifications being introduced in 2014, MQTT dates all the way back to 1999. Even though the messaging protocols can be seemingly used interchangeably, there are some key differences in the architectures. MQTT is a publish-subscribe messaging protocol where clients (IoT Devices) communicate using TCP to a server which is referred to as the Broker. Each message is sent to an address known as a topic, e.g. /temperature. Clients can subscribe to one or multiple topics and get notified when new data is received on any of those topics. Due to the publish-subscribe architecture, communication can happen one-to-one, one-to-many and many-to-one. MQTT knows three levels of Quality of Service (QoS), from 0 to 2 QoS 0: At most once. Data is sent without acknowledgment QoS 1: At least once. A message requires an acknowledgment, ensuring the data reaches the receiver. QoS 2: Exactly once. Through the process of a four-step handshake, the sender ensures the data is received exactly once. A variation of the MQTT protocol is called MQTT-SN (MQTT for Sensor Networks) and is designed for sensor networks as it supports UDP transport. CoAP uses \u2014 similar to HTTP \u2014 a request-response model. It uses UDP by default, but it can also run on top of TCP or SMS. Unconfirmed messages are similar to MQTT QoS 0, confirmed messages with MQTT QoS 1. Similar to MQTT, data is sent to specific addresses. When using CoAP we refer to these addresses as URIs . CoAP provides support for a publish-subscribe architecture; specific resources can be Observed . Every time an observed value changes an update is sent to the Server. Due to the underlying UDP transport layer, CoAP messages are somewhat smaller than MQTT packets due to the smaller overhead. An advantage of CoAP is the interoperability with HTTP. Because of the many similarities, it is relatively easy to translate HTTP requests to and from CoAP requests.","title":"CoAP"},{"location":"academy/module3/#lwm2m-operations","text":"CoAP took its inspiration from web APIs which depend on the REST architecture. CoAP uses similar methods but optimized for IoT applications. A Client or Server sends a request and \u2013 depending on the request \u2013 awaits a response which includes a response code. The methods used by CoAP are GET, POST, PUT, DELETE, FETCH, and (i)PATCH. Due to its similarities with HTTP, CoAP is interoperable with HTTP with only a translation proxy between the protocols. The CoAP GET request can be used to Observe a specific resource. When a resource updates its value (e.g. after a new sensor reading), the Client directly sends an update to the Server. These CoAP commands are utilized by the LwM2M standard and are referred to as Operations . Operations come in different forms to support the registration of devices, to report telemetry data and to manage device configurations or firmware. All LwM2M Operations are based on the CoAP request/response methods . In the previous modules, we learned about the Bootstrap and Registration processes \u2013 referred to as interfaces . Both interfaces use a combination of CoAP commands. E.g. during the registration process, the LwM2M Client sends a Request operation to the LwM2M Server using a CoAP POST to inform the Server of its existence and provides metadata describing its data model and IP address. When a Bootstrap Server is used, the LwM2M Client sends a Bootstrap-Request (CoAP POST) to trigger the bootstrap sequence, after which the Bootstrap server sends a Bootstrap Discover using the CoAP GET command to request information about the data model supported by the Client.","title":"LwM2M operations"},{"location":"academy/module3/#data-encoding-formats","text":"Whereas humans comprehend information through words, computers prefer information to be encoded in a more compact way, allowing for faster processing of data. There are different encoding formats (also known as content formats ) which are optimized for resource-constrained devices. LwM2M supports several encoding formats including plain text , opaque , TLV , JSON , CoRE Link , CBOR , and SenML . The different encoding formats are used for different LwM2M Operations, as defined by the specifications . Let\u2019s discuss these formats in more detail. Note It is not required to fully understand the data encoding formats. LwM2M Client libraries automatically encode the information in such a way it meets the encoding and LwM2M data format criteria. Plain text : used for READ and WRITE operations on Resources. Example: Req: Get /3/0/0 Res: 2.05 Content Open Mobile Alliance Opaque : used for READ and WRITE operations on Resources where the value of the Resource is an opaque sequence of binary octets. CBOR : the Concise Binary Object Representation format is used for READ and WRITE operations on Resources. CoRE Link : the CoRE Link content format is used as a response to DISCOVER operations and contains a list of Objects, Objects Instances, Resources and Resource Instances. TLV : the Type-Length-Value format can be used for READ and WRITE operations and represents a singular or an array of values. For example, if the LwM2M Server requests to READ the Device Object Instance /3/0 , the client may reply using TLV payload which includes all readable Resources. TLV payload Translation C8 00 14 4F 70 65 6E 20 4D 6F 62 69 6C 65 20 41 6C 6C 69 61 6E 63 65 C8 01 16 4C 69 67 68 74 77 65 69 67 74 20 4D 32 4D 20 43 6C 69 65 6E 74 C8 02 09 33 34 35 30 30 30 31 32 33 C3 03 31 2E 30 86 06 41 00 01 41 01 05 C1 09 64 /0 Open Mobile Alliance /1 Lightweight M2M Client /2 345000123 /3 1.0 /7 /0 /5 /9 100 SenML (Sensor Measurement Lists) is a popular encoding format used for READ and WRITE operations, specifically with the operations READ-Composite and WRITE-Composite. SenML comes in a SenML JSON and SenML CBOR variant. For example, the following shows a single SenML JSON Record containing temperature ( /3303/x/5700 ), humidity ( /3304/x/5700 ) and location data ( /6/x/0 & /6/0/1 ). [ {\"n\":\"/3303/0/5700\",\"t\":1681817678,\"v\":23.1}, {\"n\":\"/3304/0/5700\",\"t\":1681817678,\"v\":54.4}, {\"n\":\"/6/0/0\",\"t\":1681817678,\"v\":43.61092}, {\"n\":\"/6/0/1\",\"t\":1681817678,\"v\":3.87723}, ] \u201cn\u201d represents the name and follows the LwM2M Object Model, \u201ct\u201d contains the timestamp and \u201cv\u201d field represents the value as a float. Alternative value fields are: Boolean \u201cvb\u201c , Object Link Value \u201cvlo\u201c , Opaque Value \u201cvd\u201c or String \u201cvs\u201c . SenML CBOR follows the same pattern as SenML JSON, but is harder to read for humans. The previous message can also be written in SenML CBOR which is a binary format and looks something like this: A4 83 18 67 98 56 42 02 82 00 18 3B 0F 7B 76 82 00 18 3E 48 3C 29 82 00 18 41 CE 4B FD 82 01 18 3F B2 A7 28","title":"Data encoding formats"},{"location":"academy/module3/#useful-resources","text":"Efficient transport of telemetry data in IoT with the LwM2M protocol Comparing the efficiency of LwM2M and MQTT: hands-on test results of two technology clients on a typical IoT device LwM2M v1.1 Technical specifications CoAP specifications SenML specifications Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Useful Resources"},{"location":"academy/module4/","text":"Module 4: Device Management using LwM2M # Introduction # One of the key reasons people choose LwM2M is its ability to manage IoT devices at scale. Device management is critical for ensuring reliable operation of IoT systems throughout their entire lifetime. Device management involves the remote configuration of device parameters. This includes renewing security credentials, adjusting the intervals between data collections, updating the device\u2019s firmware and modifying device settings such as the APN, WiFi credentials or sensor calibrations. The LwM2M protocol defines a standardized approach for efficiently managing IoT devices deployed in the field. In this module we will dive into the device management capabilities of the standard and explore its features and functionalities in detail. Interfaces # LwM2M specifies four distinct interfaces. We have already discussed two of them in previous modules: the Bootstrap Interface and the Registration Interface (see module 2). The standard defines two additional interfaces: the Device Management Interface and the Information Reporting Interface . Let\u2019s explore these interfaces and understand how they contribute to efficient IoT device management Device Management Interface # The Device Management and Service Enablement Interface (as the full name goes) serves as the primary interface for device management. In this interface, all of the requests are initiated by the LwM2M Server and include standardized instructions which the LwM2M Client needs to act upon. Various Operations can be initiated from the Server, ranging from reading a specific resource and executing a specific task, to writing device parameters and creating new Objects, Instances or Resources. Six different Operations can be sent to the LwM2M Client: DISCOVER : Retrieving the list of Objects and Resources supported by the Client. READ : Retrieving the current value of a specific Resource, or an Instance or Object as a whole. A variation of the READ operations is the READ-Composite which is used when reading multiple Objects, Object Instances and/or Resources in a single request. WRITE : Modifying the value of a specific Resource, Resource Instance, or an Instance or Object as a whole. Variations of the WRITE operation are WRITE-Composite and WRITE-Attributes. WRITE-Composite : Whereas the WRITE operation is limited to one Resource, Instance or Object, the WRITE-Composite operations can be used to updated values of a number of different Resources, Instances and/or Objects. WRITE-Attributes : Altering the attributes related to an Object, Object Instance or Resources, e.g. Minimum Period, Maximum Period, Greater Than, Less Than etc. EXECUTE : Invoking an action or operation on a Resource. For example instructing a device to reset, reboot or upgrade its firmware. CREATE : Creating a new Object Instance. DELETE : Deleting an Object Instance. Information Reporting Interface # The Information Reporting Interface is used by the Client to transmit telemetry data or state changes without explicit request from the LwM2M Server. The triggers for transmitting data can be programmed in the application firmware of the device. In this interface, the Server holds the ability to define the behavior of the device by requesting it to send data based on conditional logic. This involves requesting the Client to send data at specific time intervals (e.g. every 10 minutes), or when values exceed predefined thresholds (e.g. when temperature rises above 30 degrees). This way, the server keeps control over the data flow and can effectively monitor and manage the device's behavior in response to changing conditions or requirements. Server Operation OBSERVE : When the Observe operation is invoked, the Client starts sending NOTIFY messages to the Server about its data or state at configurable intervals. The OBSERVE operation is canceled when sending CANCEL OBSERVE . Set Observation in Coiote IoT Device Management platform Client Operations SEND : The SEND message is used by the Client to send data to the server without explicit request. Depending on the application firmware it can be used to report new measurements or inform the server about a change in telemetry data or state. NOTIFY : In response to the OBSERVE operation initiated from the server, the client sends NOTIFY operations with data. Usually, the server provides a bandwidth in which the client needs to send its data. Either time bound: e.g. at least every 1 hour, but no more than once every 15 minutes, or value bound: e.g. when value is greater than 30, less than 20 or when the value changes by at least 2. Example payload of a SEND operation containing the location and radio signal strength could look something like this (using SenML JSON): [ {\"n\":\"/4/0/2\", \"v\":-49}, {\"n\":\"/6/0/0\", \"v\":43.61092}, {\"n\":\"/6/0/1\", \"v\":3.87723} ] Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Theory Module 4"},{"location":"academy/module4/#module-4-device-management-using-lwm2m","text":"","title":"Module 4: Device Management using LwM2M"},{"location":"academy/module4/#introduction","text":"One of the key reasons people choose LwM2M is its ability to manage IoT devices at scale. Device management is critical for ensuring reliable operation of IoT systems throughout their entire lifetime. Device management involves the remote configuration of device parameters. This includes renewing security credentials, adjusting the intervals between data collections, updating the device\u2019s firmware and modifying device settings such as the APN, WiFi credentials or sensor calibrations. The LwM2M protocol defines a standardized approach for efficiently managing IoT devices deployed in the field. In this module we will dive into the device management capabilities of the standard and explore its features and functionalities in detail.","title":"Introduction"},{"location":"academy/module4/#interfaces","text":"LwM2M specifies four distinct interfaces. We have already discussed two of them in previous modules: the Bootstrap Interface and the Registration Interface (see module 2). The standard defines two additional interfaces: the Device Management Interface and the Information Reporting Interface . Let\u2019s explore these interfaces and understand how they contribute to efficient IoT device management","title":"Interfaces"},{"location":"academy/module4/#device-management-interface","text":"The Device Management and Service Enablement Interface (as the full name goes) serves as the primary interface for device management. In this interface, all of the requests are initiated by the LwM2M Server and include standardized instructions which the LwM2M Client needs to act upon. Various Operations can be initiated from the Server, ranging from reading a specific resource and executing a specific task, to writing device parameters and creating new Objects, Instances or Resources. Six different Operations can be sent to the LwM2M Client: DISCOVER : Retrieving the list of Objects and Resources supported by the Client. READ : Retrieving the current value of a specific Resource, or an Instance or Object as a whole. A variation of the READ operations is the READ-Composite which is used when reading multiple Objects, Object Instances and/or Resources in a single request. WRITE : Modifying the value of a specific Resource, Resource Instance, or an Instance or Object as a whole. Variations of the WRITE operation are WRITE-Composite and WRITE-Attributes. WRITE-Composite : Whereas the WRITE operation is limited to one Resource, Instance or Object, the WRITE-Composite operations can be used to updated values of a number of different Resources, Instances and/or Objects. WRITE-Attributes : Altering the attributes related to an Object, Object Instance or Resources, e.g. Minimum Period, Maximum Period, Greater Than, Less Than etc. EXECUTE : Invoking an action or operation on a Resource. For example instructing a device to reset, reboot or upgrade its firmware. CREATE : Creating a new Object Instance. DELETE : Deleting an Object Instance.","title":"Device Management Interface"},{"location":"academy/module4/#information-reporting-interface","text":"The Information Reporting Interface is used by the Client to transmit telemetry data or state changes without explicit request from the LwM2M Server. The triggers for transmitting data can be programmed in the application firmware of the device. In this interface, the Server holds the ability to define the behavior of the device by requesting it to send data based on conditional logic. This involves requesting the Client to send data at specific time intervals (e.g. every 10 minutes), or when values exceed predefined thresholds (e.g. when temperature rises above 30 degrees). This way, the server keeps control over the data flow and can effectively monitor and manage the device's behavior in response to changing conditions or requirements. Server Operation OBSERVE : When the Observe operation is invoked, the Client starts sending NOTIFY messages to the Server about its data or state at configurable intervals. The OBSERVE operation is canceled when sending CANCEL OBSERVE . Set Observation in Coiote IoT Device Management platform Client Operations SEND : The SEND message is used by the Client to send data to the server without explicit request. Depending on the application firmware it can be used to report new measurements or inform the server about a change in telemetry data or state. NOTIFY : In response to the OBSERVE operation initiated from the server, the client sends NOTIFY operations with data. Usually, the server provides a bandwidth in which the client needs to send its data. Either time bound: e.g. at least every 1 hour, but no more than once every 15 minutes, or value bound: e.g. when value is greater than 30, less than 20 or when the value changes by at least 2. Example payload of a SEND operation containing the location and radio signal strength could look something like this (using SenML JSON): [ {\"n\":\"/4/0/2\", \"v\":-49}, {\"n\":\"/6/0/0\", \"v\":43.61092}, {\"n\":\"/6/0/1\", \"v\":3.87723} ] Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Information Reporting Interface"},{"location":"academy/module5/","text":"Module 5: Firmware Updates Over The Air # Firmware updates over the air (FOTA) are becoming increasingly important as more and more resource-constrained IoT devices are being deployed. Physical access to devices can be expensive or impossible to realize when devices are deployed in remote, hard-to-reach locations. As a result, FOTA is in many cases the only way to fix bugs, patch security vulnerabilities, or add functionality to devices which are deployed in the field. The LwM2M protocol provides a standardized process for remote firmware updates. When developers follow the standardized guidelines provided by the protocol, updating the firmware of resource-constrained devices remotely can be accomplished effortlessly, regardless of the device or platform used. The LwM2M way of updating firmware # Remote firmware updates know many names, such as Firmware Update OTA (FUOTA) or Device Firmware Upgrade (DFU). Device vendors can develop their own custom FOTA mechanisms, however, these implementations are specific to the vendor or platform and cannot be easily ported to other systems. The problem of vendor compatibility can be resolved by adopting the LwM2M standard, which is hardware agnostic and can be implemented on any hardware platform. The LwM2M firmware update process consists of four steps: The LwM2M Client is triggered to initiate the firmware update process The Client downloads the firmware and reports to the LwM2M Server when the download is finished The Client performs the firmware update after validating the integrity and authenticity of the new firmware which is done through a process called secure boot . The Client attempts to run the new firmware and reports the status to the Server. If the update is successful, the device starts running the new firmware, if not, the device performs a rollback to the earlier firmware version. This procedure is defined in detail in the LwM2M specifications (see LwM2M specifications ). To add firmware update capabilities to a device, the Firmware Update Object /5 needs to be implemented containing all essential functionalities for conducting the update and reporting the status. Several LwM2M Clients natively support this Firmware Update Object, including AVSystem\u2019s Anjay LwM2M Client and Zephyr\u2019s LwM2M Client . Updating a device\u2019s firmware using Coiote IoT Device Management platform Download a new firmware # The LwM2M standard defines two methods to perform a firmware update, allowing either the Client or the Server to decide on the best moment to start the download of the new firmware. PULL method # In the PULL scenario, the LwM2M Server provides the device with the address of the server containing the firmware file known as the Package URI . The device subsequently downloads the firmware from the so-called firmware repository at the earliest available opportunity. PUSH method # In the PUSH scenario, the LwM2M Server determines the moment to initiate the firmware download, ideally based on the connectivity conditions. The device must have access to information such as Radio Signal Strength and Link Quality to support such server-side decision making. These resources are available in the LwM2M Connectivity Monitoring Object /4 . Firmware Delivery Methods Firmware Update Object # The FOTA process is defined in the Firmware Update Object /5 . This Object defines the update process using four states (defined by Resource /5/*/3 ), as well as multiple update results (defined by Resource /5/*/5 ) representing the most common outcomes of the firmware update process. Learn more about the Firmware Update Object on the OMA LwM2M Object and Resource Registry . Update States ID State Description state 0 Idle Before downloading and after successfully updating state 1 Downloading The new firmware is on the way state 2 Downloaded The firmware download is completed state 3 Updating The Client starts updating its firmware, after which it changes its state back to Idle Update Results Result Description update result 0 Initial value update result 1 Firmware updated successfully update result 2 Insufficient flash memory for the new firmware package update result 3 Out of RAM during downloading proces update result 4 Connection lost during downloading process update result 5 Integrity check failure for new downloaded package update result 6 Unsupported package type update result 7 Invalid URI update result 8 Firmware update failed update result 9 Unsupported protocol update result 10 Firmware update cancelled update result 11 Firmware update deferred Conclusion # Remote IoT device updates are essential for the long-term success of IoT applications, as physical access to devices is often impossible to realize. Updating firmware remotely poses some serious challenges, such as limited memory, battery capacity, available bandwidth, and unstable connections to the cloud. However, by adopting the LwM2M standard and following a structured approach with standardized states and error codes, developers can ensure that new firmware images can be safely sent to their fleet of devices in the field, regardless of hardware vendor or cloud platform used. Useful Resources # DevZone Firmware update documentation Anjay firmware update documentation Anjay Demo for Zephyr Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Theory Module 5"},{"location":"academy/module5/#module-5-firmware-updates-over-the-air","text":"Firmware updates over the air (FOTA) are becoming increasingly important as more and more resource-constrained IoT devices are being deployed. Physical access to devices can be expensive or impossible to realize when devices are deployed in remote, hard-to-reach locations. As a result, FOTA is in many cases the only way to fix bugs, patch security vulnerabilities, or add functionality to devices which are deployed in the field. The LwM2M protocol provides a standardized process for remote firmware updates. When developers follow the standardized guidelines provided by the protocol, updating the firmware of resource-constrained devices remotely can be accomplished effortlessly, regardless of the device or platform used.","title":"Module 5: Firmware Updates Over The Air"},{"location":"academy/module5/#the-lwm2m-way-of-updating-firmware","text":"Remote firmware updates know many names, such as Firmware Update OTA (FUOTA) or Device Firmware Upgrade (DFU). Device vendors can develop their own custom FOTA mechanisms, however, these implementations are specific to the vendor or platform and cannot be easily ported to other systems. The problem of vendor compatibility can be resolved by adopting the LwM2M standard, which is hardware agnostic and can be implemented on any hardware platform. The LwM2M firmware update process consists of four steps: The LwM2M Client is triggered to initiate the firmware update process The Client downloads the firmware and reports to the LwM2M Server when the download is finished The Client performs the firmware update after validating the integrity and authenticity of the new firmware which is done through a process called secure boot . The Client attempts to run the new firmware and reports the status to the Server. If the update is successful, the device starts running the new firmware, if not, the device performs a rollback to the earlier firmware version. This procedure is defined in detail in the LwM2M specifications (see LwM2M specifications ). To add firmware update capabilities to a device, the Firmware Update Object /5 needs to be implemented containing all essential functionalities for conducting the update and reporting the status. Several LwM2M Clients natively support this Firmware Update Object, including AVSystem\u2019s Anjay LwM2M Client and Zephyr\u2019s LwM2M Client . Updating a device\u2019s firmware using Coiote IoT Device Management platform","title":"The LwM2M way of updating firmware"},{"location":"academy/module5/#download-a-new-firmware","text":"The LwM2M standard defines two methods to perform a firmware update, allowing either the Client or the Server to decide on the best moment to start the download of the new firmware.","title":"Download a new firmware"},{"location":"academy/module5/#pull-method","text":"In the PULL scenario, the LwM2M Server provides the device with the address of the server containing the firmware file known as the Package URI . The device subsequently downloads the firmware from the so-called firmware repository at the earliest available opportunity.","title":"PULL method"},{"location":"academy/module5/#push-method","text":"In the PUSH scenario, the LwM2M Server determines the moment to initiate the firmware download, ideally based on the connectivity conditions. The device must have access to information such as Radio Signal Strength and Link Quality to support such server-side decision making. These resources are available in the LwM2M Connectivity Monitoring Object /4 . Firmware Delivery Methods","title":"PUSH method"},{"location":"academy/module5/#firmware-update-object","text":"The FOTA process is defined in the Firmware Update Object /5 . This Object defines the update process using four states (defined by Resource /5/*/3 ), as well as multiple update results (defined by Resource /5/*/5 ) representing the most common outcomes of the firmware update process. Learn more about the Firmware Update Object on the OMA LwM2M Object and Resource Registry . Update States ID State Description state 0 Idle Before downloading and after successfully updating state 1 Downloading The new firmware is on the way state 2 Downloaded The firmware download is completed state 3 Updating The Client starts updating its firmware, after which it changes its state back to Idle Update Results Result Description update result 0 Initial value update result 1 Firmware updated successfully update result 2 Insufficient flash memory for the new firmware package update result 3 Out of RAM during downloading proces update result 4 Connection lost during downloading process update result 5 Integrity check failure for new downloaded package update result 6 Unsupported package type update result 7 Invalid URI update result 8 Firmware update failed update result 9 Unsupported protocol update result 10 Firmware update cancelled update result 11 Firmware update deferred","title":"Firmware Update Object"},{"location":"academy/module5/#conclusion","text":"Remote IoT device updates are essential for the long-term success of IoT applications, as physical access to devices is often impossible to realize. Updating firmware remotely poses some serious challenges, such as limited memory, battery capacity, available bandwidth, and unstable connections to the cloud. However, by adopting the LwM2M standard and following a structured approach with standardized states and error codes, developers can ensure that new firmware images can be safely sent to their fleet of devices in the field, regardless of hardware vendor or cloud platform used.","title":"Conclusion"},{"location":"academy/module5/#useful-resources","text":"DevZone Firmware update documentation Anjay firmware update documentation Anjay Demo for Zephyr Provide your feedback We're constantly working on improving the LwM2M Academy. Please share with us your feedback about this module so we can create an even better learning experience. Feedback form","title":"Useful Resources"}]}